<html>
<head><title>js-antescript</title></head>
<body>
<h2>AnteScript</h2>
<ul>
	<li>Etymology</li>
	<ul>
		<li>In JavaScript, the operator typically stands in between operands, for example: 52 + 20</li>
		<li>In PostScript, the operator typically stands on the right of the operands, for example: 52 20 add</li>
		<li>In AnteScript, the operator typically stands on the left of the operands, for example: add_ (52) (20)</li>
	</ul>
	<li>Syntax</li>
	<ul>
		<li>In Object Oriented Programming, the method typically stands on the right of the object, for example: circle.surface()</li>
		<li>In Functional Programming, the function stands on the left of the data argument, for example: surface(circle)</li>
		<li>In AnteScript, the application stands on the left of the implementation argument, for example: surface_(circle)</li>
		<li>In AnteScript, the syntax is similar to the Functional Programming syntax</li>
		<li>In AnteScript, applications may be concatenated, for example to compute the surface of the base of a cylinder: surface_(base_)(cylinder)</li>
		<li>In AnteScript, for syntax consistency, the left most application may also be surounded by parentheses, for example: (surface_)(base_)(cylinder)</li>
	</ul>
	<li>Concepts</li>
	<ul>
		<li>Application</li>
		<ul>
			<li>In AnteScript, the concept of application corresponds to the concept of function in Functional Programming</li>
			<li>An application is just a name (unlike a function declaration or definition in Functional Programming)</li>
			<li>An application is typically distinguished from other AnteScript concept by a naming convention (an underscore suffix): surface_</li>
			<li>A style preference consists in surounding an application by parentheses, for example: (surface_)(circle)</li>
			<li>Surounding an application by parentheses is not required (if it is the left most), for example: surface_(circle)</li>
			<li>Two or more levels of applications may be concatenated, to represent for example, the "surface" method of the "shape" interface: (surface_)(shape_)</li>
			<li>Several levels of applications may represent a namespace hierarchy as supported by popular programming languages</li>
			<li>Applications representing a namespace hierarchy are specified in reverse order, for example, the System.Collections.IList namespace hierarchy: (list_)(collections_)(system_)</li>
			<li>Unlike popular programming languages, partial namespace path are first-class citizens, for example, in the System.Collections.IList namespace hierarchy: (list_)(collections_)</li>
			<li>Application concatenation is associtive (but not commutative): ((list_)(collections_))(system_) === (list_)((collections_)(system_))</li>
		</ul>
		<li>Declaration</li>
		<ul>
			<li>In AnteScript, the concept of declaration corresponds to both concepts of class and class consturctor in Object Oriented Programming</li>
			<li>A declaration specifies both the specification and the implementation</li>
			<li>The specification and implementation of a declaration is checked for consistency</li>
			<li>Applying values to a declaration (like calling a class constructor with value arguments) returns a definition</li>
			<li>Declaration can model Algebraic Data Types supported by popular Functional Programmming languages</li>
			<li>A declaration with two (or more) definition values models an additive Algebraic Data Type</li>
			<li>A declaration with one definition value that can be defined from two (or mor) different declarations models an multplicative Algebraic Data Type</li>
		</ul>
		<li>Implementation</li>
		<ul>
			<li>An implementation specifies the code to implement supported applications (like a class definition in Object Oriented Programming)</li>
			<li>An implementation specifies the code to implement supported concatenations of applications (like a private class definition inside a class definition in Object Oriented Programming)</li>
			<li>An implementation may be recursive (in case of concatenation of applications)</li>
		</ul>
		<li>Specification</li>
		<ul>
			<li>A specification lists the supported applications (like a class method declarations in Object Oriented Programming)</li>
			<li>A specification lists the supported concatenations of applications</li>
			<li>A specification may be recursive (in case of concatenation of applications)</li>
		</ul>
		<li>Definition</li>
		<ul>
			<li>In AnteScript, the concept of definition corresponds to the concept of class instance in Object Oriented Programming</li>
			<li>A definition is defined by applying values to a declaration</li>
			<li>A supported application (or a supported concatenation of applications) may be applied to a definition</li>
			<li>Applying an unsupported application (or a unsupported concatenation of applications) to a definition results in an error</li>
		</ul>
		<li>Specification</li>
		<ul>
			<li>In AnteScript, the concept of specification corresponds to the concept of interface or abstract class in Object Oriented Programming</li>
			<li>A specification lists the supported applications</li>
			<li>A specification lists the supported concatenations of applications</li>
			<li>A specification may implement invariant applications and invariant concatenations of applications</li>
			<li>An invariant does not depend on the definition values</li>
			<li>A declaration specifies a specification</li>
			<li>A declaration specifying an implementation for an application not listed in the specification results in an error</li>
			<li>A declaration not specifying an implementation for an application listed in the specification results in an error</li>
			<li>A declaration specifying an implementation for an invariant application in the specification results in an error</li>
		</ul>
		<li>Extension</li>
		<ul>
			<li>In AnteScript, the concept of extension resolves the expression problem in both Functional Programming and Object Oriented Programming</li>
			<li>An extension generates a new definition from a previous definition by specifing the specifiction and implementation for additional applications</li>
			<li>Alternatively, an extension may generate a new specification from a previous specification by specifing the specifiction for additional invariant applications</li>
		</ul>
	</ul>
	<li>Notes</li>
	<ul>
		<li>AnteScript is dynamically typed</li>
		<li>Although AnteScript is dynamically typed, a definition is checked for consistency with its specification before any implmementation is generated and used</li>
		<li>AnteScript supports an Object Oriented Programming form of polymorphism (interface polymorphism) which transparently supports heterogeneous collections</li>
		<li>AnteScript promotes Functional Programming paradigms notably, immutability, referencial transparency, declarative style, composition, point-free style, curying...</li>
		<li>AnteScript does not support inheritance (this is not a lack, this is a feature) except for the relationship between a specification and a definition</li>
		<li>AnteScript does not support overriding (this is not a lack, this is a feature), notably, an invariant application specified in a specification cannot be specified in the associated definition</li>
		<li>In AnteScript, the concept of specification corresponds to the concept of function declaration in Functional Programming</li>
		<li>In AnteScript, the concept of definition corresponds to the concept of function definition in Functional Programming</li>
		<li>In AnteScript, composition is simply the concatenation of applications (point-free), for example, to compose the base of the cynlinder with the surface of the circle: (surface_)(base_)(cylinder)</li>
		<li>AnteScript supports multiple-dispatch, the actual code applied depends on more than one argument, for example to add two operands which are either integer, decimal or string: (add_)(operand1)(operand2)</li>
		<li>AnteScript is currently a JavaScript meta-language (the language keywords which names may be freely chosen are actualy JavaScript functions provided by mean of a 350 line IIFE)</li> 
		<li>AnteScript defines the following keywords: APPLICATION, DECLARATION, SPECIFICATION, IMPLEMENTATION, EXTENSION</li>
		<li>The APPLICATION keyword is used to declare applications, for example in the below example: surface_</li>
		<li>The DECLARATION keyword is used to specify declarations, for example in the below example: cube</li>
		<li>The SPECIFICATION keyword is used to declare specifications, for example in the below example: shape</li>
		<li>The IMPLEMENTATION keyword is used to declare implementations, for example in the below example: cube</li>
		<li>The EXTENSION keyword is used to declare extensions as a special case of specifications and definitions (the expression problem is taken into account by the AnteScript language design in a simple and natural way)</li>
		<li>An application is typically referenced by a JavaScript variable of the same name (using "const" JavaScript keyword to warn about dulicates or "var" to allow independent specifications sharing the same applications)</li>
		<li>Applications are memoized (calling APPLICATION several times with the same name argument always return the same JavaScript function)</li>
		<li>The current implementation of AnteScript has a large overhead compared to direct JavaScript function calls (linear with the level of applications but constant in the total number of applications)</li>
		<li>AnteScript runtime errors are dealt with by providing an optional custom error function (ommited in the below sample)</li>
		<li>AnteScript is currently a proof of concept (the overhead compared to direct JavaScript function calls may impact performance)</li>
		<li>AnteScript is currently implemented using pure functions only (with a significant use of JavaScript WeakMap objects)</li>
		<li>AnteScript could be implemented without the specification concept (loose typing instead of dynamic typing, no invariant application, no interface application) but interface applications help resoning (if not inferring)</li>
		<li>AnteScript could be implemented as a compiled language (obviously, the first compiler would be implemented using the JavaScript version of AnteScript)</li>
	</ul>
	<li>Sample</li>
	<ul><pre>
	const label_ = APPLICATION("label_");
	const surface_ = APPLICATION("surface_");
	const volume_ = APPLICATION("volume_");
	const stretch_ = APPLICATION("stretch_");
	const invariant_ = APPLICATION("invariant_");

	const shape = SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_, implementation => ((volume_)(shape_)(implementation) * (volume_)(shape_)(implementation)) / ((surface_)(shape_)(implementation) * (surface_)(shape_)(implementation) * (surface_)(shape_)(implementation))],
		])],
	]);

	const cube = DECLARATION(IMPLEMENTATION([
		[shape_, IMPLEMENTATION([
			[label_, implementation => side => `cube of side ${side}`],
			[surface_, implementation => side => side * side * 6],
			[volume_, implementation => side => side * side * side],
			[stretch_, implementation => side => k => cube(side * k)],
		])],
	]), shape);

	const sphere = DECLARATION(IMPLEMENTATION([
		[shape_, IMPLEMENTATION([
			[label_, implementation => radius => `sphere of radius ${radius}`],
			[surface_, implementation => radius => radius * radius * Math.PI * 4],
			[volume_, implementation => radius => radius * radius * radius * Math.PI * 4/3],
			[stretch_, implementation => radius => k => sphere(radius * k)],
		])],
	]), shape);

	const cube1 = cube(1);
	const cube2 = (stretch_)(shape_)(cube1)(2);
	const sphere1 = sphere(1);
	const sphere2 = (stretch_)(shape_)(sphere1)(2);

	const label1 = (label_)(cube1); // "cube of side 1"
	const label2 = (label_)(cube2); // "cube of side 2"
	const label3 = (label_)(sphere1); // "sphere of radius 1"
	const label4 = (label_)(sphere2); // "sphere of radius 2"

	const invariant1 = (invariant_)(cube1); // 0.004629629629629629
	const invariant2 = (invariant_)(cube2); // 0.004629629629629629
	const invariant3 = (invariant_)(sphere1); // 0.008841941282883074
	const invariant4 = (invariant_)(sphere2); // 0.008841941282883074

	// open browser console to see test results...
	</pre></ul>
</ul>
<script>
"use strict";

//todo handle recursive implementations like recrsive specifications (more verbose but more strict)

const { APPLICATION, DECLARATION, SPECIFICATION, IMPLEMENTATION, EXTENSION } = (function(){
	function applicationType(){
	}
	function definitionType(){
	}
	function specificationType(){
	}
	function declarationType(){
	}
	function extensionType(){
	}
	function errorType(){
	}
	function TYPE(value, type){
		if (type === specificationType){
			return value !== null && typeof(value) === "object" && value.type === specificationType;
		}
		if (type !== undefined){
			return TYPE(value) === type;
		}
		if (typeof(value) ===  "function"){
			return value(TYPE);
		}
		if (value !== null && typeof(value) === "object"){
			if (value.type === specificationType){
				return specificationType;
			}
		}
	}
	let memoization = new(Map)();
	function APPLICATION(application, definition, error){
		if (definition === TYPE){
			return applicationType;
		}
		switch (TYPE(definition)){
			case applicationType: return APPLICATIONS(error, definition, application);
			case definitionType: return definition(application);
		}
		return error && error("applications applied to an invalid definition or invalid application", [application]);
	}
	function APPLICATIONS(error, application, ...applications){
		return function(definition){
			if (definition === TYPE){
				return applicationType;
			}
			switch (TYPE(definition)){
				case applicationType: return APPLICATIONS(error, definition, application, ...applications);
				case definitionType: {
					return [application, ...applications].reduce(function(definition, application){
						if (typeof(definition) === "function"){	
							return application(definition);
						}
					}, definition);
				}
			}
			return error && error("applications applied to an invalid definition or invalid application", [application, ...applications]);
		};
	}
	function DEFINITIONS(error, applications, specifications, values, implementations, definition){
		return function DEFINITION(application){
			if (application === TYPE){
				return definitionType;
			}
			if (application === undefined){
				return specifications;
			}
			if (TYPE(application) === applicationType){
				const implementation = implementations(application);
				const specification = specifications(application);
				if (implementation === undefined){
					if (specification !== undefined && specification !== errorType && typeof(specification) === "function" && !TYPE(specification, specificationType)){
						return specification(definition?? DEFINITION);
					}
					return error && error("unexpected applications", [...applications, application]);
				}
				if (specification !== errorType){
					if(!TYPE(specification, specificationType)){
						if (typeof(implementation) === "function"){
							return implementation(definition?? DEFINITION)(...values);
						}
						return error && error("applications applied to an invalid function", [...applications, application]);	
					}
					return DEFINITIONS(error, [...applications, application], specification.mapping, values, implementation, definition?? DEFINITION);
				}
				return error && error("unexpected applications", [...applications, application]);
			}
			return error && error("incorrect application", [...applications, application]);
		};
	}
	function MAPPINGS(implementations, specifications){
		const entries = implementations.map(function(item){
			const application = item[0];
			const specification = specifications(application);
			if (TYPE(specification, specificationType)){
				const implementation = item[1];
				return [application, MAPPINGS(implementation, specification.mapping)];
			}
			return item;
		});
		const map = new(WeakMap)(entries);
		return function(application){
			if (application === TYPE){
				return definitionType;
			}
			if (application === undefined){
				return entries.map(item => item[0]);
			}
			return map.get(application);
		};
	}
	function ENTRIES(implementations, specifications){
		if (!TYPE(specifications, specificationType)){
			return implementations;
		}
		return implementations().reduce(function(entries, application){
			const implementation = implementations(application);
			const specification = specifications.mapping(application);
			return [...entries, [application, ENTRIES(implementation, specification)]];
		}, [])
	}
	function OVERSUPPLY(implementations, specifications, ...applications){
		return implementations().reduce(function(oversupply, application){
			if (oversupply !== undefined){
				return oversupply;
			}
			const implementation = implementations(application);
			const specification = specifications(application);
			if (specification === errorType){
				return [application, ...applications];
			}
			if (implementation !== undefined && TYPE(implementation) === definitionType){
				if (specification === undefined || !TYPE(specification, specificationType)){
					return [application, ...applications];
				}
				return OVERSUPPLY(implementation, specification.mapping, application, ...applications);
			}
			if (specification !== undefined){
				return [application, ...applications];
			}
		}, undefined);
	}
	function UNDERSUPPLY(implementations, specifications, ...applications){
		return specifications().reduce(function(undersupply, application){
			if (undersupply !== undefined){
				return undersupply;
			}
			const implementation = implementations(application);
			const specification = specifications(application);
			if (TYPE(specification, specificationType)){
				if (implementation === undefined || TYPE(implementation) !== definitionType){
					return [application, ...applications];
				}
				return UNDERSUPPLY(implementation, specification.mapping, application, ...applications);
			}
			if (specification === undefined){
				if (implementation === undefined){
					return [application, ...applications];
				}
			}
		}, undefined);
	}
	function DUPLICATION(specifications0, specifications, ...applications){
		return specifications.mapping().reduce(function(duplication, application){
			if (duplication !== undefined){
				return duplication;
			}
			const specification0 = specifications0.mapping(application);
			if (specification0 !== errorType){
				const specification = specifications.mapping(application);
				if (!TYPE(specification0, specificationType) || !TYPE(specification, specificationType)){
					return [application, ...applications];
				}
				return DUPLICATION(specification0, specification, application, ...applications);
			}
		}, undefined);
	}
	function SPECIFICATIONS(specifications0, specifications){
		const entries0 = specifications0.mapping().reduce(function(entries, application){
			const specification0 = specifications0.mapping(application);
			const specification = specifications === errorType? errorType: specifications.mapping(application);
			if (specification === errorType){
				return [...entries, [application, specification0]];
			}
			if (!TYPE(specification, specificationType)){
				return [...entries, [application, specification0]];
			}
			return [...entries, [application, SPECIFICATIONS(specification0, specification)]];
		}, []);
		const entries1 = specifications.mapping().reduce(function(entries, application){
			const specification = specifications.mapping(application);
			const specification0 = specifications0 === errorType? errorType: specifications0.mapping(application);
			if (specification0 === errorType){
				return [...entries, [application, specification]];
			}
			if (!TYPE(specification0, specificationType)){
				return [...entries, [application, specification]];
			}
			return entries;
		}, entries0);
		return SPECIFICATION(entries1);
	}
	function DECLARATIONS(implementations0, implementations, specifications0, specifications){
		if (implementations === undefined){
			return implementations0;
		}
		const entries0 = implementations0().reduce(function(entries, application){
			const implementation0 = implementations0(application);
			const specification0 = specifications0.mapping(application);
			const implementation = implementations === undefined? undefined: implementations(application);
			if (implementation === undefined){
				return [...entries, [application, ENTRIES(implementation0, specification0)]];
			}
			const specification = specifications.mapping(application);
			if (!TYPE(specification, specificationType)){
				return [...entries, [application, implementation0]];
			}
			return [...entries, [application, DECLARATIONS(implementation0, implementation, specification0, specification)]];
		}, []);
		const entries1 = implementations().reduce(function(entries, application){
			const implementation = implementations(application);
			const specification = specifications.mapping(application);
			const implementation0 = implementations0 === undefined? undefined: implementations0(application);
			const specification0 = specifications0.mapping(application);
			if (specification0 === errorType){
				return [...entries, [application, ENTRIES(implementation, specification)]];
			}
			if (!TYPE(specification0, specificationType)){
				return [...entries, [application, implementation]];
			}
			return entries;
		}, entries0);
		return entries1;
	}
	function EXTENSION(DECLARATION, implementations0, specifications0, error0){
		return function(implementations, specifications, error){
			const error1 = error !== undefined? error: error0;
			if (!TYPE(specifications, specificationType)){
				return error1 && error1("invalid extension specifications", []);
			}
			const duplication = DUPLICATION(specifications0, specifications);
			if (duplication !== undefined){
				return error1 && error1("specification duplication", duplication);
			}
			const specifications1 = SPECIFICATIONS(specifications0, specifications);
			if (implementations === undefined){
				return DECLARATION(implementations0, specifications1, error1);
			}
			const mappings = MAPPINGS(implementations, specifications.mapping);
			const oversupply = OVERSUPPLY(mappings, specifications.mapping);
			if (oversupply !== undefined){
				return error1 && error1("unexpected extension implementation", oversupply);
			}
			const undersupply = UNDERSUPPLY(mappings, specifications.mapping);
			if (undersupply !== undefined){
				return error1 && error1("missing extension implementation", undersupply);
			}
			const mappings0 = MAPPINGS(implementations0, specifications0.mapping);
			const implementations1 = DECLARATIONS(mappings0, mappings, specifications0, specifications);
			return DECLARATION(implementations1, specifications1, error1);
		};
	}
	function EXTENSIONS(specifications0){
		return function(specifications, error){
			if (!TYPE(specifications, specificationType)){
				return error && error("invalid extension specifications", []);
			}
			const duplication = DUPLICATION(specifications0, specifications);
			if (duplication !== undefined){
				return error && error("specification duplication", duplication);
			}
			const specifications1 = SPECIFICATIONS(specifications0, specifications);
			return specifications1;
		};
	}
	return {
		APPLICATION: function(name, error){
			const memoized = memoization.get(name);
			if (memoized !== undefined){
				return memoized;
			}
			const naming = {
				[name]: function(definition){
					return APPLICATION(application, definition, error);
				},
			};
			const application = naming[name];
			memoization.set(name, application);
			return application;
		},
		SPECIFICATION: function SPECIFICATION(specifications){
			const map = new(WeakMap)(specifications);
			return {
				mapping: function(application){
					if (application === TYPE){
						return specificationType;
					}
					if (application === extensionType){
						return EXTENSIONS(SPECIFICATION(specifications));
					}
					if (application === undefined){
						return specifications.map(item => item[0]);
					}
					const value = map.get(application);
					if (value !== undefined || map.has(application)){
						return value;
					}
					return errorType;
				},
				type: specificationType,
			}; 
		},
		DECLARATION: function DECLARATION(implementations, specifications, error){
			if (!TYPE(specifications, specificationType)){
				return error && error("invalid specifications", []);
			}
			const mappings = MAPPINGS(implementations, specifications.mapping);
			const oversupply = OVERSUPPLY(mappings, specifications.mapping);
			if (oversupply !== undefined){
				return error && error("unexpected implementation", oversupply);
			}
			const undersupply = UNDERSUPPLY(mappings, specifications.mapping);
			if (undersupply !== undefined){
				return error && error("missing implementation", undersupply);
			}
			return function(...values){
				switch(values[0]){
					case TYPE: return declarationType;
					case extensionType: return EXTENSION(DECLARATION, implementations, specifications, error);
				}
				return DEFINITIONS(error, [], specifications.mapping, values, mappings);
			}
		},
		EXTENSION: function EXTENSION(declaration){
			if (TYPE(declaration) === declarationType){
				return declaration(extensionType);
			}
			if (TYPE(declaration, specificationType)){
				return declaration.mapping(extensionType);
			}
			return error && error("invalid declaration", []);
		},
		IMPLEMENTATION: function IMPLEMENTATION(implementation){
			return implementation;
		},
	};
})();

function error(message, applications){
	throw message + ": " + applications.reduce(function(accumulator, application){
		return "(" + application.name + ")" + accumulator;
	}, "");
}

// level 1 applications
var label_ = APPLICATION("label_", error);
var surface_ = APPLICATION("surface_", error);
var volume_ = APPLICATION("volume_", error);
var stretch_ = APPLICATION("stretch_", error);
var invariant_ = APPLICATION("invariant_", error);
var weight_ = APPLICATION("weight_", error);
var alignment_ = APPLICATION("alignment_", error);
var test_ = APPLICATION("test_", error);

// level 2 applications
var shape_ = APPLICATION("shape_", error);
var solid_ = APPLICATION("solid_", error);

const shape = SPECIFICATION([
	[shape_, SPECIFICATION([
		[label_],
		[surface_],
		[volume_],
		[stretch_],
		[invariant_, definition => ((volume_)(shape_)(definition) * (volume_)(shape_)(definition)) / ((surface_)(shape_)(definition) * (surface_)(shape_)(definition) * (surface_)(shape_)(definition))],
		[alignment_],
	])],
]);

const solid = SPECIFICATION([
	[solid_, SPECIFICATION([
		[label_],
		[weight_],
		[alignment_],
		[test_],
	])],
]);

const cube = DECLARATION(IMPLEMENTATION([
	[shape_, IMPLEMENTATION([
		[label_, definition => side => `cube of side ${side}`],
		[surface_, definition => side => side * side * 6],
		[volume_, definition => side => side * side * side],
		[stretch_, definition => side => k => cube(side * k)],
		[alignment_, definition => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
	])],
]), shape, error);

const sphere = DECLARATION(IMPLEMENTATION([
	[shape_, IMPLEMENTATION([
		[label_, definition => radius => `sphere of radius ${radius}`],
		[surface_, definition => radius => radius * radius * Math.PI * 4],
		[volume_, definition => radius => radius * radius * radius * Math.PI * 4/3],
		[stretch_, definition => radius => k => sphere(radius * k)],
		[alignment_, definition => radius => o => typeof o === "number"? o + 2 * radius: alignment_(o)(2 * radius)],
	])],
]), shape, error);

const object = DECLARATION(IMPLEMENTATION([
	[solid_, IMPLEMENTATION([
		[label_, definition => (shape, density) => `object of density ${density} and shape ${label_(shape)}`],
		[weight_, definition => (shape, density) => volume_(shape) * density],
		[alignment_, definition => (shape, density) => o => alignment_(shape)(o)],
		[test_, definition => (shape, density) => weight_(solid_)(definition)],
	])],
]), solid, error);

const cube1 = cube(1);
const cube2 = stretch_(shape_(cube1))(2);
const sphere1 = sphere(1);
const sphere2 = stretch_(shape_(sphere1))(2);

// heterogeneous collection
const shapes = [cube1, cube2, sphere1, sphere2];

const invariants = shapes.reduce(function(results, item){
	return results + label_(shape_(item)) + ": " + invariant_(shape_(item)) + "\n";
}, "invariants: \n");

// <label>: <invariant>
// <label>: <invariant>
// ...
console.log(invariants);

const objects = shapes.map(function(item){
	return object(shape_(item), 10);
});

const weights = objects.reduce(function(results, item){
	return results + label_(solid_(item)) + ": " + weight_(solid_(item)) + "\n";
}, "weights: \n");

// <label>: <weight>
// <label>: <weight>
// ...
console.log(weights);

console.log("alignments:");
console.log("alignment of " + label_(shape_)(cube1) + " And " + label_(shape_)(cube2) + ": " + alignment_(shape_(cube1))(shape_(cube2)));
console.log("alignment of " + label_(shape_)(cube1) + " And " + label_(shape_)(sphere1) + ": " + alignment_(shape_(cube1))(shape_(sphere1)));
console.log("alignment of " + label_(shape_)(cube1) + " And " + label_(solid_)(object(shape_(sphere1), 7)) + ": " + alignment_(shape_(cube1))(solid_(object(shape_(sphere1), 7))));
console.log("alignment of " + label_(solid_)(object(shape_(cube1), 4)) + " And " + label_(shape_)(sphere1) + ": " + alignment_(solid_(object(shape_(cube1), 4)))(shape_(sphere1)));
console.log("alignment of " + label_(solid_)(object(shape_(cube1), 4)) + " And " + label_(solid_)(object(shape_(sphere1), 7)) + ": " + alignment_(solid_(object(shape_(cube1), 4)))(solid_(object(shape_(sphere1), 7))));

console.log("tests:");

const object1 = object(shape_(cube(5)), 15);
const weight1 = weight_(solid_)(object1);
const test1 = test_(solid_)(object1);
console.log(test1 + " === " + weight1 + ": " + (test1 === weight1));

var application0_ = APPLICATION("application0_", error);
var application1_ = APPLICATION("application1_", error);
var application2_ = APPLICATION("application2_", error);
var application3_ = APPLICATION("application3_", error);
var application4_ = APPLICATION("application4_", error);

const definitionTest = DECLARATION(IMPLEMENTATION([
	[application4_, IMPLEMENTATION([
		[application3_, IMPLEMENTATION([
			[application2_, IMPLEMENTATION([
				[application1_, definition => value => value],
			])],
		])],
	])],
]), SPECIFICATION([
	[application4_, SPECIFICATION([
		[application3_, SPECIFICATION([
			[application2_, SPECIFICATION([
				[application1_],
			])],
		])],
	])],
]), error);

const test2 = application1_(application2_)(application3_)(application4_)(definitionTest(222));
console.log(test2 + " === 222: " + (test2 === 222));

const test3 = application1_(application2_)(application3_)(application4_(definitionTest(333)));
console.log(test3 + " === 333: " + (test3 === 333));

const test4 = application1_(application2_)(application3_(application4_(definitionTest(444))));
console.log(test4 + " === 444: " + (test4 === 444));

const test5 = application1_(application2_(application3_(application4_(definitionTest(555)))));
console.log(test5 + " === 555: " + (test5 === 555));

const test6 = application1_(application2_)(application3_(application4_))(definitionTest(666));
console.log(test6 + " === 666: " + (test6 === 666));

const test7 = application1_(application2_(application3_))(application4_)(definitionTest(777));
console.log(test7 + " === 777: " + (test7 === 777));

const test8 = application1_(application2_)(application3_(application4_))(definitionTest(888));
console.log(test8 + " === 888: " + (test8 === 888));

console.log("compositions:");

var value_ = APPLICATION("value_", error);
var next_ = APPLICATION("next_", error);
var previous_ = APPLICATION("previous_", error);
var double_ = APPLICATION("double_", error);
var half_ = APPLICATION("half_", error);

const number = DECLARATION(IMPLEMENTATION([
	[value_, definition => value => value],
	[next_, definition => value => number(value + 1)],
	[previous_, definition => value => number(value - 1)],
	[double_, definition => value => number(value * 2)],
	[half_, definition => value => number(value / 2)],
]), SPECIFICATION([
	[value_],
	[next_],
	[previous_],
	[double_],
	[half_],
]), error);

const composition1 = double_(previous_)(half_)(next_)(number(13));
console.log(value_(composition1) + " === 12: " + (value_(composition1) === 12));

const composition2 = double_(previous_)(half_)(next_(number(13)));
console.log(value_(composition2) + " === 12: " + (value_(composition2) === 12));

const composition3 = double_(previous_)(half_(next_(number(13))));
console.log(value_(composition3) + " === 12: " + (value_(composition3) === 12));

const composition4 = double_(previous_(half_(next_(number(13)))));
console.log(value_(composition4) + " === 12: " + (value_(composition4) === 12));

const composition5 = double_(previous_)(half_(next_))(number(13));
console.log(value_(composition5) + " === 12: " + (value_(composition5) === 12));

const composition6 = double_(previous_(half_))(next_)(number(13));
console.log(value_(composition6) + " === 12: " + (value_(composition6) === 12));

const composition7 = double_(previous_)(half_(next_))(number(13));
console.log(value_(composition7) + " === 12: " + (value_(composition7) === 12));

const composition8 = ((double_)(previous_)(((half_)(next_))(number(13))));
console.log(value_(composition8) + " === 12: " + (value_(composition8) === 12));

const composition9 = (((double_)(previous_))((half_)(next_)))(number(13));
console.log(value_(composition9) + " === 12: " + (value_(composition9) === 12));

console.log("chains:");

var first_ = APPLICATION("first_", error);
var second_ = APPLICATION("second_", error);

const tree = DECLARATION(IMPLEMENTATION([
	[first_, definition => value => typeof(value[0]) === "object"? tree(value[0]): value[0]],
	[second_, definition => value => typeof(value[1]) === "object"? tree(value[1]): value[1]],
]), SPECIFICATION([
	[first_],
	[second_],
]), error);

const tree1 = tree([
	[11, 21],
	[12, 22],
]);

const chain11 = (first_)(first_)(tree1);
console.log(chain11 + " === 11: " + (chain11 === 11));

const chain12 = (first_)(second_)(tree1);
console.log(chain12 + " === 12: " + (chain12 === 12));

const chain21 = (second_)(first_)(tree1);
console.log(chain21 + " === 21: " + (chain21 === 21));

const chain22 = (second_)(second_)(tree1);
console.log(chain22 + " === 22: " + (chain22 === 22));

console.log("combinations:");

var add_ = APPLICATION("add_", error);
var addString_ = APPLICATION("addString_", error);
var addInteger_ = APPLICATION("addInteger_", error);
var addDecimal_ = APPLICATION("addDecimal_", error);
var string_ = APPLICATION("string_", error);
var numerator_ = APPLICATION("numerator_", error);
var denominator_ = APPLICATION("denominator_", error);

const integer = DECLARATION(IMPLEMENTATION([
	[value_, definition => value => value],
	[string_, definition => value => value.toString()],
	[add_, definition => value => addition => addInteger_(addition)(definition)],
	[addInteger_, definition => value => addition => integer(value + value_(addition))],
	[addDecimal_, definition => value => addition => decimal(value * denominator_(addition) + numerator_(addition), denominator_(addition))],
]), SPECIFICATION([
	[value_],
	[string_],
	[add_],
	[addInteger_],
	[addDecimal_],
	[addString_, definition => addition => string(string_(addition) + string_(definition))],
]), error);

const decimal = DECLARATION(IMPLEMENTATION([
	[numerator_, definition => (numerator, denominator) => numerator],
	[denominator_, definition => (numerator, denominator) => denominator],
	[string_, definition => (numerator, denominator) => numerator.toString() + "/" + denominator.toString()],
	[add_, definition => (numerator, denominator) => addition => addDecimal_(addition)(definition)],
	[addInteger_, definition => (numerator, denominator) => addition => decimal(numerator + value_(addition) * denominator, denominator)],
	[addDecimal_, definition => (numerator, denominator) => addition => decimal(numerator * denominator_(addition) + numerator_(addition) * denominator, denominator * denominator_(addition))],
]), SPECIFICATION([
	[numerator_],
	[denominator_],
	[string_],
	[add_],
	[addInteger_],
	[addDecimal_],
	[addString_, definition => addition => string(string_(addition) + string_(definition))],
]), error);

const string = DECLARATION(IMPLEMENTATION([
	[string_, definition => value => value],
	[add_, definition => value => addition => addString_(addition)(definition)],
	[addInteger_, definition => value => addition => string(string_(addition) + value)],
	[addDecimal_, definition => value => addition => string(string_(addition) + value)],
]), SPECIFICATION([
	[string_],
	[add_],
	[addInteger_],
	[addDecimal_],
	[addString_, definition => addition => string(string_(addition) + string_(definition))],
]), error);

const combination1 = (string_)((add_)(integer(13))(integer(10)));
console.log(combination1 + " === 23: " + (combination1 === "23"));

const combination2 = (string_)((add_)(integer(3))(decimal(5, 7)));
console.log(combination2 + " === 26/7: " + (combination2 === "26/7"));

const combination3 = (string_)((add_)(decimal(5, 7))(integer(3)));
console.log(combination3 + " === 26/7: " + (combination3 === "26/7"));

const combination4 = (string_)((add_)(decimal(5, 7))(string("qwerty")));
console.log(combination4 + " === 5/7qwerty: " + (combination4 === "5/7qwerty"));

const combination5 = (string_)((add_)(string("azerty"))(decimal(5, 7)));
console.log(combination5 + " === azerty5/7: " + (combination5 === "azerty5/7"));

const combination6 = (string_)((add_)(string("azerty"))(integer(57)));
console.log(combination6 + " === azerty57: " + (combination6 === "azerty57"));

const combination7 = (string_)((add_)(integer(57))(string("qwerty")));
console.log(combination7 + " === 57qwerty: " + (combination7 === "57qwerty"));

const combination8 = (string_)((add_)(string("azerty"))(string("qwerty")));
console.log(combination8 + " === azertyqwerty: " + (combination8 === "azertyqwerty"));

console.log("recursions:");

var nil_ = APPLICATION("nil_", error);
var head_ = APPLICATION("head_", error);
var tail_ = APPLICATION("tail_", error);
var extent_ = APPLICATION("extent_", error);
var translation_ = APPLICATION("translation_", error);
var collection_ = APPLICATION("collection_", error);
var reduction_ = APPLICATION("reduction_", error);
var array_ = APPLICATION("array_", error);

const list0 = (function(){
	const list = DECLARATION(IMPLEMENTATION([
		[nil_, definition => (head, tail) => nil],
		[head_, definition => (head, tail) => head],
		[tail_, definition => (head, tail) => definition === nil? nil: tail],
		[extent_, definition => (head, tail) => value => list(value, definition)],
		[translation_, definition => (head, tail) => translation => definition === nil? nil: list(translation(head), translation_(tail)(translation))],
		[collection_, definition => (head, tail) => collection => definition === nil? nil: collection(head)? list(head, collection_(tail)(collection)): collection_(tail)(collection)],
		[reduction_, definition => (head, tail) => reduction => accumulation => definition === nil? accumulation: (reduction_(tail)(reduction))(reduction(head)(accumulation))],
	]), SPECIFICATION([
		[nil_],
		[head_],
		[tail_],
		[extent_],
		[translation_],
		[collection_],
		[reduction_],
		[array_, definition => reduction_(definition)(value => accumulation => [value, ...accumulation])([])],
	]), error);
	const nil = list();
	return nil;
})();

const list1 = (extent_)(list0)(10);
const list2 = (extent_)(list1)(100);
const list3 = (extent_)(list2)(1000);

console.log((head_)(list3) + " === 1000: " + ((head_)(list3) === 1000));
console.log((head_)(tail_)(list3) + " === 100: " + ((head_)(tail_)(list3) === 100));
console.log((head_)(tail_)(tail_)(list3) + " === 10: " + ((head_)(tail_)(tail_)(list3) === 10));
console.log((head_)(tail_)(tail_)(tail_)(list3) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(list3) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(list3) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(list3) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list3) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list3) === undefined));

const list4 = (translation_)(list3)(value => value + 1);

console.log((head_)(list4) + " === 1001: " + ((head_)(list4) === 1001));
console.log((head_)(tail_)(list4) + " === 101: " + ((head_)(tail_)(list4) === 101));
console.log((head_)(tail_)(tail_)(list4) + " === 11: " + ((head_)(tail_)(tail_)(list4) === 11));
console.log((head_)(tail_)(tail_)(tail_)(list4) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(list4) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(list4) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(list4) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list4) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list4) === undefined));

const list5 = (collection_)(list4)(value => value !== 101);

console.log((head_)(list5) + " === 1001: " + ((head_)(list5) === 1001));
console.log((head_)(tail_)(list5) + " === 11: " + ((head_)(tail_)(list5) === 11));
console.log((head_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(list5) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(list5) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(list5) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list5) === undefined));

const accumulation4 = (reduction_)(list4)(value => accumulation => value + accumulation)(909);

console.log(accumulation4 + " === 2022: " + (accumulation4 === 2022));

const array4 = (array_)(list4);

console.log(array4 + " === 11,101,1001: " + (JSON.stringify(array4) === "[11,101,1001]"));

console.log("extensions:");

var stretch2_ = APPLICATION("stretch2_", error);
var stretch3_ = APPLICATION("stretch3_", error);

const specificationx = SPECIFICATION([
	[shape_, SPECIFICATION([
		[stretch2_, definition => (stretch_)(shape_)(definition)(2)],
		[stretch3_],
	])],
]);

const cubex = EXTENSION(cube)([
	[shape_, [
		[stretch3_, definition => side => cube(side * 3)],
	]],
], specificationx);

const spherex = EXTENSION(sphere)([
	[shape_, [
		[stretch3_, definition => radius => sphere(radius * 3)],
	]],
], specificationx);

const cubex1 = cubex(1); 
console.log((label_)(shape_)(cubex1) + " === cube of side 1: " + ((label_)(shape_)(cubex1) === "cube of side 1"));

const cubex2 = (stretch2_)(shape_)(cubex1);
console.log((label_)(shape_)(cubex2) + " === cube of side 2: " + ((label_)(shape_)(cubex2) === "cube of side 2"));

const cubex3 = (stretch3_)(shape_)(cubex1);
console.log((label_)(shape_)(cubex3) + " === cube of side 3: " + ((label_)(shape_)(cubex3) === "cube of side 3"));

const spherex1 = spherex(1);
console.log((label_)(shape_)(spherex1) + " === sphere of radius 1: " + ((label_)(shape_)(spherex1) === "sphere of radius 1"));

const spherex2 = (stretch2_)(shape_)(spherex1);
console.log((label_)(shape_)(spherex2) + " === sphere of radius 2: " + ((label_)(shape_)(spherex2) === "sphere of radius 2"));

const spherex3 = (stretch3_)(shape_)(spherex1);
console.log((label_)(shape_)(spherex3) + " === sphere of radius 3: " + ((label_)(shape_)(spherex3) === "sphere of radius 3"));

var stretch2_ = APPLICATION("stretch2_", error);
var stretch4_ = APPLICATION("stretch4_", error);

const specificationxx = EXTENSION(shape)(SPECIFICATION([
	[shape_, SPECIFICATION([
		[stretch2_, definition => (stretch_)(shape_)(definition)(2)],
		[stretch4_, definition => (stretch2_)(shape_)(stretch2_)(shape_)(definition)],
	])],
]), error);

const cubexx = DECLARATION(IMPLEMENTATION([
	[shape_, IMPLEMENTATION([
		[label_, definition => side => `cube of side ${side}`],
		[surface_, definition => side => side * side * 6],
		[volume_, definition => side => side * side * side],
		[stretch_, definition => side => k => cubexx(side * k)],
		[alignment_, definition => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
	])],
]), specificationxx, error);

const spherexx = DECLARATION(IMPLEMENTATION([
	[shape_, IMPLEMENTATION([
		[label_, definition => radius => `sphere of radius ${radius}`],
		[surface_, definition => radius => radius * radius *Math.PI * 4],
		[volume_, definition => radius => radius * radius * radius * Math.PI * 4/3],
		[stretch_, definition => radius => k => spherexx(radius * k)],
		[alignment_, definition => radius => o => typeof o === "number"? o + 2 * radius: alignment_(o)(2 * radius)],
	])],
]), specificationxx, error);

const cubexx1 = cubexx(1); 
console.log((label_)(shape_)(cubexx1) + " === cube of side 1: " + ((label_)(shape_)(cubexx1) === "cube of side 1"));

const cubexx2 = (stretch2_)(shape_)(cubexx1);
console.log((label_)(shape_)(cubexx2) + " === cube of side 2: " + ((label_)(shape_)(cubexx2) === "cube of side 2"));

var stretch2_ = APPLICATION("stretch2_", error);

const cubexx3 = (stretch2_)(shape_)(cubexx1);
console.log((label_)(shape_)(cubexx3) + " === cube of side 2: " + ((label_)(shape_)(cubexx3) === "cube of side 2"));

const cubexx4 = (stretch4_)(shape_)(cubexx1);
console.log((label_)(shape_)(cubexx4) + " === cube of side 4: " + ((label_)(shape_)(cubexx4) === "cube of side 4"));

const spherexx1 = spherexx(1);
console.log((label_)(shape_)(spherexx1) + " === sphere of radius 1: " + ((label_)(shape_)(spherexx1) === "sphere of radius 1"));

const spherexx2 = (stretch2_)(shape_)(spherexx1);
console.log((label_)(shape_)(spherexx2) + " === sphere of radius 2: " + ((label_)(shape_)(spherexx2) === "sphere of radius 2"));

const spherexx4 = (stretch4_)(shape_)(spherexx1);
console.log((label_)(shape_)(spherexx4) + " === sphere of radius 4: " + ((label_)(shape_)(spherexx4) === "sphere of radius 4"));

const cubexxx = EXTENSION(cube)([
	[solid_, [
		[weight_, definition => side => density => density * (volume_)(shape_)(definition)],
	]],
], SPECIFICATION([
	[solid_, SPECIFICATION([
		[weight_],
	])],
]), error);

const cubexxx2 = cubexxx(2); 
console.log((label_)(shape_)(cubexxx2) + " === cube of side 2: " + ((label_)(shape_)(cubexxx2) === "cube of side 2"));

const volumexxx2 = (volume_)(shape_)(cubexxx2);
console.log(volumexxx2 + " === 8: " + (volumexxx2 === 8));

const weightxxx2 = (weight_)(solid_)(cubexxx2)(10);
console.log(weightxxx2 + " === 80: " + (weightxxx2 === 80));

console.log("exceptions:");

try{
	(stretch_)(shape_)(solid_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected applications: (solid_)": ' + (exception === "unexpected applications: (solid_)"));
}

try{
	(solid_)(stretch_)(shape_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid definition or invalid application: (solid_)": ' + (exception === "applications applied to an invalid definition or invalid application: (solid_)"));
}

try{
	(weight_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected applications: (weight_)": ' + (exception === "unexpected applications: (weight_)"));
}

try{
	(solid_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected applications: (solid_)": ' + (exception === "unexpected applications: (solid_)"));
}

try{
	(shape_)(x => 2 * x);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid definition or invalid application: (shape_)": ' + (exception === "applications applied to an invalid definition or invalid application: (shape_)"));
}

try{
	(shape_)(2);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid definition or invalid application: (shape_)": ' + (exception === "applications applied to an invalid definition or invalid application: (shape_)"));
}

try{
	(shape_)();
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid definition or invalid application: (shape_)": ' + (exception === "applications applied to an invalid definition or invalid application: (shape_)"));
}

try{
	(label_)(shape_)(1234);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid definition or invalid application: (label_)(shape_)": ' + (exception === "applications applied to an invalid definition or invalid application: (label_)(shape_)"));
}

try{
	(label_)(shape_)();
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid definition or invalid application: (label_)(shape_)": ' + (exception === "applications applied to an invalid definition or invalid application: (label_)(shape_)"));
}

try{
	(label_)(shape_)(x => 1234);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid definition or invalid application: (label_)(shape_)": ' + (exception === "applications applied to an invalid definition or invalid application: (label_)(shape_)"));
}

try{
	const cube = DECLARATION(IMPLEMENTATION([
		[shape_, IMPLEMENTATION([
			[label_, definition => side => `cube of side ${side}`],
			[volume_, definition => side => side * side * side],
			[alignment_, definition => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		])],
	]), SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_, definition => (volume_(definition) * volume_(definition)) / (surface_(definition) * surface_(definition) * surface_(definition))],
			[alignment_],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "missing implementation: (shape_)(surface_)": ' + (exception === "missing implementation: (shape_)(surface_)"));
}

try{
	const cube = DECLARATION(IMPLEMENTATION([
		[shape_, IMPLEMENTATION([
			[label_, definition => side => `cube of side ${side}`],
			[surface_, definition => side => side * side * 6],
			[volume_, definition => side => side * side * side],
			[stretch_, definition => side => k => cube(side * k)],
			[invariant_, definition => side => 1],
			[alignment_, definition => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		])],
	]), SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_, definition => (volume_(definition) * volume_(definition)) / (surface_(definition) * surface_(definition) * surface_(definition))],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected implementation: (shape_)(invariant_)": ' + (exception === "unexpected implementation: (shape_)(invariant_)"));
}

try{
	const cube = DECLARATION(IMPLEMENTATION([
		[shape_, IMPLEMENTATION([
			[label_, definition => side => `cube of side ${side}`],
			[surface_, definition => side => side * side * 6],
			[volume_, definition => side => side * side * side],
			[stretch_, definition => side => k => cube(side * k)],
			[invariant_],
			[alignment_, definition => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		])],
	]), SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_],
			[alignment_],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "missing implementation: (shape_)(invariant_)": ' + (exception === "missing implementation: (shape_)(invariant_)"));
}

try{
	const cube = DECLARATION(IMPLEMENTATION([
		[shape_, IMPLEMENTATION([
			[label_, definition => side => `cube of side ${side}`],
			[surface_, definition => side => side * side * 6],
			[volume_, definition => side => side * side * side],
			[stretch_, definition => side => k => cube(side * k)],
			[alignment_, definition => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		])],
	]), SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_],
			[alignment_],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "missing implementation: (shape_)(invariant_)": ' + (exception === "missing implementation: (shape_)(invariant_)"));
}








try{
	const cubex = EXTENSION(cube)([
		[shape_, [
			[label_, definition => side => `cube of side ${side}`],
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "specification duplication: (shape_)(label_)": ' + (exception === "specification duplication: (shape_)(label_)"));
}

try{
	const cubex = EXTENSION(cube)([
		[shape_, [
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "specification duplication: (shape_)(label_)": ' + (exception === "specification duplication: (shape_)(label_)"));
}

try{
	const cubex = EXTENSION(cube)([
		[shape_, [
			[label_, definition => side => `cube of side ${side}`],
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected extension implementation: (shape_)(label_)": ' + (exception === "unexpected extension implementation: (shape_)(label_)"));
}

try{
	const cubex = EXTENSION(cube)([
		[shape_, definition => side => `cube of side ${side}`],
	], SPECIFICATION([
		[shape_],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "specification duplication: (shape_)": ' + (exception === "specification duplication: (shape_)"));
}

/* //todo
try{
	const cubex = EXTENSION(cube)([
		[solid_],
	], SPECIFICATION([
		[solid_, SPECIFICATION([
			[weight_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected extension implementation: (shape_)(label_)": ' + (exception === "unexpected extension implementation: (shape_)(label_)"));
}
*/ //todo

console.log("debugs:");

const debug1 = cube(1)()().map(application => application.name);
console.log(JSON.stringify(debug1) + ' === ["shape_"]: ' + (JSON.stringify(debug1) === '["shape_"]'));

const debug2 = cube(1)()(shape_).mapping().map(application => application.name);
console.log(JSON.stringify(debug2) + ' === ["label_","surface_","volume_","stretch_","invariant_","alignment_"]: ' + (JSON.stringify(debug2) === '["label_","surface_","volume_","stretch_","invariant_","alignment_"]'));

const debug3 = cube(1)()(shape_).mapping(alignment_);
console.log(debug3 + ' === undefined: ' + (debug3 === undefined));

const debug4 = cube(1)()(shape_).mapping(solid_);
console.log(typeof(debug4) + ' === function: ' + (typeof(debug4) === "function"));

const debug5 = cube(1)()(shape_).mapping(solid_)();
console.log(debug5 + ' === undefined: ' + (debug5 === undefined));


</script>
</body>
</html>