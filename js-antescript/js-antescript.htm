<html>
<head><title>js-antescript</title></head>
<body>
<h2>AnteScript</h2>
<ul>
	<li>Naming</li>
	<ul>
		<li>In JavaScript, the operator typically stands in between operands, for example: 52 + 20</li>
		<li>In PostScript, the operator typically stands on the right of the operands, for example: 52 20 +</li>
		<li>In AnteScript, the operator typically stands on the left of the operands, for example: addition_(52)(20)</li>
	</ul>
	<li>Syntax</li>
	<ul>
		<li>In Object Oriented Programming, the method typically stands on the right of the object, for example: circle.surface()</li>
		<li>In Functional Programming, the function stands on the left of the data argument, for example: surface(circle)</li>
		<li>In AnteScript, the application stands on the left of the implementation argument, for example: surface_(circle)</li>
		<li>In AnteScript, the syntax is similar to the Functional Programming syntax</li>
	</ul>
	<li>Concepts</li>
	<ul>
		<li>Application</li>
		<ul>
			<li>In AnteScript, the concept of application corresponds to the concept of function in Functional Programming</li>
			<li>An application is just a declaration (unlike a function definition in Functional Programming)</li>
			<li>An application is typically distinguished from other AnteScript concept by a naming convention (an underscore suffix): surface_</li>
			<li>A style preference consists in surounding an application by parentheses, for example: (surface_)(circle)</li>
			<li>Surounding an application by parentheses is not required (if it is the left most), for example: surface_(circle)</li>
			<li>Two or more levels of applications may be concatenated, to represent for example, the "surface" method of the "shape" interface: (surface_)(shape_)</li>
			<li>Several levels of applications may represent a namespace hierarchy as supported by popular programming languages</li>
			<li>Applications representing a namespace hierarchy are specified in reverse order, for example, the System.Collections.IList namespace hierarchy: (list_)(collections_)(system_)</li>
			<li>Unlike popular programming languages, partial namespace path are first-class citizens, for example, in the System.Collections.IList namespace hierarchy: (list_)(collections_)</li>
			<li>Application concatenation is associtive (but not commutative): ((list_)(collections_))(system_) === (list_)((collections_)(system_))</li>
		</ul>
		<li>Definition</li>
		<ul>
			<li>In AnteScript, the concept of definition corresponds to both concepts of class and class consturctor in Object Oriented Programming</li>
			<li>A definition specifies the code to implement supported applications (like a class definition)</li>
			<li>A definition specifies the code to implement supported concatenations of applications (like a private class definitions inside a class definition)</li>
			<li>Applying values to a definition (like calling a class constructor with value arguments) returns an implementation</li>
			<li>Definitions can model Algebraic Data Types supported by popular Functional Programmming languages</li>
			<li>A definition with two (or more) implementation values models an additive Algebraic Data Type</li>
			<li>A definition with one implementation value that can be generated from two (or mor) different definitions models an multplicative Algebraic Data Type</li>
		</ul>
		<li>Implementation</li>
		<ul>
			<li>In AnteScript, the concept of implementation corresponds to the concept of class instance in Object Oriented Programming</li>
			<li>A supported application (or a supported concatenation of applications) may be applied to an implementation</li>
			<li>Applying an unsupported application (or a unsupported concatenation of applications) to an implementation results in an error</li>
		</ul>
		<li>Specification</li>
		<ul>
			<li>In AnteScript, the concept of specification corresponds to the concept of interface definition in Object Oriented Programming</li>
			<li>A specification lists the supported applications</li>
			<li>A specification lists the supported concatenations of applications</li>
			<li>A specification specifies the code for invariant applications and invariant concatenations of applications</li>
			<li>An invariant only depends on the definition</li>
			<li>An invariant does not depend on the values of the implementation</li>
			<li>A definition specifies a specification</li>
			<li>A definition specifying code for an application not listed in the specification results in an error</li>
			<li>A definition not specifying code for an application listed in the specification results in an error</li>
			<li>A definition specifying code for an invariant application in the specification results in an error</li>
		</ul>
		<li>Extension</li>
		<ul>
			<li>In AnteScript, the concept of extension resolves the expression problem in both Functional Programming and Object Oriented Programming</li>
			<li>An extension generates a new definition from a previous definition by specifing the specifiction and implementation for additional applications</li>
		</ul>
	</ul>
	<li>Notes</li>
	<ul>
		<li>AnteScript is dynamically typed</li>
		<li>Although AnteScript is dynamically typed, a definition is checked for consistency with its specification before any implmementation is generated and used</li>
		<li>AnteScript supports an Object Oriented Programming form of polymorphism (interface polymorphism) which may be used in heterogeneous collections</li>
		<li>AnteScript promotes Functional Programming paradigms notably, immutability, referencial transparency, declarative style, composition, point-free style, curying...</li>
		<li>AnteScript does not support inheritance (this is not a lack, this is a feature) except for the relationship between a specification and a definition</li>
		<li>AnteScript does not support overriding (this is not a lack, this is a feature), notably, an invariant application specified in a specification cannot be specified in the associated definition</li>
		<li>In AnteScript, the concept of specification corresponds to the concept of function declaration in Functional Programming</li>
		<li>In AnteScript, the concept of definition corresponds to the concept of function definition in Functional Programming</li>
		<li>In AnteScript, composition is simply the concatenation of applications (point-free), for example, to compose the base of the cynlinder with the surface of the circle: (surface_)(base_)(cylinder)</li>
		<li>AnteScript is currently a JavaScript meta-language, based on the following keywords (actually JavaScript function): APPLICATION, DEFINITION, SPECIFICATION, EXTENSION</li>
		<li>The APPLICATION keyword is used to declare applications, for example in the below example: surface_</li>
		<li>The SPECIFICATION keyword is used to declare specifications, for example in the below example: specification</li>
		<li>The DEFINITION keyword is used to declare definitions, for example in the below example: cube</li>
		<li>The EXTENSION keyword is used to declare extensions as a special case of specifications and definitions (the expression problem is taken into account by the AnteScript language design in a simple and natural way)</li>
		<li>AnteScript key-words are actually JavaScript functions provided by an IIFE function (their names may be chosen freely)</li>
		<li>The APPLICATION boilerplate syntax, based on a JavaScript function definition, is needed to access the name of the application in error report and debugging</li>
		<li>The current implementation of AnteScript has a large over head for compared to direct JavaScript function calls (linear with the level of applications but constant in the total number of applications)</li>
		<li>AnteScript runtime errors are dealt with by providing an optional custom error function (ommited in the below sample)</li>
	</ul>
	<li>Sample</li>
	<ul><pre>
	function label_(implementation){ return APPLICATION(label_, implementation); }
	function surface_(implementation){ return APPLICATION(surface_, implementation); }
	function volume_(implementation){ return APPLICATION(volume_, implementation); }
	function stretch_(implementation){ return APPLICATION(stretch_, implementation); }
	function invariant_(implementation){ return APPLICATION(invariant_, implementation); }

	const specifications = SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_, implementation => (volume_(implementation) * volume_(implementation)) / (surface_(implementation) * surface_(implementation) * surface_(implementation))],
		])],
	]);

	const cube = DEFINITION([
		[shape_, [
			[label_, implementation => side => `cube of side ${side}`],
			[surface_, implementation => side => side * side * 6],
			[volume_, implementation => side => side * side * side],
			[stretch_, implementation => side => k => cube(side * k)],
		]],
	], specifications);

	const sphere = DEFINITION([
		[shape_, [
			[label_, implementation => radius => `sphere of radius ${radius}`],
			[surface_, implementation => radius => radius * radius *Math.PI * 4],
			[volume_, implementation => radius => radius * radius * radius * Math.PI * 4/3],
			[stretch_, implementation => radius => k => sphere(radius * k)],
		]],
	], specifications);

	const cube1 = cube(1);
	const cube2 = (stretch_)(shape_)(cube1)(2);
	const sphere1 = sphere(1);
	const sphere2 = (stretch_)(shape_)(sphere1)(2);

	const label1 = (label_)(cube1); // "cube of side 1"
	const label2 = (label_)(cube2); // "cube of side 2"
	const label3 = (label_)(sphere1); // "sphere of radius 1"
	const label4 = (label_)(sphere2); // "sphere of radius 2"

	const invariant1 = (invariant_)(cube1); // 0.004629629629629629
	const invariant2 = (invariant_)(cube2); // 0.004629629629629629
	const invariant3 = (invariant_)(sphere1); // 0.008841941282883074
	const invariant4 = (invariant_)(sphere2); // 0.008841941282883074

	// open browser console to see test results...
	</pre></ul>
</ul>
<script>
"use strict";

//todo EXTENSION of specification (in addition ot EXTENSION of definition)

const { APPLICATION, SPECIFICATION, DEFINITION, EXTENSION } = (function(){
	function applicationType(){
	}
	function implementationType(){
	}
	function specificationType(){
	}
	function definitionType(){
	}
	function extensionType(){
	}
	function errorType(){
	}
	function TYPE(value, type){
		if (type === specificationType){
			return value !== null && typeof(value) === "object" && value.type === specificationType;
		}
		if (type !== undefined){
			return TYPE(value) === type;
		}
		if (typeof(value) ===  "function"){
			return value(TYPE);
		}
		if (value !== null && typeof(value) === "object"){
			if (value.type === specificationType){
				return specificationType;
			}
		}
	}
	function APPLICATIONS(error, application, ...applications){
		return function(implementation){
			if (implementation === TYPE){
				return applicationType;
			}
			switch (TYPE(implementation)){
				case applicationType: return APPLICATIONS(error, implementation, application, ...applications);
				case implementationType: {
					return [application, ...applications].reduce(function(implementation, application){
						if (typeof(implementation) === "function"){	
							return application(implementation);
						}
					}, implementation);
				}
			}
			return error && error("applications applied to an invalid argument", [application, ...applications]);
		};
	}
	function IMPLEMENTATIONS(applications, specifications, properties, definitions, implementation){
		return function IMPLEMENTATION(application){
			if (application === TYPE){
				return implementationType;
			}
			if (application === undefined){
				return specifications;
			}
			if (TYPE(application) === applicationType){
				const definition = definitions(application);
				const specification = specifications(application);
				if (definition === undefined){
					if (specification !== undefined && specification !== errorType && !TYPE(specification, specificationType)){ //todo check typeof(specification)==="function" in DEFINITION
						return specification(IMPLEMENTATION);
					}
					return error && error("unexpected applications", [...applications, application]);
				}
				if (specification !== errorType){
					if(!TYPE(specification, specificationType)){
						return definition(implementation?? IMPLEMENTATION)(...properties); //todo check typeof(implementation)==="function" in DEFINITION
					}
					return IMPLEMENTATIONS([...applications, application], specification.mapping, properties, definition, implementation?? IMPLEMENTATION);
				}
				return error && error("unexpected applications", [...applications, application]);
			}
			return error && error("incorrect application", [...applications, application]);
		};
	}
	function MAPPINGS(definitions, specifications){
		const entries = definitions.map(function(item){
			const application = item[0];
			const specification = specifications(application);
			if (TYPE(specification, specificationType)){
				const definition = item[1];
				return [application, MAPPINGS(definition, specification.mapping)];
			}
			return item;
		});
		const map = new(WeakMap)(entries);
		return function(application){
			if (application === TYPE){
				return implementationType;
			}
			if (application === undefined){
				return entries.map(item => item[0]);
			}
			return map.get(application);
		};
	}
	function OVERSUPPLIES(definitions, specifications, ...applications){
		const oversupplies = definitions().reduce(function(oversupplies, application){
			if (oversupplies.length !== 0){
				return oversupplies;
			}
			const definition = definitions(application);
			const specification = specifications(application);
			if (specification === errorType){
				return [application, ...applications];
			}
			if (definition !== undefined && TYPE(definition) === implementationType){
				if (specification === undefined || !TYPE(specification, specificationType)){
					return [application, ...applications];
				}
				return OVERSUPPLIES(definition, specification.mapping, application, ...applications);
			}
			if (specification !== undefined){
				return [application, ...applications];
			}
			return oversupplies;
		}, []); //todo pass undefined instead of []
		return oversupplies; //todo remove intermediate variable
	}
	function UNDERSUPPLIES(definitions, specifications, ...applications){
		const undersupplies = specifications().reduce(function(undersupplies, application){
			if (undersupplies.length !== 0){
				return undersupplies;
			}
			const definition = definitions(application);
			if (applications.length === 0 && (definition === undefined)){
				return undersupplies;
			}
			const specification = specifications(application);
			if (TYPE(specification, specificationType)){
				if (definition === undefined || TYPE(definition) !== implementationType){
					return [application, ...applications];
				}
				return UNDERSUPPLIES(definition, specification.mapping, application, ...applications);
			}
			if (specification === undefined){
				if (definition === undefined){
					return [application, ...applications];
				}
			}
			return undersupplies;
		}, []); //todo pass undefined instead of []
		return undersupplies; //todo remove intermediate variable
	}
	function DUPLICATION(specifications0, specifications, ...applications){
		return specifications.mapping().reduce(function(duplication, application){
			if (duplication !== undefined){
				return duplication;
			}
			const specification0 = specifications0.mapping(application);
			if (specification0 !== errorType){
				const specification = specifications.mapping(application);
				if (!TYPE(specification0, specificationType) || !TYPE(specification, specificationType)){
					return [application, ...applications];
				}
				return DUPLICATION(specification0, specification, application, ...applications);
			}
		}, undefined);
	}
	function SPECIFICATIONS(specifications0, specifications){
		const entries0 = specifications0.mapping().reduce(function(entries, application){
			const specification0 = specifications0.mapping(application);
			const specification = specifications === errorType? errorType: specifications.mapping(application);
			if (specification === errorType){
				return [...entries, [application, specification0]];
			}
			if (!TYPE(specification, specificationType)){
				return [...entries, [application, specification0]];
			}
			return [...entries, [application, SPECIFICATIONS(specification0, specification)]];
		}, []);
		const entries1 = specifications.mapping().reduce(function(entries, application){
			const specification = specifications.mapping(application);
			const specification0 = specifications0 === errorType? errorType: specifications0.mapping(application);
			if (specification0 === errorType){
				return [...entries, [application, specification]];
			}
			if (!TYPE(specification0, specificationType)){
				return [...entries, [application, specification]];
			}
			return entries;
		}, entries0);
		return SPECIFICATION(entries1);
	}
	function DEFINITIONS(definitions0, definitions, specifications0, specifications){
		if (definitions === undefined){
			return definitions0;
		}
		const entries0 = definitions0().reduce(function(entries, application){
			const definition0 = definitions0(application);
			const definition = definitions === undefined? undefined: definitions(application);
			if (definition === undefined){
				return [...entries, [application, definition0]];
			}
			const specification = specifications.mapping(application);
			if (!TYPE(specification, specificationType)){
				return [...entries, [application, definition0]];
			}
			const specification0 = specifications0.mapping(application);
			return [...entries, [application, DEFINITIONS(definition0, definition, specification0, specification)]];
		}, []);
		const entries1 = definitions().reduce(function(entries, application){
			const definition = definitions(application);
			const definition0 = definitions0 === undefined? undefined: definitions0(application);
			const specification0 = specifications0.mapping(application);
			if (specification0 === undefined){
				return [...entries, [application, definition]];
			}
			if (!TYPE(specification0, specificationType)){
				return [...entries, [application, definition]];
			}
			return entries;
		}, entries0);
		return entries1;
	}
	function EXTENSION(DEFINITION, definitions0, specifications0, error0){
		return function(definitions, specifications, error){
			if (!TYPE(specifications, specificationType)){
				return error && error("invalid extension specifications", []);
			}
			const duplication = DUPLICATION(specifications0, specifications);
			if (duplication !== undefined){
				return error && error("specification duplication", duplication);
			}
			if (definitions !== undefined){
				const mappings = MAPPINGS(definitions, specifications.mapping);
				const oversupplies = OVERSUPPLIES(mappings, specifications.mapping);
				if (oversupplies.length !== 0){
					return error && error("unexpected extension definition", oversupplies);
				}
				const undersupplies = UNDERSUPPLIES(mappings, specifications.mapping);
				if (undersupplies.length !== 0){
					return error && error("missing extension definition", undersupplies);
				}
			}
			const specifications1 = SPECIFICATIONS(specifications0, specifications);
			const definitions1 = definitions === undefined? definitions0: DEFINITIONS(MAPPINGS(definitions0, specifications0.mapping), MAPPINGS(definitions, specifications.mapping), specifications0, specifications);
			const error1 = error !== undefined? error: error0;
			return DEFINITION(definitions1, specifications1, error1);
		};
	}
	return {
		APPLICATION: function APPLICATION(application, implementation, error){
			if (implementation === TYPE){
				return applicationType;
			}
			switch (TYPE(implementation)){
				case applicationType: return APPLICATIONS(error, implementation, application);
				case implementationType: return implementation(application);
			}
			return error && error("applications applied to an invalid argument", [application]);
		},
		SPECIFICATION: function SPECIFICATION(specifications){
			const map = new(WeakMap)(specifications);
			return {
				mapping: function(application){
					if (application === TYPE){
						return specificationType;
					}
					if (application === undefined){
						return specifications.map(item => item[0]);
					}
					const value = map.get(application);
					if (value !== undefined || map.has(application)){
						return value;
					}
					return errorType;
				},
				type: specificationType,
			}; 
		},
		DEFINITION: function DEFINITION(definitions, specifications, error){
			if (!TYPE(specifications, specificationType)){
				return error && error("invalid specifications", []);
			}
			const mappings = MAPPINGS(definitions, specifications.mapping);
			const oversupplies = OVERSUPPLIES(mappings, specifications.mapping);
			if (oversupplies.length !== 0){
				return error && error("unexpected definition", oversupplies);
			}
			const undersupplies = UNDERSUPPLIES(mappings, specifications.mapping);
			if (undersupplies.length !== 0){
				return error && error("missing definition", undersupplies);
			}
			return function(...properties){
				switch(properties[0]){
					case TYPE: return definitionType;
					case extensionType: return EXTENSION(DEFINITION, definitions, specifications, error);
				}
				return IMPLEMENTATIONS([], specifications.mapping, properties, mappings);
			}
		},
		EXTENSION: function EXTENSION(definition){
			if (TYPE(definition)){
				return definition(extensionType);
			}
			return error && error("invalid definition", []);
		},
	};
})();

function error(message, applications){
	throw message + ": " + applications.reduce(function(accumulator, application){
		return "(" + application.name + ")" + accumulator;
	}, "");
}

// level 1 applications
function label_(implementation){ return APPLICATION(label_, implementation, error); }
function surface_(implementation){ return APPLICATION(surface_, implementation, error); }
function volume_(implementation){ return APPLICATION(volume_, implementation, error); }
function stretch_(implementation){ return APPLICATION(stretch_, implementation, error); }
function invariant_(implementation){ return APPLICATION(invariant_, implementation, error); }
function weight_(implementation){ return APPLICATION(weight_, implementation, error); }
function alignment_(implementation){ return APPLICATION(alignment_, implementation, error); }
function test_(implementation){ return APPLICATION(test_, implementation, error); }

// level 2 applications
function shape_(implementation){ return APPLICATION(shape_, implementation, error); }
function solid_(implementation){ return APPLICATION(solid_, implementation, error); }

const specifications = SPECIFICATION([
	[shape_, SPECIFICATION([
		[label_],
		[surface_],
		[volume_],
		[stretch_],
		[invariant_, implementation => (volume_(implementation) * volume_(implementation)) / (surface_(implementation) * surface_(implementation) * surface_(implementation))],
		[alignment_],
	])],
	[solid_, SPECIFICATION([
		[label_],
		[weight_],
		[alignment_],
		[test_],
	])],
]);

const cube = DEFINITION([
	[shape_, [
		[label_, implementation => side => `cube of side ${side}`],
		[surface_, implementation => side => side * side * 6],
		[volume_, implementation => side => side * side * side],
		[stretch_, implementation => side => k => cube(side * k)],
		[alignment_, implementation => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
	]],
], specifications, error);

const sphere = DEFINITION([
	[shape_, [
		[label_, implementation => radius => `sphere of radius ${radius}`],
		[surface_, implementation => radius => radius * radius *Math.PI * 4],
		[volume_, implementation => radius => radius * radius * radius * Math.PI * 4/3],
		[stretch_, implementation => radius => k => sphere(radius * k)],
		[alignment_, implementation => radius => o => typeof o === "number"? o + 2 * radius: alignment_(o)(2 * radius)],
	]],
], specifications, error);

const object = DEFINITION([
	[solid_, [
		[label_, implementation => (shape, density) => `object of density ${density} and shape ${label_(shape)}`],
		[weight_, implementation => (shape, density) => volume_(shape) * density],
		[alignment_, implementation => (shape, density) => o => alignment_(shape)(o)],
		[test_, implementation => (shape, density) => weight_(solid_)(implementation)],
	]],
], specifications, error);

const cube1 = cube(1);
const cube2 = stretch_(shape_(cube1))(2);
const sphere1 = sphere(1);
const sphere2 = stretch_(shape_(sphere1))(2);

// heterogeneous collection
const shapes = [cube1, cube2, sphere1, sphere2];

const invariants = shapes.reduce(function(results, item){
	return results + label_(shape_(item)) + ": " + invariant_(shape_(item)) + "\n";
}, "invariants: \n");

// <label>: <invariant>
// <label>: <invariant>
// ...
console.log(invariants);

const objects = shapes.map(function(item){
	return object(shape_(item), 10);
});

const weights = objects.reduce(function(results, item){
	return results + label_(solid_(item)) + ": " + weight_(solid_(item)) + "\n";
}, "weights: \n");

// <label>: <weight>
// <label>: <weight>
// ...
console.log(weights);

console.log("alignments:");
console.log("alignment of " + label_(shape_)(cube1) + " And " + label_(shape_)(cube2) + ": " + alignment_(shape_(cube1))(shape_(cube2)));
console.log("alignment of " + label_(shape_)(cube1) + " And " + label_(shape_)(sphere1) + ": " + alignment_(shape_(cube1))(shape_(sphere1)));
console.log("alignment of " + label_(shape_)(cube1) + " And " + label_(solid_)(object(shape_(sphere1), 7)) + ": " + alignment_(shape_(cube1))(solid_(object(shape_(sphere1), 7))));
console.log("alignment of " + label_(solid_)(object(shape_(cube1), 4)) + " And " + label_(shape_)(sphere1) + ": " + alignment_(solid_(object(shape_(cube1), 4)))(shape_(sphere1)));
console.log("alignment of " + label_(solid_)(object(shape_(cube1), 4)) + " And " + label_(solid_)(object(shape_(sphere1), 7)) + ": " + alignment_(solid_(object(shape_(cube1), 4)))(solid_(object(shape_(sphere1), 7))));

console.log("tests:");

const object1 = object(shape_(cube(5)), 15);
const weight1 = weight_(solid_)(object1);
const test1 = test_(solid_)(object1);
console.log(test1 + " === " + weight1 + ": " + (test1 === weight1));

function application0_(implementation){ return APPLICATION(application0_, implementation, error); }
function application1_(implementation){ return APPLICATION(application1_, implementation, error); }
function application2_(implementation){ return APPLICATION(application2_, implementation, error); }
function application3_(implementation){ return APPLICATION(application3_, implementation, error); }
function application4_(implementation){ return APPLICATION(application4_, implementation, error); }

const implementationTest = DEFINITION([
	[application4_, [
		[application3_, [
			[application2_, [
				[application1_, implementation => value => value],
			]],
		]],
	]],
], SPECIFICATION([
	[application4_, SPECIFICATION([
		[application3_, SPECIFICATION([
			[application2_, SPECIFICATION([
				[application1_],
			])],
		])],
	])],
]), error);

const test2 = application1_(application2_)(application3_)(application4_)(implementationTest(222));
console.log(test2 + " === 222: " + (test2 === 222));

const test3 = application1_(application2_)(application3_)(application4_(implementationTest(333)));
console.log(test3 + " === 333: " + (test3 === 333));

const test4 = application1_(application2_)(application3_(application4_(implementationTest(444))));
console.log(test4 + " === 444: " + (test4 === 444));

const test5 = application1_(application2_(application3_(application4_(implementationTest(555)))));
console.log(test5 + " === 555: " + (test5 === 555));

const test6 = application1_(application2_)(application3_(application4_))(implementationTest(666));
console.log(test6 + " === 666: " + (test6 === 666));

const test7 = application1_(application2_(application3_))(application4_)(implementationTest(777));
console.log(test7 + " === 777: " + (test7 === 777));

const test8 = application1_(application2_)(application3_(application4_))(implementationTest(888));
console.log(test8 + " === 888: " + (test8 === 888));

console.log("compositions:");

function value_(implementation){ return APPLICATION(value_, implementation, error); }
function next_(implementation){ return APPLICATION(next_, implementation, error); }
function previous_(implementation){ return APPLICATION(previous_, implementation, error); }
function double_(implementation){ return APPLICATION(double_, implementation, error); }
function half_(implementation){ return APPLICATION(half_, implementation, error); }

const number = DEFINITION([
	[value_, implementation => value => value],
	[next_, implementation => value => number(value + 1)],
	[previous_, implementation => value => number(value - 1)],
	[double_, implementation => value => number(value * 2)],
	[half_, implementation => value => number(value / 2)],
], SPECIFICATION([
	[value_],
	[next_],
	[previous_],
	[double_],
	[half_],
]), error);

const composition1 = double_(previous_)(half_)(next_)(number(13));
console.log(value_(composition1) + " === 12: " + (value_(composition1) === 12));

const composition2 = double_(previous_)(half_)(next_(number(13)));
console.log(value_(composition2) + " === 12: " + (value_(composition2) === 12));

const composition3 = double_(previous_)(half_(next_(number(13))));
console.log(value_(composition3) + " === 12: " + (value_(composition3) === 12));

const composition4 = double_(previous_(half_(next_(number(13)))));
console.log(value_(composition4) + " === 12: " + (value_(composition4) === 12));

const composition5 = double_(previous_)(half_(next_))(number(13));
console.log(value_(composition5) + " === 12: " + (value_(composition5) === 12));

const composition6 = double_(previous_(half_))(next_)(number(13));
console.log(value_(composition6) + " === 12: " + (value_(composition6) === 12));

const composition7 = double_(previous_)(half_(next_))(number(13));
console.log(value_(composition7) + " === 12: " + (value_(composition7) === 12));

const composition8 = ((double_)(previous_)(((half_)(next_))(number(13))));
console.log(value_(composition8) + " === 12: " + (value_(composition8) === 12));

const composition9 = (((double_)(previous_))((half_)(next_)))(number(13));
console.log(value_(composition9) + " === 12: " + (value_(composition9) === 12));

console.log("chains:");

function first_(implementation){ return APPLICATION(first_, implementation, error); }
function second_(implementation){ return APPLICATION(second_, implementation, error); }

const tree = DEFINITION([
	[first_, implementation => value => typeof(value[0]) === "object"? tree(value[0]): value[0]],
	[second_, implementation => value => typeof(value[1]) === "object"? tree(value[1]): value[1]],
], SPECIFICATION([
	[first_],
	[second_],
]), error);

const tree1 = tree([
	[11, 21],
	[12, 22],
]);

const chain11 = (first_)(first_)(tree1);
console.log(chain11 + " === 11: " + (chain11 === 11));

const chain12 = (first_)(second_)(tree1);
console.log(chain12 + " === 12: " + (chain12 === 12));

const chain21 = (second_)(first_)(tree1);
console.log(chain21 + " === 21: " + (chain21 === 21));

const chain22 = (second_)(second_)(tree1);
console.log(chain22 + " === 22: " + (chain22 === 22));

console.log("combinations:");

function add_(implementation){ return APPLICATION(add_, implementation, error); }
function addString_(implementation){ return APPLICATION(addString_, implementation, error); }
function addInteger_(implementation){ return APPLICATION(addInteger_, implementation, error); }
function addDecimal_(implementation){ return APPLICATION(addDecimal_, implementation, error); }
function string_(implementation){ return APPLICATION(string_, implementation, error); }
function numerator_(implementation){ return APPLICATION(numerator_, implementation, error); }
function denominator_(implementation){ return APPLICATION(denominator_, implementation, error); }

const integer = DEFINITION([
	[value_, implementation => value => value],
	[string_, implementation => value => value.toString()],
	[add_, implementation => value => addition => addInteger_(addition)(implementation)],
	[addInteger_, implementation => value => addition => integer(value + value_(addition))],
	[addDecimal_, implementation => value => addition => decimal(value * denominator_(addition) + numerator_(addition), denominator_(addition))],
], SPECIFICATION([
	[value_],
	[string_],
	[add_],
	[addInteger_],
	[addDecimal_],
	[addString_, implementation => addition => string(string_(addition) + string_(implementation))],
]), error);

const decimal = DEFINITION([
	[numerator_, implementation => (numerator, denominator) => numerator],
	[denominator_, implementation => (numerator, denominator) => denominator],
	[string_, implementation => (numerator, denominator) => numerator.toString() + "/" + denominator.toString()],
	[add_, implementation => (numerator, denominator) => addition => addDecimal_(addition)(implementation)],
	[addInteger_, implementation => (numerator, denominator) => addition => decimal(numerator + value_(addition) * denominator, denominator)],
	[addDecimal_, implementation => (numerator, denominator) => addition => decimal(numerator * denominator_(addition) + numerator_(addition) * denominator, denominator * denominator_(addition))],
], SPECIFICATION([
	[numerator_],
	[denominator_],
	[string_],
	[add_],
	[addInteger_],
	[addDecimal_],
	[addString_, implementation => addition => string(string_(addition) + string_(implementation))],
]), error);

const string = DEFINITION([
	[string_, implementation => value => value],
	[add_, implementation => value => addition => addString_(addition)(implementation)],
	[addInteger_, implementation => value => addition => string(string_(addition) + value)],
	[addDecimal_, implementation => value => addition => string(string_(addition) + value)],
], SPECIFICATION([
	[string_],
	[add_],
	[addInteger_],
	[addDecimal_],
	[addString_, implementation => addition => string(string_(addition) + string_(implementation))],
]), error);

const combination1 = (string_)((add_)(integer(13))(integer(10)));
console.log(combination1 + " === 23: " + (combination1 === "23"));

const combination2 = (string_)((add_)(integer(3))(decimal(5, 7)));
console.log(combination2 + " === 26/7: " + (combination2 === "26/7"));

const combination3 = (string_)((add_)(decimal(5, 7))(integer(3)));
console.log(combination3 + " === 26/7: " + (combination3 === "26/7"));

const combination4 = (string_)((add_)(decimal(5, 7))(string("qwerty")));
console.log(combination4 + " === 5/7qwerty: " + (combination4 === "5/7qwerty"));

const combination5 = (string_)((add_)(string("azerty"))(decimal(5, 7)));
console.log(combination5 + " === azerty5/7: " + (combination5 === "azerty5/7"));

const combination6 = (string_)((add_)(string("azerty"))(integer(57)));
console.log(combination6 + " === azerty57: " + (combination6 === "azerty57"));

const combination7 = (string_)((add_)(integer(57))(string("qwerty")));
console.log(combination7 + " === 57qwerty: " + (combination7 === "57qwerty"));

const combination8 = (string_)((add_)(string("azerty"))(string("qwerty")));
console.log(combination8 + " === azertyqwerty: " + (combination8 === "azertyqwerty"));

console.log("recursions:");

function nil_(implementation){ return APPLICATION(nil_, implementation, error); }
function head_(implementation){ return APPLICATION(head_, implementation, error); }
function tail_(implementation){ return APPLICATION(tail_, implementation, error); }
function extent_(implementation){ return APPLICATION(extent_, implementation, error); }
function translation_(implementation){ return APPLICATION(translation_, implementation, error); }
function collection_(implementation){ return APPLICATION(collection_, implementation, error); }
function reduction_(implementation){ return APPLICATION(reduction_, implementation, error); }
function array_(implementation){ return APPLICATION(array_, implementation, error); }

const list0 = (function(){
	const list = DEFINITION([
		[nil_, implementation => (head, tail) => nil],
		[head_, implementation => (head, tail) => head],
		[tail_, implementation => (head, tail) => implementation === nil? nil: tail],
		[extent_, implementation => (head, tail) => value => list(value, implementation)],
		[translation_, implementation => (head, tail) => translation => implementation === nil? nil: list(translation(head), translation_(tail)(translation))],
		[collection_, implementation => (head, tail) => collection => implementation === nil? nil: collection(head)? list(head, collection_(tail)(collection)): collection_(tail)(collection)],
		[reduction_, implementation => (head, tail) => reduction => accumulation => implementation === nil? accumulation: (reduction_(tail)(reduction))(reduction(head)(accumulation))],
	], SPECIFICATION([
		[nil_],
		[head_],
		[tail_],
		[extent_],
		[translation_],
		[collection_],
		[reduction_],
		[array_, implementation => reduction_(implementation)(value => accumulation => [value, ...accumulation])([])],
	]), error);
	const nil = list();
	return nil;
})();

const list1 = (extent_)(list0)(10);
const list2 = (extent_)(list1)(100);
const list3 = (extent_)(list2)(1000);

console.log((head_)(list3) + " === 1000: " + ((head_)(list3) === 1000));
console.log((head_)(tail_)(list3) + " === 100: " + ((head_)(tail_)(list3) === 100));
console.log((head_)(tail_)(tail_)(list3) + " === 10: " + ((head_)(tail_)(tail_)(list3) === 10));
console.log((head_)(tail_)(tail_)(tail_)(list3) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(list3) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(list3) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(list3) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list3) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list3) === undefined));

const list4 = (translation_)(list3)(value => value + 1);

console.log((head_)(list4) + " === 1001: " + ((head_)(list4) === 1001));
console.log((head_)(tail_)(list4) + " === 101: " + ((head_)(tail_)(list4) === 101));
console.log((head_)(tail_)(tail_)(list4) + " === 11: " + ((head_)(tail_)(tail_)(list4) === 11));
console.log((head_)(tail_)(tail_)(tail_)(list4) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(list4) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(list4) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(list4) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list4) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list4) === undefined));

const list5 = (collection_)(list4)(value => value !== 101);

console.log((head_)(list5) + " === 1001: " + ((head_)(list5) === 1001));
console.log((head_)(tail_)(list5) + " === 11: " + ((head_)(tail_)(list5) === 11));
console.log((head_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(list5) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(list5) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(list5) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list5) === undefined));

const accumulation4 = (reduction_)(list4)(value => accumulation => value + accumulation)(909);

console.log(accumulation4 + " === 2022: " + (accumulation4 === 2022));

const array4 = (array_)(list4);

console.log(array4 + " === 11,101,1001: " + (JSON.stringify(array4) === "[11,101,1001]"));

console.log("extensions:");

const specificationx = SPECIFICATION([
	[shape_, SPECIFICATION([
		[stretch2_, implementation => stretch_(implementation)(2)],
		[stretch3_],
	])],
]);

function stretch2_(implementation){ return APPLICATION(stretch2_, implementation, error); }
function stretch3_(implementation){ return APPLICATION(stretch3_, implementation, error); }

const cubex = EXTENSION(cube)([
	[shape_, [
		[stretch3_, implementation => side => cube(side * 3)],
	]],
], specificationx);

const spherex = EXTENSION(sphere)([
	[shape_, [
		[stretch3_, implementation => radius => sphere(radius * 3)],
	]],
], specificationx);

const cubex1 = cubex(1); 
console.log((label_)(shape_)(cubex1) + " === cube of side 1: " + ((label_)(shape_)(cubex1) === "cube of side 1"));

const cubex2 = (stretch2_)(shape_)(cubex1);
console.log((label_)(shape_)(cubex2) + " === cube of side 2: " + ((label_)(shape_)(cubex2) === "cube of side 2"));

const cubex3 = (stretch3_)(shape_)(cubex1);
console.log((label_)(shape_)(cubex3) + " === cube of side 3: " + ((label_)(shape_)(cubex3) === "cube of side 3"));

const spherex1 = spherex(1);
console.log((label_)(shape_)(spherex1) + " === sphere of radius 1: " + ((label_)(shape_)(spherex1) === "sphere of radius 1"));

const spherex2 = (stretch2_)(shape_)(spherex1);
console.log((label_)(shape_)(spherex2) + " === sphere of radius 2: " + ((label_)(shape_)(spherex2) === "sphere of radius 2"));

const spherex3 = (stretch3_)(shape_)(spherex1);
console.log((label_)(shape_)(spherex3) + " === sphere of radius 3: " + ((label_)(shape_)(spherex3) === "sphere of radius 3"));

console.log("exceptions:");

try{
	(stretch_)(shape_)(solid_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected applications: (solid_)": ' + (exception === "unexpected applications: (solid_)"));
}

try{
	(solid_)(stretch_)(shape_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid argument: (solid_)": ' + (exception === "applications applied to an invalid argument: (solid_)"));
}

try{
	(weight_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected applications: (weight_)": ' + (exception === "unexpected applications: (weight_)"));
}

try{
	(solid_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected applications: (solid_)": ' + (exception === "unexpected applications: (solid_)"));
}

try{
	(shape_)(x => 2 * x);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid argument: (shape_)": ' + (exception === "applications applied to an invalid argument: (shape_)"));
}

try{
	(shape_)(2);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid argument: (shape_)": ' + (exception === "applications applied to an invalid argument: (shape_)"));
}

try{
	(shape_)();
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid argument: (shape_)": ' + (exception === "applications applied to an invalid argument: (shape_)"));
}

try{
	(label_)(shape_)(1234);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid argument: (label_)(shape_)": ' + (exception === "applications applied to an invalid argument: (label_)(shape_)"));
}

try{
	(label_)(shape_)();
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid argument: (label_)(shape_)": ' + (exception === "applications applied to an invalid argument: (label_)(shape_)"));
}

try{
	(label_)(shape_)(x => 1234);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "applications applied to an invalid argument: (label_)(shape_)": ' + (exception === "applications applied to an invalid argument: (label_)(shape_)"));
}

try{
	const cube = DEFINITION([
		[shape_, [
			[label_, implementation => side => `cube of side ${side}`],
			[volume_, implementation => side => side * side * side],
			[alignment_, implementation => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_, implementation => (volume_(implementation) * volume_(implementation)) / (surface_(implementation) * surface_(implementation) * surface_(implementation))],
			[alignment_],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "missing definition: (shape_)(surface_)": ' + (exception === "missing definition: (shape_)(surface_)"));
}

try{
	const cube = DEFINITION([
		[shape_, [
			[label_, implementation => side => `cube of side ${side}`],
			[surface_, implementation => side => side * side * 6],
			[volume_, implementation => side => side * side * side],
			[stretch_, implementation => side => k => cube(side * k)],
			[invariant_, implementation => side => 1],
			[alignment_, implementation => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_, implementation => (volume_(implementation) * volume_(implementation)) / (surface_(implementation) * surface_(implementation) * surface_(implementation))],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected definition: (shape_)(invariant_)": ' + (exception === "unexpected definition: (shape_)(invariant_)"));
}

try{
	const cube = DEFINITION([
		[shape_, [
			[label_, implementation => side => `cube of side ${side}`],
			[surface_, implementation => side => side * side * 6],
			[volume_, implementation => side => side * side * side],
			[stretch_, implementation => side => k => cube(side * k)],
			[invariant_],
			[alignment_, implementation => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_],
			[alignment_],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "missing definition: (shape_)(invariant_)": ' + (exception === "missing definition: (shape_)(invariant_)"));
}

try{
	const cube = DEFINITION([
		[shape_, [
			[label_, implementation => side => `cube of side ${side}`],
			[surface_, implementation => side => side * side * 6],
			[volume_, implementation => side => side * side * side],
			[stretch_, implementation => side => k => cube(side * k)],
			[alignment_, implementation => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_],
			[alignment_],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "missing definition: (shape_)(invariant_)": ' + (exception === "missing definition: (shape_)(invariant_)"));
}

//todo extension exceptions

console.log("debugs:");

const debug1 = cube(1)()().map(application => application.name);
console.log(JSON.stringify(debug1) + ' === ["shape_","solid_"]: ' + (JSON.stringify(debug1) === '["shape_","solid_"]'));

const debug2 = cube(1)()(shape_).mapping().map(application => application.name);
console.log(JSON.stringify(debug2) + ' === ["label_","surface_","volume_","stretch_","invariant_","alignment_"]: ' + (JSON.stringify(debug2) === '["label_","surface_","volume_","stretch_","invariant_","alignment_"]'));

const debug3 = cube(1)()(shape_).mapping(alignment_);
console.log(debug3 + ' === undefined: ' + (debug3 === undefined));

const debug4 = cube(1)()(shape_).mapping(solid_);
console.log(typeof(debug4) + ' === function: ' + (typeof(debug4) === "function"));

const debug5 = cube(1)()(shape_).mapping(solid_)();
console.log(debug5 + ' === undefined: ' + (debug5 === undefined));


</script>
</body>
</html>