<html>
<head><title>js-antescript</title></head>
<body>
<script>
"use strict";

const { ATTRIBUTE, SPECIFICATION, IMPLEMENTATION } = (function(){
	function attributeType(){
	}
	function implementationType(){
	}
	function specificationType(){
	}
	function errorType(){
	}
	function expensionType(){
	}
	function TYPE(value, type){
		if (type === specificationType){
			return value !== null && typeof(value) === "object" && value.type === specificationType;
		}
		if (type !== undefined){
			return TYPE(value) === type;
		}
		if (typeof(value) ===  "function"){
			return value(TYPE);
		}
		if (value !== null && typeof(value) === "object"){
			if (value.type === specificationType){
				return specificationType;
			}
		}
	}
	function EXPENSION(attributes){
		return attributes.reduce(function(accumulator, attribute){
			const attributes = attribute(expensionType);
			if (attributes === attribute){
				return [...accumulator, attribute];
			}
			return [...accumulator, ...EXPENSION(attributes)];
		}, []);
	}
	function ATTRIBUTES(error, attribute, ...attributes){
		return function(implementation){
			if (implementation === TYPE){
				return attributeType;
			}
			if (implementation === expensionType){
				return EXPENSION([attribute, ...attributes]);
			}
			switch (TYPE(implementation)){
				case attributeType: return ATTRIBUTES(error, implementation, attribute, ...attributes);
				case implementationType: {
					const value = [attribute, ...attributes].reduce(function(implementation, attribute){
						if (implementation !== errorType && typeof(implementation) === "function"){	
							return attribute(implementation);
						}
						return errorType;
					}, implementation);
					if (value !== errorType){
						return value;
					}
				}
			}
			return error && error("attribute applied to an invalid argument", [EXPENSION([attribute, ...attributes])]);
		};
	}
	function IMPLEMENTATIONS(attributes, specifications, properties, implementations, implementation0){
		return function IMPLEMENTATION(attribute){
			if (attribute === TYPE){
				return implementationType;
			}
			if (attribute === undefined){
				return specifications;
			}
			if (TYPE(attribute) === attributeType){
				const implementation = implementations(attribute);
				const specification = specifications(attribute);
				if (implementation !== errorType && specification !== errorType){
					if (implementation === undefined){
						if (typeof(specification) === "function"){
							return specification(IMPLEMENTATION);
						}
						return error && error("attribute associated to an invalid specification", [[...attributes, attribute]]);
					}
					if (!TYPE(specification, specificationType)){
						if (implementation !== errorType){
							if (typeof(implementation) === "function"){
								return implementation(implementation0?? IMPLEMENTATION)(...properties);
							}
							return error && error("attribute associated to an invalid implementation", [[...attributes, attribute]]);
						}
						return error && error("unexpected attribute", [[...attributes, attribute]]);
					}
					return IMPLEMENTATIONS([...attributes, attribute], specification.mapping, properties, implementation, implementation0?? IMPLEMENTATION);
				}
				return error && error("unexpected attribute", [[...attributes, attribute]]);
			}
			return error && error("incorrect attribute", [[...attributes, attribute]]);
		};
	}
	function MAPPINGS(implementations, specifications){
		const entries = implementations.map(function(item){
			const attribute = item[0];
			const specification = specifications(attribute);
			if (TYPE(specification, specificationType)){
				const implementation = item[1];
				return [attribute, MAPPINGS(implementation, specification.mapping)];
			}
			return item;
		});
		const map = new(WeakMap)(entries);
		return function(attribute){
			if (attribute === TYPE){
				return implementationType;
			}
			if (attribute === undefined){
				return entries.map(item => item[0]);
			}
			const value = map.get(attribute);
			if (value !== undefined || map.has(attribute)){
				return value;
			}
			return errorType;
		};
	}
	function OVERSUPPLIES(implementations, specifications, ...attributes){
		const oversupplies = implementations().reduce(function(oversupplies, attribute){
			const implementation = implementations(attribute);
			const specification = specifications(attribute);
			if (specification === errorType){
				return [...oversupplies, [attribute, ...attributes]];
			}
			if (implementation !== undefined && TYPE(implementation) === implementationType){
				if (specification === undefined || !TYPE(specification, specificationType)){
					return [...oversupplies, [attribute, ...attributes]];
				}
				return [...oversupplies, ...OVERSUPPLIES(implementation, specification.mapping, attribute, ...attributes)]
			}
			if (implementation !== undefined && specification !== undefined){
				return [...oversupplies, [attribute, ...attributes]];
			}
			return oversupplies;
		}, []);
		return oversupplies;
	}
	function UNDERSUPPLIES(implementations, specifications, ...attributes){
		const undersupplies = specifications().reduce(function(undersupplies, attribute){
			const specification = specifications(attribute);
			const implementation = implementations(attribute);
			if (implementation === errorType){
				return attributes.length === 0? undersupplies: [...undersupplies, [attribute, ...attributes]];
			}
			if (TYPE(specification, specificationType)){
				if (implementation === undefined || TYPE(implementation) !== implementationType){
					return [...undersupplies, [attribute, ...attributes]];
				}
				return [...undersupplies, ...UNDERSUPPLIES(implementation, specification.mapping, attribute, ...attributes)]
			}
			if (specification === undefined && implementation === undefined){
				return [...undersupplies, [attribute, ...attributes]];
			}
			return undersupplies;
		}, []);
		return undersupplies;
	}
	return {
		ATTRIBUTE: function ATTRIBUTE(attribute, implementation, error){
			if (implementation === TYPE){
				return attributeType;
			}
			if (implementation === expensionType){
				return attribute;
			}
			switch (TYPE(implementation)){
				case attributeType: return ATTRIBUTES(error, implementation, attribute);
				case implementationType: return implementation(attribute);
			}
			return error && error("attributes applied to an invalid argument", [[attribute]]);
		},
		SPECIFICATION: function SPECIFICATION(specifications){
			const map = new(WeakMap)(specifications);
			return {
				mapping: function(attribute){
					if (attribute === TYPE){
						return specificationType;
					}
					if (attribute === undefined){
						return specifications.map(item => item[0]);
					}
					const value = map.get(attribute);
					if (value !== undefined || map.has(attribute)){
						return value;
					}
					return errorType;
				},
				type: specificationType,
			}; 
		},
		IMPLEMENTATION: function IMPLEMENTATION(implementations, specifications, error){
			if (!TYPE(specifications, specificationType)){
				return error && error("invalid specifications", [[]]);
			}
			const mappings = MAPPINGS(implementations, specifications.mapping);
			const oversupplies = OVERSUPPLIES(mappings, specifications.mapping);
			if (oversupplies.length !== 0){
				return error && error("unexpected implementations", oversupplies);
			}
			const undersupplies = UNDERSUPPLIES(mappings, specifications.mapping);
			if (undersupplies.length !== 0){
				return error && error("missing implementations", undersupplies);
			}
			return function(...properties){
				return IMPLEMENTATIONS([], specifications.mapping, properties, mappings);
			}
		},
	};
})();

function error(message, attributes){
	const messages = attributes.map(function(attributes){
		return attributes.reduce(function(accumulator, attribute){
			return "(" + attribute.name + ")" + accumulator;
		}, "");
	}).join(" ");
	throw message + ": " + messages;
}

// level 1 attributes
function label_(implementation){ return ATTRIBUTE(label_, implementation, error); }
function surface_(implementation){ return ATTRIBUTE(surface_, implementation, error); }
function volume_(implementation){ return ATTRIBUTE(volume_, implementation, error); }
function stretch_(implementation){ return ATTRIBUTE(stretch_, implementation, error); }
function invariant_(implementation){ return ATTRIBUTE(invariant_, implementation, error); }
function weight_(implementation){ return ATTRIBUTE(weight_, implementation, error); }
function alignment_(implementation){ return ATTRIBUTE(alignment_, implementation, error); }
function test_(implementation){ return ATTRIBUTE(test_, implementation, error); }

// level 2 attributes
function shape_(implementation){ return ATTRIBUTE(shape_, implementation, error); }
function solid_(implementation){ return ATTRIBUTE(solid_, implementation, error); }

const specifications = SPECIFICATION([
	[shape_, SPECIFICATION([
		[label_],
		[surface_],
		[volume_],
		[stretch_],
		[invariant_, implementation => (volume_(implementation) * volume_(implementation)) / (surface_(implementation) * surface_(implementation) * surface_(implementation))],
		[alignment_],
	])],
	[solid_, SPECIFICATION([
		[label_],
		[weight_],
		[alignment_],
		[test_],
	])],
]);

const cube = IMPLEMENTATION([
	[shape_, [
		[label_, implementation => side => `cube of side ${side}`],
		[surface_, implementation => side => side * side * 6],
		[volume_, implementation => side => side * side * side],
		[stretch_, implementation => side => k => cube(side * k)],
		[invariant_],
		[alignment_, implementation => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
	]],
], specifications, error);

const sphere = IMPLEMENTATION([
	[shape_, [
		[label_, implementation => radius => `sphere of radius ${radius}`],
		[surface_, implementation => radius => radius * radius *Math.PI * 4],
		[volume_, implementation => radius => radius * radius * radius * Math.PI * 4/3],
		[stretch_, implementation => radius => k => sphere(radius * k)],
		[invariant_],
		[alignment_, implementation => radius => o => typeof o === "number"? o + 2 * radius: alignment_(o)(2 * radius)],
	]],
], specifications, error);

const object = IMPLEMENTATION([
	[solid_, [
		[label_, implementation => (shape, density) => `object of density ${density} and shape ${label_(shape)}`],
		[weight_, implementation => (shape, density) => volume_(shape) * density],
		[alignment_, implementation => (shape, density) => o => alignment_(shape)(o)],
		[test_, implementation => (shape, density) => weight_(solid_)(implementation)],
	]],
], specifications, error);

const cube1 = cube(1);
const cube2 = stretch_(shape_(cube1))(2);
const sphere1 = sphere(1);
const sphere2 = stretch_(shape_(sphere1))(2);

// heterogeneous collection
const shapes = [cube1, cube2, sphere1, sphere2];

const invariants = shapes.reduce(function(results, item){
	return results + label_(shape_(item)) + ": " + invariant_(shape_(item)) + "\n";
}, "invariants: \n");

// <label>: <invariant>
// <label>: <invariant>
// ...
console.log(invariants);

const objects = shapes.map(function(item){
	return object(shape_(item), 10);
});

const weights = objects.reduce(function(results, item){
	return results + label_(solid_(item)) + ": " + weight_(solid_(item)) + "\n";
}, "weights: \n");

// <label>: <weight>
// <label>: <weight>
// ...
console.log(weights);

console.log("alignments:");
console.log("alignment of " + label_(shape_)(cube1) + " And " + label_(shape_)(cube2) + ": " + alignment_(shape_(cube1))(shape_(cube2)));
console.log("alignment of " + label_(shape_)(cube1) + " And " + label_(shape_)(sphere1) + ": " + alignment_(shape_(cube1))(shape_(sphere1)));
console.log("alignment of " + label_(shape_)(cube1) + " And " + label_(solid_)(object(shape_(sphere1), 7)) + ": " + alignment_(shape_(cube1))(solid_(object(shape_(sphere1), 7))));
console.log("alignment of " + label_(solid_)(object(shape_(cube1), 4)) + " And " + label_(shape_)(sphere1) + ": " + alignment_(solid_(object(shape_(cube1), 4)))(shape_(sphere1)));
console.log("alignment of " + label_(solid_)(object(shape_(cube1), 4)) + " And " + label_(solid_)(object(shape_(sphere1), 7)) + ": " + alignment_(solid_(object(shape_(cube1), 4)))(solid_(object(shape_(sphere1), 7))));

console.log("tests:");

const object1 = object(shape_(cube(5)), 15);
const weight1 = weight_(solid_)(object1);
const test1 = test_(solid_)(object1);
console.log(test1 + " === " + weight1 + ": " + (test1 === weight1));

function attribute0_(implementation){ return ATTRIBUTE(attribute0_, implementation, error); }
function attribute1_(implementation){ return ATTRIBUTE(attribute1_, implementation, error); }
function attribute2_(implementation){ return ATTRIBUTE(attribute2_, implementation, error); }
function attribute3_(implementation){ return ATTRIBUTE(attribute3_, implementation, error); }
function attribute4_(implementation){ return ATTRIBUTE(attribute4_, implementation, error); }

const implementationTest = IMPLEMENTATION([
	[attribute4_, [
		[attribute3_, [
			[attribute2_, [
				[attribute1_, implementation => value => value],
			]],
		]],
	]],
], SPECIFICATION([
	[attribute4_, SPECIFICATION([
		[attribute3_, SPECIFICATION([
			[attribute2_, SPECIFICATION([
				[attribute1_],
			])],
		])],
	])],
]), error);

const test2 = attribute1_(attribute2_)(attribute3_)(attribute4_)(implementationTest(222));
console.log(test2 + " === 222: " + (test2 === 222));

const test3 = attribute1_(attribute2_)(attribute3_)(attribute4_(implementationTest(333)));
console.log(test3 + " === 333: " + (test3 === 333));

const test4 = attribute1_(attribute2_)(attribute3_(attribute4_(implementationTest(444))));
console.log(test4 + " === 444: " + (test4 === 444));

const test5 = attribute1_(attribute2_(attribute3_(attribute4_(implementationTest(555)))));
console.log(test5 + " === 555: " + (test5 === 555));

const test6 = attribute1_(attribute2_)(attribute3_(attribute4_))(implementationTest(666));
console.log(test6 + " === 666: " + (test6 === 666));

const test7 = attribute1_(attribute2_(attribute3_))(attribute4_)(implementationTest(777));
console.log(test7 + " === 777: " + (test7 === 777));

const test8 = attribute1_(attribute2_)(attribute3_(attribute4_))(implementationTest(888));
console.log(test8 + " === 888: " + (test8 === 888));

console.log("compositions:");

function value_(implementation){ return ATTRIBUTE(value_, implementation, error); }
function next_(implementation){ return ATTRIBUTE(next_, implementation, error); }
function previous_(implementation){ return ATTRIBUTE(previous_, implementation, error); }
function double_(implementation){ return ATTRIBUTE(double_, implementation, error); }
function half_(implementation){ return ATTRIBUTE(half_, implementation, error); }

const number = IMPLEMENTATION([
	[value_, implementation => value => value],
	[next_, implementation => value => number(value + 1)],
	[previous_, implementation => value => number(value - 1)],
	[double_, implementation => value => number(value * 2)],
	[half_, implementation => value => number(value / 2)],
], SPECIFICATION([
	[value_],
	[next_],
	[previous_],
	[double_],
	[half_],
]), error);

const composition1 = double_(previous_)(half_)(next_)(number(13));
console.log(value_(composition1) + " === 12: " + (value_(composition1) === 12));

const composition2 = double_(previous_)(half_)(next_(number(13)));
console.log(value_(composition2) + " === 12: " + (value_(composition2) === 12));

const composition3 = double_(previous_)(half_(next_(number(13))));
console.log(value_(composition3) + " === 12: " + (value_(composition3) === 12));

const composition4 = double_(previous_(half_(next_(number(13)))));
console.log(value_(composition4) + " === 12: " + (value_(composition4) === 12));

const composition5 = double_(previous_)(half_(next_))(number(13));
console.log(value_(composition5) + " === 12: " + (value_(composition5) === 12));

const composition6 = double_(previous_(half_))(next_)(number(13));
console.log(value_(composition6) + " === 12: " + (value_(composition6) === 12));

const composition7 = double_(previous_)(half_(next_))(number(13));
console.log(value_(composition7) + " === 12: " + (value_(composition7) === 12));

const composition8 = ((double_)(previous_)(((half_)(next_))(number(13))));
console.log(value_(composition8) + " === 12: " + (value_(composition8) === 12));

const composition9 = (((double_)(previous_))((half_)(next_)))(number(13));
console.log(value_(composition9) + " === 12: " + (value_(composition9) === 12));

console.log("chains:");

function first_(implementation){ return ATTRIBUTE(first_, implementation, error); }
function second_(implementation){ return ATTRIBUTE(second_, implementation, error); }

const tree = IMPLEMENTATION([
	[first_, implementation => value => typeof(value[0]) === "object"? tree(value[0]): value[0]],
	[second_, implementation => value => typeof(value[1]) === "object"? tree(value[1]): value[1]],
], SPECIFICATION([
	[first_],
	[second_],
]), error);

const tree1 = tree([
	[11, 21],
	[12, 22],
]);

const chain11 = (first_)(first_)(tree1);
console.log(chain11 + " === 11: " + (chain11 === 11));

const chain12 = (first_)(second_)(tree1);
console.log(chain12 + " === 12: " + (chain12 === 12));

const chain21 = (second_)(first_)(tree1);
console.log(chain21 + " === 21: " + (chain21 === 21));

const chain22 = (second_)(second_)(tree1);
console.log(chain22 + " === 22: " + (chain22 === 22));

console.log("combinations:");

function add_(implementation){ return ATTRIBUTE(add_, implementation, error); }
function addString_(implementation){ return ATTRIBUTE(addString_, implementation, error); }
function addInteger_(implementation){ return ATTRIBUTE(addInteger_, implementation, error); }
function addDecimal_(implementation){ return ATTRIBUTE(addDecimal_, implementation, error); }
function string_(implementation){ return ATTRIBUTE(string_, implementation, error); }
function numerator_(implementation){ return ATTRIBUTE(numerator_, implementation, error); }
function denominator_(implementation){ return ATTRIBUTE(denominator_, implementation, error); }

const integer = IMPLEMENTATION([
	[value_, implementation => value => value],
	[string_, implementation => value => value.toString()],
	[add_, implementation => value => addition => addInteger_(addition)(implementation)],
	[addInteger_, implementation => value => addition => integer(value + value_(addition))],
	[addDecimal_, implementation => value => addition => decimal(value * denominator_(addition) + numerator_(addition), denominator_(addition))],
	[addString_],
], SPECIFICATION([
	[value_],
	[string_],
	[add_],
	[addInteger_],
	[addDecimal_],
	[addString_, implementation => addition => string(string_(addition) + string_(implementation))],
]), error);

const decimal = IMPLEMENTATION([
	[numerator_, implementation => (numerator, denominator) => numerator],
	[denominator_, implementation => (numerator, denominator) => denominator],
	[string_, implementation => (numerator, denominator) => numerator.toString() + "/" + denominator.toString()],
	[add_, implementation => (numerator, denominator) => addition => addDecimal_(addition)(implementation)],
	[addInteger_, implementation => (numerator, denominator) => addition => decimal(numerator + value_(addition) * denominator, denominator)],
	[addDecimal_, implementation => (numerator, denominator) => addition => decimal(numerator * denominator_(addition) + numerator_(addition) * denominator, denominator * denominator_(addition))],
	[addString_],
], SPECIFICATION([
	[numerator_],
	[denominator_],
	[string_],
	[add_],
	[addInteger_],
	[addDecimal_],
	[addString_, implementation => addition => string(string_(addition) + string_(implementation))],
]), error);

const string = IMPLEMENTATION([
	[string_, implementation => value => value],
	[add_, implementation => value => addition => addString_(addition)(implementation)],
	[addInteger_, implementation => value => addition => string(string_(addition) + value)],
	[addDecimal_, implementation => value => addition => string(string_(addition) + value)],
	[addString_],
], SPECIFICATION([
	[string_],
	[add_],
	[addInteger_],
	[addDecimal_],
	[addString_, implementation => addition => string(string_(addition) + string_(implementation))],
]), error);

const combination1 = (string_)((add_)(integer(13))(integer(10)));
console.log(combination1 + " === 23: " + (combination1 === "23"));

const combination2 = (string_)((add_)(integer(3))(decimal(5, 7)));
console.log(combination2 + " === 26/7: " + (combination2 === "26/7"));

const combination3 = (string_)((add_)(decimal(5, 7))(integer(3)));
console.log(combination3 + " === 26/7: " + (combination3 === "26/7"));

const combination4 = (string_)((add_)(decimal(5, 7))(string("qwerty")));
console.log(combination4 + " === 5/7qwerty: " + (combination4 === "5/7qwerty"));

const combination5 = (string_)((add_)(string("azerty"))(decimal(5, 7)));
console.log(combination5 + " === azerty5/7: " + (combination5 === "azerty5/7"));

const combination6 = (string_)((add_)(string("azerty"))(integer(57)));
console.log(combination6 + " === azerty57: " + (combination6 === "azerty57"));

const combination7 = (string_)((add_)(integer(57))(string("qwerty")));
console.log(combination7 + " === 57qwerty: " + (combination7 === "57qwerty"));

const combination8 = (string_)((add_)(string("azerty"))(string("qwerty")));
console.log(combination8 + " === azertyqwerty: " + (combination8 === "azertyqwerty"));

console.log("recursions:");

function nil_(implementation){ return ATTRIBUTE(nil_, implementation, error); }
function head_(implementation){ return ATTRIBUTE(head_, implementation, error); }
function tail_(implementation){ return ATTRIBUTE(tail_, implementation, error); }
function extent_(implementation){ return ATTRIBUTE(extent_, implementation, error); }
function translation_(implementation){ return ATTRIBUTE(translation_, implementation, error); }
function collection_(implementation){ return ATTRIBUTE(collection_, implementation, error); }
function reduction_(implementation){ return ATTRIBUTE(reduction_, implementation, error); }
function array_(implementation){ return ATTRIBUTE(array_, implementation, error); }

const list0 = (function(){
	const list = IMPLEMENTATION([
		[nil_, implementation => (head, tail) => nil],
		[head_, implementation => (head, tail) => head],
		[tail_, implementation => (head, tail) => implementation === nil? nil: tail],
		[extent_, implementation => (head, tail) => value => list(value, implementation)],
		[translation_, implementation => (head, tail) => translation => implementation === nil? nil: list(translation(head), translation_(tail)(translation))],
		[collection_, implementation => (head, tail) => collection => implementation === nil? nil: collection(head)? list(head, collection_(tail)(collection)): collection_(tail)(collection)],
		[reduction_, implementation => (head, tail) => reduction => accumulation => implementation === nil? accumulation: (reduction_(tail)(reduction))(reduction(head)(accumulation))],
		[array_],
	], SPECIFICATION([
		[nil_],
		[head_],
		[tail_],
		[extent_],
		[translation_],
		[collection_],
		[reduction_],
		[array_, implementation => reduction_(implementation)(value => accumulation => [value, ...accumulation])([])],
	]), error);
	const nil = list();
	return nil;
})();

const list1 = (extent_)(list0)(10);
const list2 = (extent_)(list1)(100);
const list3 = (extent_)(list2)(1000);

console.log((head_)(list3) + " === 1000: " + ((head_)(list3) === 1000));
console.log((head_)(tail_)(list3) + " === 100: " + ((head_)(tail_)(list3) === 100));
console.log((head_)(tail_)(tail_)(list3) + " === 10: " + ((head_)(tail_)(tail_)(list3) === 10));
console.log((head_)(tail_)(tail_)(tail_)(list3) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(list3) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(list3) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(list3) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list3) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list3) === undefined));

const list4 = (translation_)(list3)(value => value + 1);

console.log((head_)(list4) + " === 1001: " + ((head_)(list4) === 1001));
console.log((head_)(tail_)(list4) + " === 101: " + ((head_)(tail_)(list4) === 101));
console.log((head_)(tail_)(tail_)(list4) + " === 11: " + ((head_)(tail_)(tail_)(list4) === 11));
console.log((head_)(tail_)(tail_)(tail_)(list4) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(list4) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(list4) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(list4) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list4) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list4) === undefined));

const list5 = (collection_)(list4)(value => value !== 101);

console.log((head_)(list5) + " === 1001: " + ((head_)(list5) === 1001));
console.log((head_)(tail_)(list5) + " === 11: " + ((head_)(tail_)(list5) === 11));
console.log((head_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(list5) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(list5) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(list5) === undefined));
console.log((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list5) + " === undefined: " + ((head_)(tail_)(tail_)(tail_)(tail_)(tail_)(list5) === undefined));

const accumulation4 = (reduction_)(list4)(value => accumulation => value + accumulation)(909);

console.log(accumulation4 + " === 2022: " + (accumulation4 === 2022));

const array4 = (array_)(list4);

console.log(array4 + " === 11,101,1001: " + (JSON.stringify(array4) === "[11,101,1001]"));

console.log("exceptions:");

try{
	(stretch_)(shape_)(solid_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected attribute: (solid_)": ' + (exception === "unexpected attribute: (solid_)"));
}

try{
	(solid_)(stretch_)(shape_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "attributes applied to an invalid argument: (solid_)": ' + (exception === "attributes applied to an invalid argument: (solid_)"));
}

try{
	(weight_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected attribute: (weight_)": ' + (exception === "unexpected attribute: (weight_)"));
}

try{
	(solid_)(cube1);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected attribute: (solid_)": ' + (exception === "unexpected attribute: (solid_)"));
}

try{
	(shape_)(x => 2 * x);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "attributes applied to an invalid argument: (shape_)": ' + (exception === "attributes applied to an invalid argument: (shape_)"));
}

try{
	(shape_)(2);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "attributes applied to an invalid argument: (shape_)": ' + (exception === "attributes applied to an invalid argument: (shape_)"));
}

try{
	(shape_)();
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "attributes applied to an invalid argument: (shape_)": ' + (exception === "attributes applied to an invalid argument: (shape_)"));
}

try{
	const cube = IMPLEMENTATION([
		[shape_, [
			[label_, implementation => side => `cube of side ${side}`],
			[volume_, implementation => side => side * side * side],
			[invariant_],
			[alignment_, implementation => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_, implementation => (volume_(implementation) * volume_(implementation)) / (surface_(implementation) * surface_(implementation) * surface_(implementation))],
			[alignment_],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "missing implementations: (shape_)(surface_) (shape_)(stretch_)": ' + (exception === "missing implementations: (shape_)(surface_) (shape_)(stretch_)"));
}

try{
	const cube = IMPLEMENTATION([
		[shape_, [
			[label_, implementation => side => `cube of side ${side}`],
			[surface_, implementation => side => side * side * 6],
			[volume_, implementation => side => side * side * side],
			[stretch_, implementation => side => k => cube(side * k)],
			[invariant_, implementation => side => 1],
			[alignment_, implementation => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_, implementation => (volume_(implementation) * volume_(implementation)) / (surface_(implementation) * surface_(implementation) * surface_(implementation))],
			[alignment_],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "unexpected implementations: (shape_)(invariant_)": ' + (exception === "unexpected implementations: (shape_)(invariant_)"));
}

try{
	const cube = IMPLEMENTATION([
		[shape_, [
			[label_, implementation => side => `cube of side ${side}`],
			[surface_, implementation => side => side * side * 6],
			[volume_, implementation => side => side * side * side],
			[stretch_, implementation => side => k => cube(side * k)],
			[invariant_],
			[alignment_, implementation => side => o => typeof o === "number"? o + side: alignment_(o)(side)],
		]],
	], SPECIFICATION([
		[shape_, SPECIFICATION([
			[label_],
			[surface_],
			[volume_],
			[stretch_],
			[invariant_],
			[alignment_],
		])],
		[solid_, SPECIFICATION([
			[label_],
			[weight_],
			[alignment_],
			[test_],
		])],
	]), error);
	console.error("unreachable script");
}
catch(exception){
	console.log('"' + exception + '" === "missing implementations: (shape_)(invariant_)": ' + (exception === "missing implementations: (shape_)(invariant_)"));
}

console.log("debugs:");

const debug1 = cube(1)()().map(attribute => attribute.name);
console.log(JSON.stringify(debug1) + ' === ["shape_","solid_"]: ' + (JSON.stringify(debug1) === '["shape_","solid_"]'));

const debug2 = cube(1)()(shape_).mapping().map(attribute => attribute.name);
console.log(JSON.stringify(debug2) + ' === ["label_","surface_","volume_","stretch_","invariant_","alignment_"]: ' + (JSON.stringify(debug2) === '["label_","surface_","volume_","stretch_","invariant_","alignment_"]'));

const debug3 = cube(1)()(shape_).mapping(alignment_);
console.log(debug3 + ' === undefined: ' + (debug3 === undefined));

const debug4 = cube(1)()(shape_).mapping(solid_);
console.log(typeof(debug4) + ' === function: ' + (typeof(debug4) === "function"));

const debug5 = cube(1)()(shape_).mapping(solid_)();
console.log(debug5 + ' === undefined: ' + (debug5 === undefined));


</script>
</body>
</html>