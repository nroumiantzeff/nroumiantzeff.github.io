<!doctype html>
<html>
<head>
<title>js-effectuality</title>
</head>
<body>

<!----------------------------------------------------------------------------------------------------------------------------------------------------------------------

What is Effectuality?
Effectuality is a solution: Effectuality solves the issue of composing n-ary asynchronous functions
Effectuality is an abstraction: Effectuality abstracts side-effects, notably, asynchronous side-effects and input-output side-effects
Effectuality is a model: Effectuality models callback functions
Effectuality is JavaScript: Effectuality targets web application and is implented using JavaScript most of it being pure functional code but it could be ported to other programming languages 
Effectuality is functional: programming with Effectuality is about composition and combinators, programming with Effectuality is pure, programming with Effectuality is declarative and point free, in Effectuality every thing is a function
Effectuality is reactive: Effectuality deals with events, representing asynchronous effects, triggered by effects
Effectuality is a generalization: generalization of IO Monad, generalization of Task Monad, generalization of Continuation Monad, generalization of Hughes Arrow
Effectuality is unification: unification of IO Monad, Task Monad, Continuation Monad, Hughes Arrow, Promises, side-effects, n-ary functions
Effectuality is a miscibilization: effectualization allows composition of different Monads (IO, Task, Continuation, ...) as well as function of different arities (0, 1, 2, 3, ...)
Effectuality is a disability: Effectuality is color blind (does not distinguih synchronous from asynchronous functions), a composition of synchronous Effectualities is transparently synchronous, a composition of asynchronous Effectualities is transparently asynchronous, a composition of synchronous and asynchronous Effectualities is transparently asynchronous
Effectuality is simplification: Effectuality has a single operation, composition, without the need of explicit composition operator
Effectuality is mathematics: Effectuality thrusts the mathematical backbone of functional programming all the way
Effectuality is an algebra: Effectuality is a semiring, with composition as operation and concatenation as notation
Effectuality is semantic: Effectuality operational semantics models the effects, Effectuality denotational semantics models the algebra operation (composition), an Effectuality description corresponds to an inverted Hoare triple of the axiomatic semantics
Effectuality is natural: there is a natural transformation between Effectuality composition and side-effect chaining
Effectuality is a logic: as an alternative to the propositional logic and quantum logic, Effectuality logic considers implications between effects, called eventualities, true if they occur, false otherwise
Effectuality is a category: Effectuality is a Category with the set of eventualities as its objects and implications as morphisms
Effectuality is a theory: Effectuality functors map eventualities to program callbacks and implications to callback calls, the natural transformation between Effectuality functors corresponds to the effect of program execution
Effectuality is a description: Effectuality is a description of the application, extracting then interpreting it runs the application
Effectuality is a interpretation: an Effectuality description may be interpreted by the Effectuality interpreter to run the programm including side-effects (the Effectuality interpreter is agnostic unlike the free Monad interpreter)
Effectuality is a circumvention: Effectuality circumvent the functional programming purity by delegating side-effects to the framework, like the IO Monad and Task Monad
Effectuality is a computation: Effectuality, like the Hughes Arrow and unlike Monads, may express any computation, including recursive computations
Effectuality is an abduction: an Effectuality infers the cause from the effect
Effectuality is an inversion: Effectuality composition is right to left, the cause Effectuality appears after the effect Effectuality implied by that cause, Effectuality conjunction is a right to left
Effectuality is a strategy: Effectuality is a top-down startegy, Effectuality is a goal oriented strategy
Effectuality is a library: Effectuality is a nano, standalone, single-function JavaScript library with support for composition
Effectuality is a framework: Effectuality comes with a sample mini-framework exposing web-application typical side-effects such as concurrence, recurrence, conjunction, injunction, disjunction, injunction, log, observation, stream, delay, signal, request, HTML components
Effectuality is a toolbox: combinators maybe implemented from the Effectuality core implementation some of which are provided as sample shuch as unit, any, all, either, lift, ...
Effectuality is a web-page: a single standalone web-page includes the Effecttuality implementation and a mini-framwork, performs selft-tests, generates and runs sample web-applications
Effectuality is a project: Effectuality is an open-source github project, https://nroumiantzeff.github.io/js-effectuality/js-effectuality.htm
Effectuality is a type: Effectuality is a functional type, unlike data types which are objects with an API, an Effectuality instance is a function with a single API, called by calling the instance
Effectuality is a type-system: Effectuality checks that a JavaScript expression is an Effectuality instance at runtime
Effectuality is an encapsulation: Effectuality encapsulate impure effects preventing the program from triggering them directly
Effectuality is an endomorphism: composition of Effectuality instances returns an Effectuality instance, combinators take Effectuality instances and return an Effectuality instance
Effectuality is an idea: Effectuality ((t -> ()) -> (s -> ())
Effectuality is a patern: effectuality(function implication(effect){ return function cause(...x){ ... return effect(...y, ...x); }; })
Effectuality is a collection: the cause and effect arguments correspond to a conservative stack (no removal)
Effectuality is a commitment: arguments shant be consumed
Effectuality is a rule: from a cause an effect shall be called once and once only
Effectuality is a convention: Effectuality instances are distinguished in the code by surounding parentheses, (effectuality1), which leads to Effectuality composition a peculiar JavaScript syntax: (effectuality1)(effectuality2)(effectuality3)
Effectuality is a mitigation: unlike when debugging a standard functional program composition, the call stack of an Effectuality program is comprehensible
Effectuality is a function: Effectuality core implementation is a single function of less than 30 lines of native functional JavaScript (not counting comments)
Effectuality is a generator: generating an Effectuality instance is as follows: effectuality(implication) where implication type is ((t -> ()) -> (s -> ()))
Effectuality is an injection: framework injects functions to get the Effectuality instance generator: const effectuality = Efectuality(encryption, decryption1, decryption2) where encryption is a public key function and decryption1 and decryption2 are private key functions
Effectuality is a dependency: an Effectuality implication injects the effect to the cause
Effectuality is an architecture: the framework instanciates the Effectuality instance generator and injects it together with encapsulated side-effects to the program which returns an Effectuality ran by the framework
Effectuality is a convenience: Effectuality interpretation of an Effectuality program may be performed server side or client side, Effectuality compilation of an Effectuality program may pre-generate web-pages on the server or dynamically generate web-pages on the client
Effectuality is an interface: the Effectuality API supports definition and composition of Effectuality instances
Effectuality is a language: the Effectuality language expressions, each enclosed by parentheses, either atomic Effectuality instances or concatenation of expressions or combination of expressions (application of combinator) are Effectuality instances, native Effectuality instances and native Effectuality combinators are providied by the environment, notably, the lift combinator which provides interoperability with JavaScript
Effectuality is a terminology: Effectuality is the quality of being able to bring about an effect, the power to be effective, adequate to accomplish a purpose, producing the intended or expected result
Effectuality is a signature: (t -> ()) -> (s -> ())
Effectuality is a manifesto: (t -> ()) -> (s -> ())
Effectuality is a continuation: in a continuation passing style the effect represents the rest of the computation after the cause, an Effectuality is a composable continuation  
Effectuality is a singularity: although there are tones of articles, papers, about Monads and Promises, nothing is to be found on the signature (t -> ()) -> (s -> ())
Effectuality is a quest: from the complexity of web-application development, to functional programming, functional reactive programming, IO Monad, Task Monad, Huges Arrow and Effectuality
Effectuality is an integration: Effectuality integrates to TypeScript allowing checking Effecuality composition compatibility: type Effectuality<T extends unknown[], S extends unknown[]> = <R extends unknown[], Q extends unknown[]>(effectuality1: Effectuality<R, Q>) => R extends [...S, ...infer V]? Effectuality<[...T, ...V], Q>: R extends Partial<S>? S extends [...[any] extends R? [any]: [any, any] extends R? [any, any]: [any, any, any] extends R? [any, any, any]: [any, any, any, any] extends R? [any, any, any, any]: [any, any, any, any, any] extends R? [any, any, any, any, any]: [any, any, any, any, any, any] extends R? [any, any, any, any, any, any]: [any, any, any, any, any, any, any] extends R? [any, any, any, any, any, any, any]: [any, any, any, any, any, any, any, any] extends R? [any, any, any, any, any, any, any, any]: /* ... up to 100 underflow subtype checking ... */ R, ...infer U]? Effectuality<T, [...Q, ...U]>: never: never;
Effectuality is a pluralism: Effectuality may be implemented in Haskell: data Effectuality t s = Effectuality ((t -> ()) -> (s -> ())), implication :: Effectuality t s -> ((t -> ()) -> (s -> ())), implication (Effectuality i) = i, (<<) :: Effectuality t s -> Effectuality s r -> Effectuality t r, effectuality1 << effectuality2 = Effectuality (\effect -> (implication effectuality2) ((implication effectuality1) effect))
Effectuality is a tribute: Effectuality is a tribute to callbacks, asynchronous and n-ary yet composable
Effectuality is a rebellion: Effectuality is a rebellion against the rebellion against callbacks
Effectuality is a rehabilitation: Effectuality rehabilitates callbacks by renaming them eventualities
Effectuality is a joy: the arguments passed between Effectuality eventualities (aka callbacks) may be considered as a Joy (the concatenative functional language) stack, Joy conservative combinators may be implemented as Effectuality instances and composed with other Effectuality instances, the stack is conservative except for the injunction combinator (Effectuality equivalent of function application)
Effectuality is a tendency: since Effectuality allows composition of nary functions and since nary arguments are concatenated, Effectuality composition has a tendency of beeing used extensively, Effectuality conjunction (Hughes arrow operations "first", "second", ...) has a tendency of not beeing needed
Effectuality is a scale: at the level 0 you rearrange the argument stack using standard stack combinators, at the level 1 you use conservative stack combinators togeteher with the injunction combinator to reduce the arguments stack, at level 2 you use the tag combinator to automatically adapt the argument stack, at level 3 use the store combinator to immutably model procedural variables (linear conservative stack)
Effectuality is a discipline: if programming is easy but functional programming is hard and requires discipline then Effectuality is easy but conservative Effectuality is hard and requires discipline
Effectuality is a riddle: what is simple yet incomprehensible, obvious yet inconceivable, beautiful yet frightening
Effectuality is a silogism: functional is fun, Effectuality is functional, Effectuality is fun
Effectuality is social: be part of the social framewok by writing your own JavaScript framework, copy the Effectuality function, rename it to your pseudonym and share it with your friends
Effectuality is a thesis: to do
Effectuality is a vision: a vision of a free world, free of Promise, Async/Await, Generator, Signal, Monad and Functional Programming daily blog posts
Effectuality is an anthem: no Future
Effectuality is a contradiction: the structure of an Effectuality declarative program is sequential by nature which is procedural by nature
Effectuality is an aberration: functions with signature such as t -> (), s -> (), (t1, t2, ...) -> (), (s1, s2, ...) -> () are mathematical aberrations because they have no returned value, in a pure functional JavaScript program their calls might as well be replaced by undefined  
Effectuality is a trade-off: the abherrant signature Effectuality ((t -> ()) -> (s -> ())) could be replace by a conforment yet more complex signature Effectuality ((t -> $) -> (s -> $)) where $ is an opaque type, forcing the cause (s -> $) implementation to call the effect (t -> $) and return its value 
Effectuality is fractal: Effectuality ((t -> ()) -> (s -> ())), Effectuality ((Effectuality ((v -> ()) -> (u -> ())) -> ()) -> (Effectuality ((t -> ()) -> (s -> ())) -> ())), ...
Effectuality is a question: why have you been reading this up to here?
Effectuality is an exclamation: stop reading this crap and go write some code!
Effectuality is an end: since Effectuality twists the brain it is an end to a means, Effectuality means the end of my research since it proves that a mathematicaly perfect abstraction is not suitable for the coder mass
Effectuality is an hoax: Effectuality will be officialy released on the first of april to fool people into thinking Effectuality is an hoax
Effectuality is a community: be the first to be part of it
Effectuality is a quotation: "I realise that my entire social and professional live has been dedicated to my emotional preparation for the diclosure of this project"
Effectuality is beyond: Effectuality is one step beyond callbacks, one step beyond Promises, one step beyond Monads, one step beyond Applicative Functors, one step beyond Arrows, one step beyond Effectuality, one step beyond...
Effectuality is a message: Effectuality is a message to you rudy, i hope that someone gets my message in the bottle
Effectuality is a revolution: Effectuality fits right in, it's a revolution, i suppose
Effectuality is an utopia: imagine all the people programming with Effectuality, first born unicorn, functional core software, dream of Effectuality

--------------------------------------------------
Effectuality "hello world" application description
--------------------------------------------------

// application: Effectuality -> Concurrence -> Recurrence -> Conjunction -> Disjunction -> Injunction -> Log -> Observation -> Stream -> Delay -> Signal -> Request -> Component -> Effectuality ((() -> ()) -> (() -> ()))
function application(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component){
	const declaration = (component(true)("hello-world")({
		description: function(){
			return { DIV: ["Hello World!"] };
		},
	}));
	const definition = (component("hello-world")());
	return (definition)(declaration);
}

-------------------------------------------------------------------------------
Effectuality application compilation and execution (performed by the framework)
-------------------------------------------------------------------------------

compilation(application)();

----------------------------------------------------
Effectuality entry point (provided by the framework)
----------------------------------------------------

// effectuality: (((t1, t2, ...) -> ()) -> ((s1, s2, ... -> ())) -> Effectuality (((t1, t2, ...) -> ()) -> (s1, s2, ... -> ()))
// Effectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())): Effectuality (((s1, s2, ...) -> ()) -> ((r1, r2, ...) -> ())) -> Effectuality (((t1, t2, ...) -> ()) -> ((r1, r2, ...) -> ()))

---------------------------------------------------------
Effectuality core combinators (provided by the framwork)
---------------------------------------------------------

// concurrence: Effectuality ((([tj1, tj2, ...], ...) -> ()) -> ([[[ti1, ti2, ...], CountN, IndexNi], ...] -> ())) -> (Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())) -> ... -> Effectuality ((([tj1, tj2, ...], ...) -> ()) -> (([s11, s12, ...], [s21, s22, ...], ...) -> ())))
 
// recurrence: Effectuality (((Boolean, ..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ())) -> Effectuality (((..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ())) -> Effectuality (((..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ()))
// recurrence: Effectuality (((Boolean, tn, tm, ... tj, ti, ..., t2, t1, s1, s2, ...) -> ()) -> ((tj, ti, ..., t2, t1, s1, s2, ...) -> ())) -> Effectuality (((tj, ti, ..., t2, t1, s1, s2, ...) -> ()) -> ((..., t2, t1, s1, s2, ...) -> ())) -> Effectuality (((..., t2, t1, s1, s2, ...) -> () -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((..., t2, t1, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))

// conjunction: Effectuality (((t11, t12, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((t21, t22, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> ... -> Effectuality (((t11, t12, ..., t21, t22, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))

// disjunction: Effectuality (((t11, t12, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) -> Effectuality (((t21, t22, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) -> ... -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))

// injunction: Effectuality (((t1, t2, ..., s1, s2, ..., u1, u2, ...) -> ()) -> ((s1, s2, ..., u1, u2, ...) -> ())) -> Effectuality (((s1, s2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) -> Effectuality (((t1, t2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
// injunction: () -> Effectuality (((s1, s2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))

---------------------------------------------------------------
Effectuality environment combinators (provided by the framwork)
---------------------------------------------------------------

// Level: 0
// Level: 1
// Level: 2
// log: Level -> ((s1, s2, ...) -> String) -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))

// observation: () -> True -> Effectuality (((Id2, u1, u2, ...) -> ()) -> ((u1, u2...) -> ())) // registration
// observation: () -> False -> Effectuality (((Id2, u1, u2, ...) -> ()) -> ((Id2, u1, u2...) -> ())) // cancellation
// observation: True -> Id1 -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // notification
// observation: True -> Id1 -> Effectuality (((t1, t2, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // notification with initialization
// observation: True -> () -> Effectuality (((t1, t2, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((Id1, s1, s2, ...) -> ()) -> ((Id1, s1, s2, ...) -> ())) // notification with variable id1 with initialization
// observation: True -> () -> Effectuality (((Id1, s1, s2, ...) -> ()) -> ((Id1, s1, s2, ...) -> ())) // notification with variable id1
// observation: False -> True -> Id1 -> Effectuality (() -> ((s1, s2, ...) -> ())) -> Effectuality (((Id2, u1, u2, ...) -> ()) -> ((Id2, u1, u2...) -> ())) // cancellable observation
// observation: False -> False -> Id1 -> Effectuality (() -> ((s1, s2, ...) -> ())) -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2...) -> ())) // uncancellable observation
// observation: False -> True -> () -> Effectuality (() -> ((s1, s2, ...) -> ())) -> Effectuality (((Id1, Id2, u1, u2, ...) -> ()) -> ((Id1, Id2, u1, u2...) -> ())) // cancellable observation with variable id1
// observation: False -> False -> () -> Effectuality (() -> ((s1, s2, ...) -> ())) -> Effectuality (((Id1, u1, u2, ...) -> ()) -> ((Id1, u1, u2...) -> ())) // uncancellable observation with variable id1

// stream: () -> (StreamConsumerCount -> StreamWatermark -> StreamOndemandProducer -> Effectuality (((Id, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) // declaration
// stream: () -> (True -> StreamWatermark -> StreamOndemandProducer -> Effectuality (((Id, StreamConsumerCount, u1, u2, ...) -> ()) -> ((StreamConsumerCount, u1, u2, ...) -> ())) // declaration
// stream: () -> (StreamConsumerCount -> True -> StreamOndemandProducer -> Effectuality (((Id, StreamWatermark, u1, u2, ...) -> ()) -> ((StreamWatermark, u1, u2, ...) -> ())) // declaration
// stream: () -> (True -> True -> StreamOndemandProducer -> Effectuality (((Id, StreamConsumerCount, StreamWatermark, u1, u2, ...) -> ()) -> ((StreamConsumerCount, StreamWatermark, u1, u2, ...) -> ())) // declaration
// stream: True -> Effectuality (((s, Id, u1, u2, ...) -> ()) -> ((s, Id, u1, u2, ...) -> ())) // production
// stream: False -> StreamConsumerIndex -> Effectuality (((s, Id, u1, u2...) -> ()) -> ((Id, u1, u2...) -> ())) // consumption
// stream: False -> True -> Effectuality (((s, StreamConsumerIndex, Id, u1, u2...) -> ()) -> ((StreamConsumerIndex, Id, u1, u2...) -> ())) // consumption
// stream: False -> StreamConsumerIndex -> False -> Effectuality (((s, Id, u1, u2...) -> ()) -> ((Id, u1, u2...) -> ())) // termination
// stream: False -> True -> False -> Effectuality (((s, StreamConsumerIndex, Id, u1, u2...) -> ()) -> ((StreamConsumerIndex, Id, u1, u2...) -> ())) // termination
// stream: False -> StreamConsumerIndex -> True -> Effectuality (((Id, u1, u2...) -> ()) -> ((Id, u1, u2...) -> ())) // termination
// stream: False -> True -> True -> Effectuality (((StreamConsumerIndex, Id, u1, u2...) -> ()) -> ((StreamConsumerIndex, Id, u1, u2...) -> ())) // termination

// delay: Milliseconds -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))
// delay: True -> Effectuality (((Milliseconds, s1, s2, ...) -> ()) -> ((Milliseconds, s1, s2, ...) -> ()))
// delay: () -> (True -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // registration
// delay: () -> (False -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((Id, s1, s2, ...) -> ()))) // cancellation
// delay: Milliseconds -> True -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((Id, s1, s2, ...) -> ())) // cancellable
// delay: True -> True -> Effectuality (((Milliseconds, Id, s1, s2, ...) -> ()) -> ((Milliseconds, Id, s1, s2, ...) -> ())) // cancellable

// signal: () -> (True -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // registration
// signal: () -> (False -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((Id, s1, s2, ...) -> ()))) // cancellation
// signal: Milliseconds -> Effectuality (() -> ((Time, Id, s1, s2, ...) -> ())) -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((Id, s1, s2, ...) -> ()))
// signal: True -> Effectuality (() -> ((Time, Id, s1, s2, ...) -> ())) -> Effectuality (((Milliseconds, Id, s1, s2, ...) -> ()) -> ((Milliseconds, Id, s1, s2, ...) -> ()))

// request: () -> (True -> Effectuality (((Id, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))) // registration
// request: () -> (False -> Effectuality (((Id, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))) // cancellation
// request: ((s1, s2, ...) -> [{}]) -> Milliseconds -> Effectuality ((([{}], s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // uncancellable
// request: ((s1, s2, ...) -> [{}]) -> Milliseconds -> True -> Effectuality ((([{}], id, s1, s2, ...) -> ()) -> ((id, s1, s2, ...) -> ())) // cancellable

// component: True -> () -> ComponentTypeAttribute -> ComponentSubtypeAttribute -> ComponentEffectAttributePrefix -> ComponentCauseAttributePrefix -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
// component: True -> ComponentType -> ComponentRegistration -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
// component: ComponentType -> ComponentSubtype -> { PropertyName: PropertyValue, ... } -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
// component: ComponentType -> ComponentSubtype -> True -> Effectuality ((({ PropertyName: PropertyValue, ... }, u1, u2, ...) -> ()) -> (({ PropertyName: PropertyValue, ... }, u1, u2, ...) -> ()))

-------------------------------
Effectuality sample combinators
-------------------------------

// effectualityZero: Effectuality -> Effectuality ()
var zero = effectualityZero(effectuality);

// effectualityUnit: Effectuality -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))
var unit = effectualityUnit(effectuality);

// effectualityLift: Effectuality -> (((s1, s2, ...) -> t) -> Effectuality (((t, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())))
// effectualityLift: Effectuality -> (((s1, s2, ...) -> [t1, t2, ...]) -> True -> Effectuality (((t1, t2, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())))
var lift = effectualityLift(effectuality);

// effectualityInitialization: Effectuality -> t1 -> t2 -> ... -> Effectuality (((t1, t2, ...) -> ()) -> (() -> ()))
var initialization = effectualityInitialization(effectuality);

// effectualityCopy: Effectuality -> Index -> Index -> ... -> Effectuality ((si, sj, ..., s1, s2, ...] -> ()) -> ((s1, s2, ...) -> ()))
var initialization = effectualityInitialization(effectuality);

// effectualityInjunctionFit: Effectuality -> Injunction -> (EffectIndex -> EffectIndex -> ...) -> (CauseIndex -> CauseIndex -> ...) -> (Effectuality (((t1, t2, t3, ..., u1, u2, u3, ...) -> ()) -> ((s1, s2, ..., u1, u2, u3, ...) -> ())) -> Effectuality (((ti, tj, ..., u1, ..., s1, u2, ..., s2, u3, ...) -> ()) -> ((u1, ..., s1, u2, ..., s2, u3, ...) -> ()))))
var fit = effectualityInjunct
ionFit(effectuality, injunction);

// effectualityIndexation: Effectuality (((t11, t12, ...) -> ()) -> ((Index, s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((Index, s21, s22, ...) -> ())) -> ... -> [Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())) -> ...]
var indexation = effectualityIndexation(effectuality);

// effectualityConcurrenceAll: Effectuality -> Concurrence -> (Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())) -> ... -> Effectuality ((([t11, t12, ...], [t21, t22, ...], ...) -> ()) -> (([s11, s12, ...], [s21, s22, ...], ...) -> ())))
var all = effectualityConcurrenceAll(effectuality, concurrence);

// effectualityConcurrenceAny: Effectuality -> Concurrence -> (Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())) -> ... -> Effectuality (((ti1, ti2, ...) -> ()) -> (([s11, s12, ...], [s21, s22, ...], ...) -> ())))
var any = effectualityConcurrenceAny(effectuality, concurrence);

// effectualityConcurrenceEither: Effectuality -> Concurrence -> (Effectuality ((Boolean -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality ((Boolean -> ()) -> ((s1, s2, ...) -> ())) -> ... -> (Effectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> ... -> Effectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ()))))
var either = effectualityConcurrenceEither(effectuality, concurrence);

// effectualityStore: Effectuality -> True -> Key, Key, ... -> Effectuality ((Store, s, u1, u2, ...) -> ()) -> ((s, u1, u2, ...) -> ()))
// effectualityStore: Effectuality -> False -> Key, Key, ... -> Effectuality ((s, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
// effectualityStore: Effectuality -> True -> True, True, ... -> Effectuality ((Store, Key, Key, ..., s, u1, u2, ...) -> ()) -> ((Key, Key, ..., s, u1, u2, ...) -> ()))
// effectualityStore: Effectuality -> False -> True, True, ... -> Effectuality ((s, Key, Key, ..., u1, u2, ...) -> ()) -> ((Key, Key, ..., u1, u2, ...) -> ()))
var store = effectualityConcurrenceStore(effectuality);

// tag: [String, String, ...] -> [String, String, ...] -> Effectuality(((t1, t2, ..., u1, u2, ...) -> ()) -> ((s1, s2, ..., u1, u2, ..., Tag (s1, s2, ..), v1, v2, ...) -> ())) -> Effectuality(((Tag (t1, t2, ..., s1, s2, ...), u1, u2, ..., Tag (s1, s2, ...), v1, v2, ...) -> ()) -> ((u1, u2, ..., Tag (s1, s2, ...), v1, v2, ...)  -> ()))
var tag = effectualityConcurrenceTag(effectuality);

----------------------------------------------------
Effectuality pure sample (using the lift combinator)
----------------------------------------------------

// square: Effectuality (((Number, Number, u1, u2, ...) -> ()) -> ((Number, u1, u2, ...) -> ()))
const square = effectualityLift(x => x * x);

----------------------------------------------------
Effectuality pure sample Effectuality (from scratch)
----------------------------------------------------

// square: Effectuality (((Number, Number, u1, u2, ...) -> ()) -> ((Number, u1, u2, ...) -> ()))
const square = effectuality(function implication(effect){
	// effect: (Number, Number, u1, u2, ...) -> ()
	// cause: (Number, u1, u2, ...) -> ()
	return function cause(value, ...x){
		return effect(value * value, value, ...x);
	};
});

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------->

<script> "use strict"

///////////////
// Effectuality

// Effectuality functional type
// effectuality: (((t1, t2, ...) -> ()) -> ((s1, s2, ... -> ())) -> Effectuality (((t1, t2, ...) -> ()) -> (s1, s2, ... -> ()))
// Effectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())): Effectuality (((s1, s2, ...) -> ()) -> ((r1, r2, ...) -> ())) -> Effectuality (((t1, t2, ...) -> ()) -> ((r1, r2, ...) -> ()))
function Effectuality(encryption, decryption1, decryption2){
	// encryption, decryption1, decryption2 are functions specified by the framework to secure the communication between the framework and the Effectuality implementation
	// zero: Effectuality ()
	const zero = effectuality(function implication(effect){
		return function cause(){
		};
	});
	// effectuality: (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ()))
	function effectuality(implication){
		if (implication === undefined){
			return zero;
		}
		// composition: Effectuality (((s1, s2, ...) -> ()) -> ((r1, r2, ...) -> ())) -> Effectuality (((t1, t2, ...) -> ()) -> ((r1, r2, ...) -> ()))
		// compositionEffectuality: Effectuality (((s1, s2, ...) -> ()) -> ((r1, r2, ...) -> ()))
		return function composition(compositionEffectuality){
			if (compositionEffectuality === encryption){
				return decryption2(implication);
			}
			if (compositionEffectuality === undefined || compositionEffectuality === zero){
				return zero;
			}
			// compositionImplication: ((s1, s2, ...) -> ()) -> ((r1, r2, ...) -> ())
			const compositionImplication = decryption1(compositionEffectuality);
			if (compositionImplication === undefined){
				return zero;
			}
			// return: Effectuality (((t1, t2, ...) -> ()) -> ((r1, r2, ...) -> ()))
			return effectuality(function(effect){
				// effect: (t1, t2, ...) -> ()
				// implication: ((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())
				const cause = implication(effect);
				// cause: (s1, s2, ...) -> ()
				// return: (r1, r2, ...) -> ()
				return compositionImplication(cause);
			});
		}
	};
	return effectuality;
}

</script>

<div id="self-tests" style="display:none">
<h2> Effectuality self-tests </h2>
<div style="width: 27em; display: inline-block">input</div> <input style="width: 10em" id="input01" value="7"> input01: 7 <input style="width: 10em" id="output01"> output01: <br/>
<div style="width: 27em; display: inline-block">output</div> <input style="width: 10em" id="input02" value="7"> input02: 7 <input style="width: 10em" id="output02"> output02: input02: 7<br/>
<div style="width: 27em; display: inline-block">output effectuality input</div> <input style="width: 10em" id="input03" value="7"> input03: 7 <input style="width: 10em" id="output03"> output03: input03 * 2: 14<br/>
<div style="width: 27em; display: inline-block">output addition addition input</div> <input style="width: 10em" id="input04" value="6"> input04: 7 <input style="width: 10em" id="output04"> output04: input04 * 10 + input04 * input04: 96.6<br/>
<div style="width: 27em; display: inline-block">output recurrence input</div> <input style="width: 10em" id="input05" value="1"> input05: 1 <input style="width: 10em" id="output05"> output05: input05 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2: 1024<br/>
<div style="width: 27em; display: inline-block">output initialization-reduction-recurrence input</div> <input style="width: 10em" id="input06" value="1"> input06: 1 <input style="width: 10em" id="output06"> output06: input06 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2: 1024<br/>
<div style="width: 27em; display: inline-block">output ternary-addition all input</div> <input style="width: 10em" id="input07" value="6"> input07: 6 <input style="width: 10em" id="output07"> output07: input07 * 10 + input07 * input07 + input07 / 10: 96.6<br/>
<div style="width: 27em; display: inline-block">output ternary-addition any input</div> <input style="width: 10em" id="input08" value="6"> input08: 6 <input style="width: 10em" id="output08"> output08: input08 * input08 + input08: 42<br/>
<div style="width: 27em; display: inline-block">output injunction input</div> <input style="width: 10em" id="input09" value="6"> input09: 6 <input style="width: 10em" id="output09"> output09: 75<br/>
<div style="width: 27em; display: inline-block">output delay input</div> <input style="width: 10em" id="input10" value="6"> input10: 6 <input style="width: 10em" id="output10"> output10: input10 * 10 + input10 * input10 + input10 / 10: 96.6<br/>
<div style="width: 27em; display: inline-block">output request input</div> <input style="width: 10em" id="input11" value="6"> input11: 6 <input style="width: 10em" id="output11"> output11: PretechEnergy<br/>
<div style="width: 27em; display: inline-block">output request canceled-any input</div> <input style="width: 10em" id="input13" value="6"> input13: 6 <input style="width: 10em" id="output13"> output13: AtlasIntercom<br/>
<div style="width: 27em; display: inline-block">output ternary-addition first variable-delay input</div> <input style="width: 10em" id="input14" value="6"> input14: 6 <input style="width: 10em" id="output14"> output14: 75<br/>
<div style="width: 27em; display: inline-block">output ternary-addition second variable-delay input</div> <input style="width: 10em" id="input15" value="6"> input15: 6 <input style="width: 10em" id="output15"> output15: 51<br/>
<div style="width: 27em; display: inline-block">output ternary-addition third variable-delay input</div> <input style="width: 10em" id="input16" value="6"> input16: 6 <input style="width: 10em" id="output16"> output16: 15.6<br/>
<div style="width: 27em; display: inline-block">output ternary-addition canceled-any fixed-delay input</div> <input style="width: 10em" id="input17" value="6"> input17: 6 <input style="width: 10em" id="output17"> output17: 51<br/>
<div style="width: 27em; display: inline-block">output ternary-addition canceled-any first variable-delay input</div> <input style="width: 10em" id="input18" value="6"> input18: 6 <input style="width: 10em" id="output18"> output18: 75<br/>
<div style="width: 27em; display: inline-block">output ternary-addition canceled-any second variable-delay input</div> <input style="width: 10em" id="input19" value="6"> input19: 6 <input style="width: 10em" id="output19"> output19: 51<br/>
<div style="width: 27em; display: inline-block">output ternary-addition canceled-any third variable-delay input</div> <input style="width: 10em" id="input20" value="6"> input20: 6 <input style="width: 10em" id="output20"> output20: 15.6<br/>
<div style="width: 27em; display: inline-block">output conjunction first recurrence input</div> <input style="width: 10em" id="input31" value="1"> input31: 1 <input style="width: 10em" id="output31"> output31: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024<br/>
<div style="width: 27em; display: inline-block">output conjunction second recurrence input</div> <input style="width: 10em" id="input32" value="1"> input32: 1 <input style="width: 10em" id="output32"> output32: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512<br/>
<div style="width: 27em; display: inline-block">output composition first recurrence input</div> <input style="width: 10em" id="input33" value="1"> input33: 1 <input style="width: 10em" id="output33"> output33: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024<br/>
<div style="width: 27em; display: inline-block">output composition second recurrence input</div> <input style="width: 10em" id="input34" value="1"> input34: 1 <input style="width: 10em" id="output34"> output34: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512<br/>
<div style="width: 27em; display: inline-block">output constant-rate-signal input</div> <input style="width: 10em" id="input41" value="6"> input41: 6 <input style="width: 10em" id="output41"> output41: 0, 6000, 12000, 18000, 24000, 30000, 36000, 42000, 48000<br/>
<div style="width: 27em; display: inline-block">output variable-rate-signal input</div> <input style="width: 10em" id="input42" value="6"> input42: 6 <input style="width: 10em" id="output42"> output42: 0, 12000, 24000, 36000, 48000<br/>
<div style="width: 27em; display: inline-block">output push-pull-pull-push-stream consumption-1 input</div> <input style="width: 10em" id="input50" value="2"> input50: 2 <input style="width: 10em" id="output50"> output50: input50 * 6: 12<br/>
<div style="width: 27em; display: inline-block">output push-pull-pull-push-stream consumption-2 input</div> <input style="width: 10em" id="input51" value="3"> input51: 3 <input style="width: 10em" id="output51"> output51: input51 * 7: 21<br/>
<div style="width: 27em; display: inline-block">output pull-pull-ondemand-stream consumption-1 input</div> <input style="width: 10em" id="input52" value="2"> input52: 2 <input style="width: 10em" id="output52"> output52: input52 * 10: 20<br/>
<div style="width: 27em; display: inline-block">output pull-pull-ondemand-stream consumption-2 input</div> <input style="width: 10em" id="input53" value="3"> input53: 3 <input style="width: 10em" id="output53"> output53: input53 * 10: 30<br/>
<div style="width: 27em; display: inline-block">output push-pull-asynchronous-stream consumption-1 input</div> <input style="width: 10em" id="input54" value="2"> input54: 2 <input style="width: 10em" id="output54"> output54: 2, 7, 9, 12, 16, 17, 23, 22, 30<br/>
<div style="width: 27em; display: inline-block">output push-pull-asynchronous-stream consumption-2 input</div> <input style="width: 10em" id="input55" value="3"> input55: 3 <input style="width: 10em" id="output55"> output55: 3, 8, 10, 13, 17, 18, 24, 23, 31<br/>
<div style="width: 27em; display: inline-block">output pull-push-asynchronous-stream consumption-1 input</div> <input style="width: 10em" id="input56" value="2"> input56: 2 <input style="width: 10em" id="output56"> output56: 2, 7, 9, 12, 16, 17, 23, 22, 30<br/>
<div style="width: 27em; display: inline-block">output pull-push-asynchronous-stream consumption-2 input</div> <input style="width: 10em" id="input57" value="3"> input57: 3 <input style="width: 10em" id="output57"> output57: 3, 8, 10, 13, 17, 18, 24, 23, 31<br/>
<div style="width: 27em; display: inline-block">output asynchronous-ondemand-stream consumption-1 input</div> <input style="width: 10em" id="input58" value="2"> input58: 2 <input style="width: 10em" id="output58"> output58: 2, 12, 22, 32, 42, 52, 62, 72, 82, 92<br/>
<div style="width: 27em; display: inline-block">output asynchronous-ondemand-stream consumption-2 input</div> <input style="width: 10em" id="input59" value="3"> input59: 3 <input style="width: 10em" id="output59"> output59: 3, 13, 23, 33, 43, 53, 63, 73, 83, 93<br/>
<div style="width: 27em; display: inline-block">output push-push-pull-pull-watermark-stream consumption-1 input</div> <input style="width: 10em" id="input60" value="2"> input60: 2 <input style="width: 10em" id="output60"> output60: input60 * 6: 12<br/>
<div style="width: 27em; display: inline-block">output push-push-pull-pull-watermark-stream consumption-2 input</div> <input style="width: 10em" id="input61" value="3"> input61: 3 <input style="width: 10em" id="output61"> output61: input61 * 7: 21<br/>
<div style="width: 27em; display: inline-block">output constant-id-observation input</div> <input style="width: 10em" id="input70" value="6"> input70: 6 <input style="width: 10em" id="output70"> output70: input70 * 7: 42<br/>
<div style="width: 27em; display: inline-block">output variable-id-observation input</div> <input style="width: 10em" id="input71" value="6"> input71: 6 <input style="width: 10em" id="output71"> output71: input71 * 7: 42<br/>
<div style="width: 27em; display: inline-block">output cancellable-constant-id-observation input</div> <input style="width: 10em" id="input72" value="6"> input72: 6 <input style="width: 10em" id="output72"> output72: input72 * 7: 42<br/>
<div style="width: 27em; display: inline-block">output cancellable-variable-id-observation input</div> <input style="width: 10em" id="input73" value="6"> input73: 6 <input style="width: 10em" id="output73"> output73: input73 * 7: 42<br/>
<br/>
<div><b>Open browser console to see more self-tests...</b></div>
</div>

<div id="sample" style="display:none">

<h2> Effectuality sample </h2>

<input id="sample-input" value="4"/> input <br/>
<input id="sample-output"/> asynchronous output (3 second delay): input * input <br/>
<button id="sample-run">run sample</button>
<br/><br/>

Sample source:
<textarea style="width:100%; height:4em">
// the output of a 3 second delay square of the input
(output)(square)(delay)(input)
</textarea>
<br/><br/>

Implementation of an HTML <b>input</b> side-effect Effectuality:
<textarea style="width:100%; height:13em">
// input: Effectuality (((String, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
const input = effectuality(function implication(effect){
	// effect: (String, u1, u2, ...) -> ()
	// cause: (u1, u2, ...) -> ()
	return function cause(...x){
		const element = document.getElementById("sample-input");
		const value = element? element.value: "";
		effect(value, ...x);
	};
});
</textarea>
<br/><br/>

Implementation of an HTML <b>output</b> side-effect Effectuality:
<textarea style="width:100%; height:15em">
// output: Effectuality (((String, u1, u2, ...) -> ()) -> ((String, u1, u2, ...) -> ()))
const output = effectuality(function implication(effect){
	// effect: (String, u1, u2, ...) -> ()
	// cause: (String, u1, u2, ...) -> ()
	return function cause(value, ...x){
		const element = document.getElementById("sample-output");
		if (element){
			element.value = value;
		}
		effect(value, ...x);
	};
});
</textarea>
<br/><br/>

Implementation of an asynchronous 3 second <b>delay</b> side-effect Effectuality:
<textarea style="width:100%; height:13em">
// delay: Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
const delay = effectuality(function implication(effect){
	// effect: (u1, u2, ...) -> ()
	// cause: (u1, u2, ...) -> ()
	return function cause(...x){
		setTimeout(function(){
			return effect(...x);
		}, 3000);
	};
});
</textarea>
<br/><br/>

Implementation of a <b>square</b> pure function Effectuality:
<textarea style="width:100%; height:11em">
// square: Effectuality (((Number, Number, u1, u2, ...) -> ()) -> ((Number, u1, u2, ...) -> ()))
const square = effectuality(function implication(effect){
	// effect: (Number, Number, u1, u2, ...) -> ()
	// cause: (Number, u1, u2, ...) -> ()
	return function cause(value, ...x){
		return effect(value * value, value, ...x);
	};
});
</textarea>
<br/><br/>

Effectuality core implementation: the <b>Effectuality</b> function returns the <b>effectuality</b> functional type constructor:
<textarea id="effectuality" style="width:100%; height:45em"></textarea>
</textarea>
<br/><br/>

Framework core implementation: the <b>execution</b> function executes an Effectuality defined by the application:
<textarea style="width:100%; height:47em">
	// safe access to the effectuality encapulation by the framework
	let decryption;
	function decryption1(decryptionEffectuality){ // private
		decryption = undefined; // unpure
		decryptionEffectuality(encryption);
		return decryption;
	}
	function decryption2(decryptionImplication){ // private
		decryption = decryptionImplication; // unpure
	}
	function encryption(){ // public
	}

	// Effectuality definition
	const effectuality = Effectuality(encryption, decryption1, decryption2);

	// interpretation: Efectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> ((s1, s2, ...) -> ())
	function interpretation(interpretationEffectuality){
		return function(...x){
			// implication: ((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())
			const implication = decryption1(interpretationEffectuality);
			if (implication !== undefined){
				const probe = [];
				let count = 0;
				const cause = implication(function effect(...y){
					if (++count > 1){
						console.error("Effectuality error: an effect should not be called more than once: " + count);
					}
					if (y[y.length - 1] !== probe){
						console.error("Effectuality error: cause arguments should be passed to the effect: " + y);
					}
				});
				return cause(...x, probe);
			}
		};
	}

	// execution: (s1, s2, ...) -> ()
	const execution = interpretation(effectuality1);

</textarea>

</div>

<script> "use sctrict"

////////////
// framework

// compilation: declaration -> execution
// execution: value -> expected -> label -> result
// value: a
// result: b
// expected: b
// label: string
// declaration: Effectuality -> Concurrence -> Recurrence -> Conjunction -> Disjunction -> Injunction -> Log -> Observation -> Stream -> Delay -> Signal -> Request -> Component -> ... -> Effectuality ((() -> ()) -> (() -> ()))
// effectuality: ((t -> ()) -> (s -> ())) -> Effectuality ((t -> ()) -> (s -> ()))
// effectuality: (((t1, t2, ...tN) -> ()) -> ((s1, s2, ...sM) -> ())) -> Effectuality (((t1, t2, ...tN) -> ()) -> ((s1, s2, ...sM) -> ()))
// Effectuality ((t -> ()) -> (s -> ())): Effectuality ((s -> ()) -> (r -> ())) -> Effectuality ((t -> ()) -> (r -> ()))
// Effectuality (((t1, t2, ...tN) -> ()) -> ((s1, s2, ...sM) -> ())): Effectuality (((s1, s2, ...sM) -> ()) -> ((r1, r2, ...rL) -> ())) -> Effectuality (((t1, t2, ...tN) -> ()) -> ((r1, r2, ...rL) -> ()))
// Effectuality (((t1, t2, ...tN) -> ()) -> ((s11, s12, ...s1M1, s21, s22, ...s2M2) -> ())): Effectuality (((s11, s12, ...s1M1) -> ()) -> ((r11, r12, ...r1L1) -> ())) -> Effectuality (((s21, s22, ...s2M2) -> ()) -> ((r21, r22, ...r2L2) -> ())) -> Effectuality (((t1, t2, ...tN) -> ()) -> ((r11, r12, ...r1L1, r21, r22, ...r2L2) -> ()))
// Input: Identifier -> Effectuality ((String -> ()) -> (() -> ()))
// Output: Identifier -> Effectuality ((() -> ()) -> (String -> ()), 0)
// Editbox: Identifier -> String -> Effectuality ((String -> ()) -> (s -> ())) -> Effectuality ((s -> ()) -> (s -> ()))
// Label: String -> Effectuality ((s -> ()) -> (s -> ()))
function compilation(declaration, ...additionalSideEffects){

	// safe access to the effectuality encapulation by the framework
	let decryption;
	function decryption1(decryptionEffectuality){ // private
		decryption = undefined; // unpure
		decryptionEffectuality(encryption);
		return decryption;
	}
	function decryption2(decryptionImplication){ // private
		decryption = decryptionImplication; // unpure
	}
	function encryption(){ // public
	}

	// Effectuality definition
	const effectuality = Effectuality(encryption, decryption1, decryption2);

	// framework Effectuality instances (unpure implementation)

	// recurrence: Effectuality (((Boolean, ..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ())) -> Effectuality (((..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ())) -> Effectuality (((..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ()))
	// recurrence: Effectuality (((Boolean, tn, tm, ... tj, ti, ..., t2, t1, s1, s2, ...) -> ()) -> ((tj, ti, ..., t2, t1, s1, s2, ...) -> ())) -> Effectuality (((tj, ti, ..., t2, t1, s1, s2, ...) -> ()) -> ((..., t2, t1, s1, s2, ...) -> ())) -> Effectuality (((..., t2, t1, s1, s2, ...) -> () -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((..., t2, t1, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))
	function recurrence(feedbackEffectuality, recursionEffectuality, initializationEffectuality){
		if (initializationEffectuality == undefined){
			// recursion without initialization nor reduction
			// feedbackEffectuality: Effectuality (((Boolean, ..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ()))
			// recursionEffectuality: Effectuality (((..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ()))
			// feedbackImplication: ((Boolean, ..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ())
			const feedbackImplication = decryption1(feedbackEffectuality);
			// recursionImplication: ((..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ())
			const recursionImplication = decryption1(recursionEffectuality);
			// return: Effectuality (((..., s2, s1, u1, u2, ...) -> ()) -> ((..., s2, s1, u1, u2, ...) -> ()))
			return effectuality(function implication(effect){
				// effect: (..., s2, s1, u1, u2, ...) -> ()
				// cause: (..., s2, s1, u1, u2, ...) -> ()
				return function cause(...x){
					// x: ..., s2, s1, u1, u2, ...
					// recursionEffect: (..., s2, s1, u1, u2, ...) -> ()
					function recursionEffect(...y){
						// y: ..., s2, s1, u1, u2, ...
						// feedbackCause: (..., s2, s1, u1, u2, ...) -> ()
						const feedbackCause = feedbackImplication(feedbackEffect);
						return feedbackCause(...y);
					}
					// feedbackEffect: (Boolean, ..., s2, s1, u1, u2, ...) -> ()
					function feedbackEffect(recure, ...z){
						// recure: Boolean
						// z: ..., s2, s1, u1, u2, ...
						if (recure){
							// recursionCause: (..., s2, s1, u1, u2, ...) -> ()
							const recursionCause = recursionImplication(recursionEffect);
							return recursionCause(...z);
						}
						return effect(...z);
					}
					// recursionCause: (..., s2, s1, u1, u2, ...) -> ()
					const recursionCause = recursionImplication(recursionEffect);
					recursionCause(...x);
				};
			});
		}
		// recursion with initialization and reduction
		// feedbackEffectuality: Effectuality ((Boolean, tn, tm, ... tj, ti, ..., t2, t1, s1, s2, ...) -> ()) -> ((tj, ti, ..., t2, t1, s1, s2, ...) -> ()))
		// recursionEffectuality: Effectuality (((tj, ti, ..., t2, t1, s1, s2, ...) -> ()) -> ((ti, ..., t2, t1, s1, s2, ...) -> ()))
		// initializationEffectuality: Effectuality (((..., t2, t1, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))
		// feedbackImplication: (Boolean, tn, tm, ... tj, ti, ..., t2, t1, s1, s2, ...) -> ()) -> ((tj, ti, ..., t2, t1, s1, s2, ...) -> ())
		const feedbackImplication = decryption1(feedbackEffectuality);
		// recursionImplication: ((tj, ti, ..., t2, t1, s1, s2, ...) -> ()) -> ((..., t2, t1, s1, s2, ...) -> ())
		const recursionImplication = decryption1(recursionEffectuality);
		// initializationImplication: ((..., t2, t1, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())
		const initializationImplication = decryption1(initializationEffectuality);
		// return: Effectuality (((..., t2, t1, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))
		return effectuality(function implication(effect){
			// effect: (s1, s2, ...) -> ()
			// cause: (..., t2, t1, s1, s2, ...) -> ()
			return function cause(...x){
				// x: (s1, s2, ...) -> ()
				// recursionEffectGeneration: [..., t2, t1, s1, s2, ...] -> ((tj, ti, ..., t2, t1, s1, s2, ...) -> ())
				function recursionEffectGeneration(x){
					// recursionEffect: (tj, ti, ..., t2, t1, s1, s2, ...) -> ()
					return function recursionEffect(...y){
						// y: tj, ti, ..., t2, t1, s1, s2, ...
						// feedbackCause: (tj, ti, ..., t2, t1, s1, s2, ...) -> ()
						const feedbackCause = feedbackImplication(feedbackEffectGeneration(x, y));
						return feedbackCause(...y);
					};
				}
				// feedbackGeneration: [..., t2, t1, s1, s2, ...] -> [..., t2, t1, s1, s2, ...] -> ((Boolean, tn, tm, ... tj, ti, ..., t2, t1, s1, s2, ...) -> ())
				function feedbackEffectGeneration(x, y){
					// feedbackEffect: (Boolean, tn, tm, ... tj, ti, ..., t2, t1, s1, s2, ...) -> ()
					return function feedbackEffect(recure, ...z){
						// recure: Boolean
						// z: tn, tm, ... tj, ti, ..., t2, t1, s1, s2, ...
						// reduction: tn, tm, ...
						const reduction = z.length <= y.length? []: z.slice(0, z.length - y.length);
						if (recure){
							// recursionCause: (ti, ..., t2, t1, s1, s2, ...) -> ()
							const recursionCause = recursionImplication(recursionEffectGeneration(reduction.concat(x)));
							return recursionCause(...reduction, ...x);
						}
						return effect(...reduction, ...x);
					};
				}
				// initializationEffect: (..., t2, t1, s1, s2, ...) -> ()
				function initializationEffect(...x){
					// x: ..., t2, t1, s1, s2, ...
					// recursionCause: (..., t2, t1, s1, s2, ...) -> ()
					const recursionCause = recursionImplication(recursionEffectGeneration(x));
					recursionCause(...x);
				}
				// initializationCause: (s1, s2, ...) -> ()
				const initializationCause = initializationImplication(initializationEffect);
				initializationCause(...x);
			};
		});
	}

	// concurrence: Effectuality ((([tj1, tj2, ...], ...) -> ()) -> ([[[ti1, ti2, ...], CountN, IndexNi], ...] -> ())) -> (Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())) -> ... -> Effectuality ((([tj1, tj2, ...], ...) -> ()) -> (([s11, s12, ...], [s21, s22, ...], ...) -> ())))
	function concurrence(concurrenceEffectuality){
		// concurrenceEffectuality: Effectuality (([tj1, tj2, ...], ...) -> ()) -> ([[[ti1, ti2, ...], CountN, IndexNi], ...] -> ()))
		// concurrenceImplication: ([tj1, tj2, ...], ...) -> () -> ([[[ti1, ti2, ...], CountN, IndexNi], ...] -> ())
		const concurrenceImplication = decryption1(concurrenceEffectuality);
		// occurrence: Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())) -> ... -> Effectuality ((([tj1, tj2, ...], ...) -> ()) -> (([s11, s12, ...], [s21, s22, ...], ...) -> ()))
		return function occurrence(...effectualities){
			// effectualities: [Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())), Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())), ...]
			// implications: [((s11, s12, ...) -> ()) -> ((r11, r12, ...) -> ()), ((s21, s22, ...) -> ()) -> ((r21, r22, ...) -> ()), ...]
			const implications = effectualities.map(function(item){
				if (item === effectuality()){
					return undefined;
				}
				return decryption1(item);
			}).filter(function (application){
				if (application === undefined){
					return false;
				}
				return true;
			});
			if (implications.length === 0){
				return effectuality();
			}
			// occurenceEffectuality: Effectuality ((([t11, t12, ...], [t21, t22, ...], ...) -> ()) -> (([s11, s12, ...], [s21, s22, ...], ...) -> ()))
			const occurenceEffectuality = effectuality(function implication(effect){
				// effect: ([t11, t12, ...], [t21, t22, ...], ...) -> ()
				// concurrenceEffect: [[[ti1, ti2, ...], CountN, IndexNi], ...] -> ()
				const concurrenceEffect = concurrenceImplication(effect);
				// cause: ([s11, s12, ...], [s21, s22, ...], ...) -> ()
				return function cause(...x){
					// x: (s1, s2 ...)
					// values: [[[ti1, ti2, ...], CountN, IndexNi], ...]
					let values = [];
					effectualities.reduceRight(function(accumulator, item, index){ // unpure
						// x1: (s11, s12, ...)
						const x1 = index < x.length? x[index]: [];
						// concurrentEffect: (t11, t12, ...) -> ()
						function concurrentEffect(...yi){
							// yi: (ti1, ti2, ...)
							// value: [[ti1, ti2, ...], CountN, IndexNi]
							const value = [yi.length > x.length? yi.slice(0, yi.length - x.length): [], effectualities.length, index, x];
							values.push(value); // unpure
							return concurrenceEffect(values);
						}
						// occurenceCause: (s11, s12, ...) -> ()
						const occurenceCause = implications[index](concurrentEffect);
						occurenceCause(...x); // unpure
					}, undefined);
				};
			});
			return occurenceEffectuality;
		};
	}

	// conjunction: Effectuality (((t11, t12, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((t21, t22, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> ... -> Effectuality (((t11, t12, ..., t21, t22, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))
	function conjunction(...effectualities){
		const implications = effectualities.map(function(item){
			if (item === effectuality()){
				return undefined;
			}
			return decryption1(item);
		}).filter(function (application){
			if (application === undefined){
				return false;
			}
			return true;
		});
		if (implications.length === 0){
			return effectuality();
		}
		return effectuality(function conjunctionImplication(effect){
			// effect: (t11, t12, ..., t21, t22, ..., ..., s1, s2, ...) -> ()
			// cause: (s1, s2, ...) -> ()
			return function cause(...x){
				// x: s1, s2, ...
				// partial: Index -> [[t11, t12,...], [t21, t22,...], ...] -> (Index, [[t11, t12,...], [t21, t22,...], ...])
				function partial(i, y){
					// i: Index
					// y:  [[t11, t12,...], [t21, t22,...], ...]
					if (i < 0){
						return effect(...y.flat(), ...x);
					}
					// partialEffect: (si1, si2, ...) -> ()
					function partialEffect(...yi){
						// yi: ti1, ti2, ..., s1, s2, ...
						if (yi.length <= x.length){
							return partial(i - 1, [yi, ...y]);
						}
						return partial(i - 1, [yi.slice(0, yi.length - x.length), ...y]);
					}
					// implications[i]: ((ti1, ti2, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())
					const partialCause = implications[i](partialEffect);
					return partialCause(...x);
				}
				return partial(implications.length - 1, []);
			};
		});
	}

	// disjunction: Effectuality (((t11, t12, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) -> Effectuality (((t21, t22, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) -> ... -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
	function disjunction(...effectualities){
		// return: Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
		return effectuality(function implication(effect){
			// implication: ((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())
			// effect: (u1, u2, ...) -> ()
			// cause: (u1, u2, ...) -> ()
			return function cause(...x){
				// x: u1, u2, ...
				const accumulator = effectualities.reduceRight(function(accumulator, item){
					interpretation(item)(...x);
				}, undefined);
				return effect(...x);
			};
		});
	}

	// injunction: Effectuality (((t1, t2, ..., s1, s2, ..., u1, u2, ...) -> ()) -> ((s1, s2, ..., u1, u2, ...) -> ())) -> Effectuality (((s1, s2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) -> Effectuality (((t1, t2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
	// injunction: () -> Effectuality (((s1, s2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
	function injunction(injunctionEffectuality){
		return function injunction(subjunctionEffectuality){
			// injunctionEffectuality: Effectuality (((t1, t2, ..., s1, s2, ..., u1, u2, ...) -> ()) -> ((s1, s2, ..., u1, u2, ...) -> ()))
			// effectualities[0]: Effectuality (((s1, s2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
			// return: Effectuality (((t1, t2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
			return effectuality(function implication(effect){
				// implication: ((t1, t2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())
				// effect: (t1, t2, ..., u1, u2, ...) -> ()
				// cause: (u1, u2, ...) -> ()
				return function cause(...x){
					// x: u1, u2, ...
					// subjunctionImplication: ((s1, s2, ..., u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())
					const subjunctionImplication = decryption1(subjunctionEffectuality);
					// subjunctionEffect: (s1, s2, ..., u1, u2, ...) -> ()
					function subjunctionEffect(...y){
						// y: s1, s2, ..., u1, u2, ...
						// injunctionEffect: (t1, t2, ..., s1, s2, ..., u1, u2, ...) -> ()				
						function injunctionEffect(...z){
							// z: t1, t2, ..., s1, s2, ..., u1, u2, ...
							const watermark0 = x.length;
							const watermark1 = y.length;
							const watermark2 = z.length;
							if (watermark1 <= watermark0 || watermark2 <= watermark0){
								return effect(...z);
							}
							// z0: u1, u2, ...
							const z0 = z.slice(watermark2 - watermark0);
							if (watermark2 <= watermark1){
								return effect(...z0);
							}
							// z1: s1, s2, ...
							// z2: t1, t2, ...
							const z2 = z.slice(0, watermark2 - watermark1);
							return effect(...z2, ...z0);
						}
						if (injunctionEffectuality === undefined){
							return injunctionEffect(...y)
						}
						// injunctionImplication: ((t1, t2, ..., s1, s2, ..., u1, u2, ...) -> ()) -> ((s1, s2, ..., u1, u2, ...) -> ())
						const injunctionImplication = decryption1(injunctionEffectuality);
						// injunctionCause: (s1, s2, ..., u1, u2, ...) -> () 
						const injunctionCause = injunctionImplication(injunctionEffect);
						return injunctionCause(...y);
					}
					// subjunctionCause: (u1, u2, ...) -> ()
					const subjunctionCause = subjunctionImplication(subjunctionEffect);
					return subjunctionCause(...x);
				};
			});
		};
	}

	// internal
	// delays: [[TimerId]]
	let delays = [];

	// delay: Milliseconds -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))
	// delay: True -> Effectuality (((Milliseconds, s1, s2, ...) -> ()) -> ((Milliseconds, s1, s2, ...) -> ()))
	// delay: () -> (True -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // registration
	// delay: () -> (False -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((Id, s1, s2, ...) -> ()))) // cancellation
	// delay: Milliseconds -> True -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((Id, s1, s2, ...) -> ())) // cancellable
	// delay: True -> True -> Effectuality (((Milliseconds, Id, s1, s2, ...) -> ()) -> ((Milliseconds, Id, s1, s2, ...) -> ())) // cancellable
	function delay(duration, cancellable){
		if (duration === undefined){
			return function(registration){
				if (registration){
					// registration
					return effectuality(function implication(effect){
						return function cause(...x){
							const id = delays.length;
							delays.length++; // unpure
							return effect(id, ...x);
						};
					});
				}
				// cancellation
				return effectuality(function implication(effect){
					return function cause(id, ...x){
						if (id !== undefined){
							const timers = delays[id];
							if (timers !== undefined){
								timers.forEach(function(timer){
									clearTimeout(timer);
								});
								delete delays[id];
							}
						}
						return effect(id, ...x);
					};
				});
			};
		}
		if (typeof duration !== "number"){
			// variable duration
			if (cancellable){
				// cancelable
				return effectuality(function implication(effect){
					return function cause(milliseconds, id, ...x){
						if (milliseconds >= 0){
							// asynchronous
							const timer = setTimeout(function(){
								const timers = delays[id];
								if (timers !== undefined && timers.length === 1){
									delete delays[id];
								}
								return effect(milliseconds, id, ...x);
							}, milliseconds);
							const timers = delays[id];
							if (timers === undefined){
								delays[id] = [timer];
							}
							else {
								timers.push(timer);
							}
						}
						else {
							// synchronous
							return effect(milliseconds, id, ...x);
						}
					};
				});
			}
			return effectuality(function implication(effect){
				return function cause(milliseconds, ...x){
					if (milliseconds >= 0){
						// asynchronous
						setTimeout(function(){
							return effect(milliseconds, ...x);
						}, milliseconds);
					}
					else {
						return effect(milliseconds, ...x);
					}
				};
			});
		}
		// constant duration
		const milliseconds = duration;
		if (milliseconds >= 0){
			// asynchrous
			if (cancellable){
				// cancelable
				return effectuality(function implication(effect){
					return function cause(id, ...x){
						const timer = setTimeout(function(){
							const timers = delays[id];
							if (timers !== undefined && timers.length === 1){
								delete delays[id];
							}
							return effect(id, ...x);
						}, milliseconds);
						const timers = delays[id];
						if (timers === undefined){
							delays[id] = [timer];
						}
						else {
							timers.push(timer);
						}
					};
				});
			}
			return effectuality(function implication(effect){
				return function cause(...x){
					setTimeout(function(){
						return effect(...x);
					}, milliseconds);
				};
			});
		}
		// synchronous
		return effectuality(function implication(effect){
			return function cause(...x){
				return effect(...x);
			};
		});
	}

	// internal
	// signals: [[TimerId, Rate, Count, ElapsedTime, StartTime], ...]
	var signals = [];

	// signal: () -> (True -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // registration
	// signal: () -> (False -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((Id, s1, s2, ...) -> ()))) // cancellation
	// signal: Milliseconds -> Effectuality (() -> ((Time, Id, s1, s2, ...) -> ())) -> Effectuality (((Id, s1, s2, ...) -> ()) -> ((Id, s1, s2, ...) -> ()))
	// signal: True -> Effectuality (() -> ((Time, Id, s1, s2, ...) -> ())) -> Effectuality (((Milliseconds, Id, s1, s2, ...) -> ()) -> ((Milliseconds, Id, s1, s2, ...) -> ()))
	function signal(rate, signalEffectuality){
		function transmission(state, id, x){
			const time = state[3];
			interpretation(signalEffectuality)(time, id, ...x);
		}
		function ignition(milliseconds, id, x){
			var state = signals[id];
			if (state !== undefined){
				const timer = state[0];
				if (timer !== undefined){
					clearInterval(timer); // unpure
					delete delays[id]; // unpure
				}
			}
			if (signalEffectuality !== undefined){
				var timer = setInterval(function(){
					var current = signals[id];
					if (current){
						var count = current[2];
						var start = current[4];
						var time = (new Date()).getTime(); // unpure
						current[2] = count + 1; // unpure
						current[3] = time - start; // unpure
						return transmission(current, id, x);
					}
				}, milliseconds);
				var time = (new Date()).getTime(); // unpure 
				var start = state? state[4]: time;
				var first = [timer, milliseconds, 0, time - start, start];
				signals[id] = first; // unpure
				return transmission(first, id, x);
			}
		}
		if (rate === undefined){
			return function(registration){
				if (registration){
					// registration
					return effectuality(function implication(effect){
						return function cause(...x){
							const id = signals.length;
							signals.length++; // unpure
							return effect(id, ...x);
						};
					});
				}
				// cancellation
				return effectuality(function implication(effect){
					return function cause(id, ...x){
						if (id !== undefined){
							const timer = signals[id];
							if (timer !== undefined){
								clearInterval(timer); // unpure
								delete signals[id]; // unpure
							}
						}
						return effect(id, ...x);
					};
				});
			};
		}
		if (typeof rate !== "number"){
			// variable rate
			return effectuality(function implication(effect){
				return function cause(milliseconds, id, ...x){
					ignition(milliseconds, id, x); // unpure
					return effect(milliseconds, id, ...x);
				};
			});
		}
		// constant rate
		const milliseconds = rate;
		return effectuality(function implication(effect){
			return function cause(id, ...x){
				ignition(milliseconds, id, x); // unpure
				return effect(id, ...x);
			};
		});
	}

	// internal
	// streams: [Stream]
	// Stream: [[StreamConsumerActivation], [StreamValue], [StreamConsumer], [StreamInterruption], StreamInterruptionCount, StreamValueCount, StreamWatermark, StreamOndemandProvider, StreamOndemandStack]
	// StreamConsumerActivation: Boolean
	// StreamValue: s
	// StreamConsumer: [[StreamEffect, StreamStack, StreamCompletion]]
	// StreamInterruption: [StreamEffect, StreamStack]
	// StreamStack: u1, u2, ...
	// StreamEffect: (u1, u2, ...) -> ()
	// StreamValueCount: Number
	// StreamWatermark: Number
	// StreamValueIndex: Number
	// StreamOndemandProvider: Effectuality (s -> ()) -> (StreamValueIndex -> ())) | undefined
	// StreamOndemandStack: StreamStack | undefined
	let streams = [];

	// stream: () -> (StreamConsumerCount -> StreamWatermark -> StreamOndemandProducer -> Effectuality (((Id, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ())) // declaration
	// stream: () -> (True -> StreamWatermark -> StreamOndemandProducer -> Effectuality (((Id, StreamConsumerCount, u1, u2, ...) -> ()) -> ((StreamConsumerCount, u1, u2, ...) -> ())) // declaration
	// stream: () -> (StreamConsumerCount -> True -> StreamOndemandProducer -> Effectuality (((Id, StreamWatermark, u1, u2, ...) -> ()) -> ((StreamWatermark, u1, u2, ...) -> ())) // declaration
	// stream: () -> (True -> True -> StreamOndemandProducer -> Effectuality (((Id, StreamConsumerCount, StreamWatermark, u1, u2, ...) -> ()) -> ((StreamConsumerCount, StreamWatermark, u1, u2, ...) -> ())) // declaration
	// stream: True -> Effectuality (((s, Id, u1, u2, ...) -> ()) -> ((s, Id, u1, u2, ...) -> ())) // production
	// stream: False -> StreamConsumerIndex -> Effectuality (((s, Id, u1, u2...) -> ()) -> ((Id, u1, u2...) -> ())) // consumption
	// stream: False -> True -> Effectuality (((s, StreamConsumerIndex, Id, u1, u2...) -> ()) -> ((StreamConsumerIndex, Id, u1, u2...) -> ())) // consumption
	// stream: False -> StreamConsumerIndex -> False -> Effectuality (((s, Id, u1, u2...) -> ()) -> ((Id, u1, u2...) -> ())) // termination
	// stream: False -> True -> False -> Effectuality (((s, StreamConsumerIndex, Id, u1, u2...) -> ()) -> ((StreamConsumerIndex, Id, u1, u2...) -> ())) // termination
	// stream: False -> StreamConsumerIndex -> True -> Effectuality (((Id, u1, u2...) -> ()) -> ((Id, u1, u2...) -> ())) // termination
	// stream: False -> True -> True -> Effectuality (((StreamConsumerIndex, Id, u1, u2...) -> ()) -> ((StreamConsumerIndex, Id, u1, u2...) -> ())) // termination
	function stream(operation, consumerIndex, completion){
		function declaration(streams, consumerCount, watermark, ondemandEffectuality, stack){ // unpure
			const id = streams.length;
			const values = [];
			const activations = (new Array(consumerCount || 1)).fill(true);
			const consumers = activations.map(item => []);
			const interruptions = [];
			const interruptionCount = 0;
			const valueCount = 0;
			streams[id] = [activations, values, consumers, interruptions, interruptionCount, valueCount, watermark, ondemandEffectuality, ondemandEffectuality? stack: undefined]; // unpure
			return id;
		}
		function termination(streams, id, consumerIndex){ // unpure
			const terminationStream = streams[id];
			if (terminationStream){
				if (terminationStream[0][consumerIndex] === true){
					terminationStream[0][consumerIndex] = false; // unpure
					const activations = terminationStream[0].reduce(function(accumulator, item){
						return item? accumulator + 1: accumulator;
					}, 0);
					if (activations === 0){
						delete streams[id]; // unpure
					}
				}				
			}
		}
		function production(streams, id, value, effect, x){ // unpure
			const productionStream = streams[id];
			if (productionStream){
				const values = productionStream[1];
				const index = values.length;
				values.push(value); // unpure
				productionStream[5]++; //unpure
				const consumers = productionStream[2];
				consumers.forEach(function(item, consumerIndex){
					postproduction(streams, id, consumerIndex, value, index); // unpure
				});
				return interruption(streams, id, effect, x);
			}
		}
		function postproduction(streams, id, consumerIndex, value, index){ // unpure
			const postproductionStream = streams[id];
			const consumers = postproductionStream[2];
			const consumer = consumers[consumerIndex];
			if (consumer.length > index){
				const consumption = consumer[index];
				const effect = consumption[0];
				const stack = consumption[1];
				const completion = consumption[2];
				if (completion){
					termination(streams, id, consumerIndex);
				}
				delete consumer[index]; // unpure
				oblivion(streams, id, index); // unpure
				return effect(value, ...stack); // unpure
			}
		}
		function interruption(streams, id, effect, x){
			interruptionStream = streams[id];
			const watermark = interruptionStream[6];
			if (typeof watermark === "number"){
				const valueCount = interruptionStream[5];
				if (valueCount > watermark){
					const interruptions = interruptionStream[3];
					interruptions.push([effect, x]);
					interruptionStream[4]++;
					return true;
				}
			}
		}
		function consumption(streams, id, consumerIndex, effect, x, completion){
			const consumptionStream = streams[id];
			if (consumptionStream){
				const activations = consumptionStream[0];
				if (activations[consumerIndex] === true){
					const consumers = consumptionStream[2];
					const consumer = consumers[consumerIndex];
					if (consumer){
						const index = consumer.length;
						consumer.length++; // unpure
						return resolution(streams, id, consumerIndex, index, effect, x, completion); // unpure
					}
				}
			}
		}
		function resolution(streams, id, consumerIndex, index, effect, x, completion){
			const resolutionStream = streams[id];
			const values = resolutionStream[1];
			if (values.length <= index){
				expectation(streams, id, consumerIndex, index, effect, x, completion); // unpure
			}
			else {
				const value = values[index];
				oblivion(streams, id, index); // unpure
				if (completion){
					termination(streams, id, consumerIndex);
				}
				return effect(value, ...x); // unpure
			}
		}
		function oblivion(streams, id, index){ // unpure
			const oblivionStream = streams[id];
			if (oblivionStream){
				const activations = oblivionStream[0];
				const consumers = oblivionStream[2];
				const expectations = consumers.reduce(function(expectations, item, consumerIndex){
					return activations[consumerIndex] && (index >= item.length || item[index])? expectations + 1: expectations;
				}, 0);
				if (expectations === 0){
					const values = oblivionStream[1];
					delete values[index]; // unpure
					oblivionStream[5]--; // unpure
					continuation(streams, id);
				}
			}
		}
		function continuation(streams, id){
			const continuationStream = streams[id];
			const interruptionCount = continuationStream[4];
			if (interruptionCount !== 0){
				const interruptions = continuationStream[3];
				const index = interruptions.length - interruptionCount;
				const eventuality = interruptions[index];
				const effect = eventuality[0];
				const stack = eventuality[1];
				delete interruptions[index];
				continuationStream[4]--;
				return effect(...stack);
			}
		}
		function expectation(streams, id, consumerIndex, index, effect, x, completion){
			// x: u1, u2, ...
			// effect: (s, u1, u2, ...) -> ()
			const expectationStream = streams[id];
			const consumers = expectationStream[2];
			const consumer = consumers[consumerIndex];
			consumer[index] = [effect, x, completion];
			ondemand(streams, id, consumerIndex, index);
		}
		function ondemand(stream, id, consumerIndex, index){
			const ondemandStream = streams[id];
			const ondemandEffectuality = ondemandStream[7];
			if (ondemandEffectuality !== undefined){
				const consumers = ondemandStream[2];
				const pending = consumers.reduce(function(pending, item, index2){
					return pending || index2 !== consumerIndex && index < item.length;
				}, false);
				if (!pending){
					const implication = decryption1(ondemandEffectuality);
					if (implication){
						const stack = ondemandStream[8];
						const cause = implication(function effect(value){
							production(streams, id, value);
						});
						cause(index, ...stack); // unpure
					}
				}
			}
		}
		if (operation === undefined){
			// declaration
			return function(consumerCount, watermark, ondemandEffectuality){
				if (typeof consumerCount === "number"){
					// fix consumer count
					if (typeof watermark === true){
						// variable watermark
						return effectuality(function implication(effect){
							return function cause(...x){
								// x: watermark, ...
								const id = declaration(streams, consumerCount, x[0], ondemandEffectuality, x); // unpure
								return effect(id, ...x);
							};
						});
					}
					// fix watermark
					return effectuality(function implication(effect){
						return function cause(...x){
							const id = declaration(streams, consumerCount, watermark, ondemandEffectuality, x); // unpure
							return effect(id, ...x);
						};
					});
				}
				// variable consumer count
				if (typeof watermark === true){
					// variable watermark
					return effectuality(function implication(effect){
						return function cause(...x){
							// x: consumerCount, watermark, ...
							const id = declaration(streams, x[0], x[1], ondemandEffectuality, x); // unpure
							return effect(id, ...x);
						};
					});
				}
				// fix watermark
				return effectuality(function implication(effect){
					return function cause(...x){
						// x: consumerCount, ...
						const id = declaration(streams, x[0], watermark, ondemandEffectuality, x); // unpure
						return effect(id, ...x);
					};
				});
			};
		}
		if (operation){
			// production
			return effectuality(function implication(effect){
				return function cause(...x){
					// x: value, id, ...
					if (!production(streams, x[1], x[0], effect, x)){ // unpure
						return effect(...x);
					}
				};
			});
		}
		if (completion){
			// termination without consumption
			if (typeof consumerIndex === "number"){
				// fixed consumer index
				return effectuality(function implication(effect){
					return function cause(id, ...x){
						termination(streams, id, consumerIndex); // unpure
						return effect(id, ...x); // unpure
					};
				});
			}
			// variable consumer index
			return effectuality(function implication(effect){
				return function cause(consumerIndex, id, ...x){
					termination(streams, id, consumerIndex); // unpure
					return effect(consumerIndex, id, ...x); // unpure
				};
			});
		}
		// consumption
		if (typeof consumerIndex === "number"){
			// fixed consumer index
			return effectuality(function implication(effect){
				return function cause(...x){
					// x: id, ...
					return consumption(streams, x[0], consumerIndex, effect, x, completion); // unpure
				};
			});
		}
		// fixed consumer index
		return effectuality(function implication(effect){
			return function cause(...x){
				// x: consumerIndex, id, ...
				if (completion !== undefined){
					termination(streams, x[1], x[0]); // unpure
				}
				return consumption(streams, x[1], x[0], effect, x, completion); // unpure
			};
		});
	}

	// internal
	// observations: { Id1: { Id2: [Effectuality(() -> ([Id1, Id2, ...] -> ()))] } }
	let observations = Object.create(null);
	// observers: [{Id1: True}]
	let observers = [];

	// observation: () -> True -> Effectuality (((Id2, u1, u2, ...) -> ()) -> ((u1, u2...) -> ())) // registration
	// observation: () -> False -> Effectuality (((Id2, u1, u2, ...) -> ()) -> ((Id2, u1, u2...) -> ())) // cancellation
	// observation: True -> Id1 -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // notification
	// observation: True -> Id1 -> Effectuality (((t1, t2, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // notification with initialization
	// observation: True -> () -> Effectuality (((t1, t2, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((Id1, s1, s2, ...) -> ()) -> ((Id1, s1, s2, ...) -> ())) // notification with variable id1 with initialization
	// observation: True -> () -> Effectuality (((Id1, s1, s2, ...) -> ()) -> ((Id1, s1, s2, ...) -> ())) // notification with variable id1
	// observation: False -> True -> Id1 -> Effectuality (() -> ((s1, s2, ...) -> ())) -> Effectuality (((Id2, u1, u2, ...) -> ()) -> ((Id2, u1, u2...) -> ())) // cancellable observation
	// observation: False -> False -> Id1 -> Effectuality (() -> ((s1, s2, ...) -> ())) -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2...) -> ())) // uncancellable observation
	// observation: False -> True -> () -> Effectuality (() -> ((s1, s2, ...) -> ())) -> Effectuality (((Id1, Id2, u1, u2, ...) -> ()) -> ((Id1, Id2, u1, u2...) -> ())) // cancellable observation with variable id1
	// observation: False -> False -> () -> Effectuality (() -> ((s1, s2, ...) -> ())) -> Effectuality (((Id1, u1, u2, ...) -> ()) -> ((Id1, u1, u2...) -> ())) // uncancellable observation with variable id1
	function observation(action){
		function registration(observations, observationEffectuality, id1, id2){
			if (id2 !== undefined){
				let observer = observers[id2];
				if (observer === undefined){
					observer = Object.create(null); // unpure
					observers[id2] = observer; // unpure
				}
				observer[id1] = true; // unpure
			}
			let observations1 = observations[id1];
			if (observations1 === undefined){
				observations1 = Object.create(null); // unpure
				observations[id1] = observations1; // unpure
			}
			let observations2 = observations1[id2 != null? id2: ""];
			if (observations2 === undefined){
				observations2 = []; // unpure
				observations1[id2 != null? id2: ""] = observations2; // unpure
			}
			observations2.push(observationEffectuality); // unpure
		}
		function notification(observations, id1, x, initializationEffectuality){
			const observations1 = observations[id1];
			if (observations1 !== undefined && observations1.length !== 0){
				const observations2 = Object.values(observations1);
				if (observations2.length !== 0){
					observations2.reduceRight(function(accumulator, effectualities){
						if (effectualities.length !== 0){
							if (initializationEffectuality === undefined){
								effectualities.reduceRight(function(accumulator, item){
									interpretation(item)(...x);
								}, undefined);
							}
							else {
								effectualities.reduceRight(function(accumulator, item){
									function selectionEffect(...y){
										const z = y.length <= x.length? []: y.slice(0, y.length - x.length); 
										return interpretation(item)(...z);
									}
									const initializationImplication = decryption1(initializationEffectuality);
									const initializationCause = initializationImplication(selectionEffect);
									initializationCause(...x);
								}, undefined);
							}
						}
					}, undefined);
				}
			}
		}
		if (action === undefined){
			return function(registration){
				if (registration === true){
					// registration
					return effectuality(function implication(effect){
						return function cause(...x){
							const id2 = observers.length;
							observers.length++; // unpure
							return effect(id2, ...x);
						};
					});
				}
				// cancellation
				return effectuality(function implication(effect){
					return function cause(id2, ...x){
						if (id2 != null && id2.toString() !== ""){
							const observer = observers[id2];
							if (observer !== undefined){
								for (let id1 in observer){ // unpure
									const observations1 = observations[id1];
									if (observations1 !== undefined){
										delete observations1[id2];
										let found = false;
										for (let key in observations1){
											found = true;
											break;
										}
										if (!found){
											delete observations[id1];
										}
									}
								}
								delete observers[id2]; // unpure
							}
						}
						return effect(id2, ...x);
					};
				});
			};
		}
		if (action){
			// notification
			return function(id1){
				return function(initializationEffectuality){
					if (id1 === undefined){
						// variable id1
						return effectuality(function implication(effect){
							return function cause(id1, ...x){
								notification(observations, id1, x, initializationEffectuality);
								return effect(id1, ...x);
							};
						});
					}
					// fixed id1
					return effectuality(function implication(effect){
						return function cause(...x){
							notification(observations, id1, x, initializationEffectuality);
							return effect(...x);
						};
					});
				};
			};
		}
		// observation
		return function(cancellable){
			return function(id1){
				return function(observationEffectuality){
					if (cancellable){
						// cancellable
						if (id1 === undefined){
							// variable id1
							return effectuality(function implication(effect){
								return function cause(id1, id2, ...x){
									registration(observations, observationEffectuality, id1, id2);
									return effect(id1, id2, ...x);
								};
							});
						}
						// fixed id1
						return effectuality(function implication(effect){
							return function cause(id2, ...x){
								registration(observations, observationEffectuality, id1, id2);
								return effect(id2, ...x);
							};
						});
					}
					// uncancellable
					if (id1 === undefined){
						// variable id1
						return effectuality(function implication(effect){
							return function cause(id1, ...x){
								registration(observations, observationEffectuality, id1);
								return effect(id1, ...x);
							};
						});
					}
					// fixed id1
					return effectuality(function implication(effect){
						return function cause(...x){
							registration(observations, observationEffectuality, id1);
							return effect(...x);
						};
					});
				};
			};
		};
	}

	// internal
	// requests: [[InternalId]]
	let requests = [];

	// request: () -> (True -> Effectuality (((Id, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))) // registration
	// request: () -> (False -> Effectuality (((Id, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))) // cancellation
	// request: ((s1, s2, ...) -> [{}]) -> Milliseconds -> Effectuality ((([{}], s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())) // uncancellable
	// request: ((s1, s2, ...) -> [{}]) -> Milliseconds -> True -> Effectuality ((([{}], id, s1, s2, ...) -> ()) -> ((id, s1, s2, ...) -> ())) // cancellable
	function request(simulation, timeout, cancellable){
		// simulation: (s1, s2, ...) -> [{}]
		// timeout: Number
		// cancellable: Boolean
		if (simulation === undefined){
			return function(registration){
				if (registration){
					// registration
					return effectuality(function implication(effect){
						return function cause(...x){
							const id = requests.length;
							requests.length++; // unpure
							return effect(id, ...x);
						};
					});
				}
				// cancellation
				return effectuality(function implication(effect){
					return function cause(id, ...x){
						if (id !== undefined){
							const timers = requests[id];
							if (timers !== undefined){
								timers.forEach(function(timer){
									clearTimeout(timer);
								});
								delete requests[id];
							}
						}
						return effect(id, ...x);
					};
				});
			};
		}
		if (cancellable){
			return effectuality(function implication(effect){
				return function cause(id, ...x){
					// id: Id
					// x: (s1, s2, ...)
					const timer = setTimeout(function(){
						const timers = requests[id];
						if (timers !== undefined && timers.length === 1){
							delete requests[id];
						}
						const records = simulation(...x);
						if (records === undefined){
							return effect([], id, ...x);
						}
						if (!Array.isArray(records)){
							return effect([records], id, ...x);
						}
						return effect(records, id, ...x);
					}, timeout === undefined? 1000: timeout);
					const timers = requests[id];
					if (timers === undefined){
						requests[id] = [timer];
					}
					else {
						timers.push(timer);
					}
				};
			});
		}
		return effectuality(function implication(effect){
			return function cause(...x){
				// x: (s1, s2, ...)
				setTimeout(function(){
					const records = simulation(...x);
					if (records === undefined){
						return effect([], ...x);
					}
					if (!Array.isArray(records)){
						return effect([records], ...x);
					}
					return effect(records, ...x);
				}, timeout === undefined? 1000: timeout);
			};
		});
	}

	// Level: 0
	// Level: 1
	// Level: 2
	// log: Level -> ((s1, s2, ...) -> String) -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))
	function log(level){
		return function(format){
			return effectuality(function implication(effect){
				return function cause(...x){
					const message = format(...x);
					if (Array.isArray(message)){
						if (message.length != 0){
							console[level>1?"error":level>0?"warn":"log"](...message);
						}
					}
					else if (message !== undefined){
						console[level>1?"error":level>0?"warn":"log"](message);
					}
					return effect(...x);
				};
			});
		};
	}

	// internal
	// input: Identifier -> Effectuality (((String, ...) -> ()) -> ((...) -> ()))
	function input(identifier){
		return effectuality(function implication(effect){
			// effect: (String, ...) -> ()
			// cause: (...) -> ()
			return function cause(...x){
				const element = document.getElementById(identifier);
				const value = element? element.value: "";
				effect(value, ...x);
			};
		});
	}

	// internal
	// output: Identifier -> Effectuality (((String, ...) -> ()) -> ((String, ...) -> ()))
	function output(identifier){
		return effectuality(function implication(effect){
			// effect: (String, ...) -> ()
			// cause: (String, ...) -> ()
			return function cause(value, ...x){
				const element = document.getElementById(identifier);
				if (element){
					element.value = value;
				}
				effect(value, ...x);
			};
		});
	}


	// internal
	const contextSymbol = Symbol("context");
	let contextDecryption = undefined;
	function context(object){
		if (object !== undefined){
			return Object.create(null, {
				[contextSymbol]: {
					value: function(){
						contextDecryption = object;
					}, 
				}	
			});
		}
		return function(...keys){
			return function(...x){
				const encrytion = x.reduce(function(accumulator, item){
					return accumulator || (typeof item === "object" && item !== null && item[contextSymbol]? item: undefined);
				}, undefined);
				if (encrytion !== undefined){
					contextDecryption = undefined;
					encrytion[contextSymbol]();
					const object = contextDecryption;
					if (object !== undefined){
						return keys.reduce(function(object, key){
							return typeof object === "object" && object !== null && object[key];
						}, object);
					}
				}
			}
		}
	}

	// internal
	// ComponentRegistration: {
	//		"description": ComponentDescriptio, // ComponentDescription: ComponentType -> { ComponentPropertyName: ComponentPropertyValue } -> ComponentSubtype -> Object
	//		"presence": ComponentPresence // ComponentPresence: ComponentNode -> Boolean
	//		"states":{
	//			ComponentStateName: ComponentStateExtraction, // ComponentStateExtraction: ComponentNode -> ComponentStateName -> ComponentStateParameter -> ... -> ComponentStateValue
	//			...
	//		},
	//		"properties":{
	//			ComponentPropertyName: ComponentPropertyApplication, // ComponentPropertyApplication: True || ComponentNode -> ComponentPropertyName -> ComponentNode || [ComponentNode -> ComponentPropertyName -> ComponentNode, ComponentPropertyName || ComponentPropertyName -> ComponentPropertyName]
	//			...
	//		},
	//		"events":{
	//			ComponentEventName: ComponentEventIgnition, // ComponentEventIgnition: True | ComponentSelector | [ComponentSubpropertyName, ComponentNode -> ComponentEventNode -> ComponentEventName -> ComponentSubpropertyName -> ComponentSubpropertyValue, ComponentSubpropertyName -> ComponentNode -> ComponentNode, ComponentSubpropertyName || ComponentSubropertyName -> ComponentSubpropertyName]
	//			...
	//		},
	//		"effects":[
	//			[
	//				[
	//					ComponentEffectName, // String
	//					ComponentEffectEffectuality, // Effectuality (((ComponentEffectValue, ComponentEffectName, ComponentCauseValue, ComponentCauseName, ...) -> ()) -> ((ComponentEffectName, ComponentCauseValue, ComponentCauseName, ...) -> ()))
	//					ComponentEffectSubelement, // ComponentNode -> ComponentEffectName -> Node
	//					ComponentEffectAlias, // ComponentEffectName || ComponentEffectName -> ComponentEffectName
	//				],
	//				[
	//					ComponentCauseName, // String
	//					ComponentCauseEvaluation, // ComponentNode -> ComponentCauseName -> ComponentCauseValue
	//					ComponentCauseSubelement, // ComponentNode -> ComponentCauseName -> Node
	//					ComponentCauseAlias, // ComponentCauseName || ComponentCauseName -> ComponentCauseName
	//				],
	//				ComponentEffectOptions:{
	//					"internal": Boolean, // if true, no propagation of change
	//					"hot": Boolean, // if true, execution of the Effectuality when component is connected to the DOM //todo
	//				},
	//			],
	//			...
	//		],
	//		"subcomponents":[
	//			[
	//				ComponentType,
	//				ComponentParentSelector, // for example ">aaa>bbb>ccc", //todo support array, for example ["aaa"],["bbb"],["ccc"]
	//				ComponentPropertyName,
	//				ComponentPropertyEvaluation, // ComponentPropertyEvaluation: ComponentNode -> ComponentSubcomponentNode -> ComponentSubcomponentIndex -> ComponentPropertyName -> ComponentPropertyValue
	//				ComponentSubcomponentSubtype,
	//			],
	//			...
	//		],
	//		"styles":[], //todo
	//	}, ...
	// }
	//todo focus declaration on page load
	//todo effect to focus and select elements
	//todo declaration to sort subcomponents
	// componentRegistrations: { ComponentType: ComponentRegistration, ... }
	let componentRegistrations = Object.create(null);
	// componentReactions: Map Element [Element, Boolean]
	let componentReactions = new Map();
	// componentTypeAttribute: String
	const componentTypeAttribute = "data-component-";
	// componentSubtypeAttribute: String
	const componentSubtypeAttribute = "data-subcomponent-";
	// componentType: Element -> ComponentType
	function componentType(element){
		if (element && element.nodeType === 1){
			return element.getAttribute(componentTypeAttribute) || undefined;
		}
	}
	// componentState: Node -> ComponentType -> ComponentStateArgument1 -> ComponentStateArgument2 -> ... -> ComponentStateValue
	function componentState(element, type, name, ...parameters){
		if (type && name){
			const registration = componentRegistrations[type];
			if (registration){
				const states = registration.states;
				if (states){
					const extraction = states[name];
					if (extraction){
						return extraction(componentNode(element, 0), name, ...parameters);
					}
				}
			}
		}
	}
	// ComponentNode: Key -> Node
	// ComponentNode: ComponentStateName -> ComponentStateParameter -> ... -> ComponentStateValue
	// ComponentNode.parentNode: ComponentNode
	// ComponentNode.parentComponent: ComponentNode
	// ComponentNode.nextSibling: ComponentNode
	// ComponentNode.previousSibling: ComponentNode
	// ComponentNode.nextElementSibling: ComponentNode
	// ComponentNode.previousElementSibling: ComponentNode
	// ComponentNode.nextComponentSibling: ComponentNode
	// ComponentNode.previousComponentSibling: ComponentNode
	// ComponentNode.firstChild: ComponentNode
	// ComponentNode.lastChild: ComponentNode
	// ComponentNode.firstElementChild: ComponentNode
	// ComponentNode.lastElementChild: ComponentNode
	// ComponentNode.firstComponentChild: ComponentNode
	// ComponentNode.lastComponentChild: ComponentNode
	// ComponentNode.componentType: String
	// ComponentNode.*: String
	// Level: Number
	// Key: Object
	// componentNode: Node -> Level -> ComponentNode
	// componentNode: Node -> Level -> Key -> ComponentNode
	const componentNode = (function(componentType, componentState){
		const properties = {
			parentNode: parent,
			parentComponent: parent,
			nextSibling: sibling,
			previousSibling: sibling,
			nextElementSibling: sibling,
			previousElementSibling: sibling,
			nextComponentSibling: sibling,
			previousComponentSibling: sibling,
			firstChild: child,
			lastChild: child,
			firstElementChild: child,
			lastElementChild: child,
			firstComponentChild: child,
			lastComponentChild: child,
			componentType: null,
			dataset: null,
		};
		function application(abstraction, unused, arguments){
			const node = abstraction();
			if (typeof arguments[0] === "object"){
				const key = abstraction(null);
				if (key && key === arguments[0]){
					return node;
				}
				return undefined;
			}
			const type = componentType(node);
			if (type){
				return componentState(node, type, ...arguments);
			}
		}
		function inception(){
			// traps: for(...in...)
			// list supported common properties
			const entries = Object.keys(properties).map(function(key){
				return [key];
			});
			return Object.fromEntries(entries);
		}
		function ownKeys(){
			// needed to prevent an exception 
			return ["name", "length", "caller", "arguments", "prototype"];
		}
		function prohibition(){
		}
		const handler = {
			get: function(abstraction, name) {
				const handler = properties[name] || property;
				const node = abstraction();
				const level = abstraction(true);
				const key = abstraction(null);
				return handler(node, level, name, key);
			},
			apply: application,
			getPrototypeOf: inception,
			ownKeys: ownKeys,
			construct: prohibition,
			defineProperty: prohibition,
			deleteProperty: prohibition,
			getOwnPropertyDescriptor: prohibition,
			preventExtensions: prohibition,
			set: prohibition,
			setPrototypeOf: prohibition,
		};
		const dataset = {
			get: function(object, name) {
				return object[name];
			},
			apply: prohibition,
			getPrototypeOf: prohibition,
			ownKeys: prohibition,
			construct: prohibition,
			defineProperty: prohibition,
			deleteProperty: prohibition,
			getOwnPropertyDescriptor: prohibition,
			preventExtensions: prohibition,
			set: prohibition,
			setPrototypeOf: prohibition,
		};
		function parent(node, level, name, key){
			if (level !== 0){
				if (name === "parentComponent"){
					return parentComponent(node, level, key);
				}
				return proxy(node[name], level + 1, key);
			}
		}
		function sibling(node, level, name, key){
			if (level !== 0){
				if (name === "nextComponentSibling"){
					return nextComponentSibling(node, level, key);
				}
				if (name === "previousComponentSibling"){
					return previousComponentSibling(node, level, key);
				}
				return proxy(node[name], level, key);
			}
		}
		function child(node, level, name, key){
			if (node.nodeType === 1 && (level === 0 || !componentType())){
				if (name === "firstComponentChild"){
					return firstComponentChild(node, level, key);
				}
				if (name === "lastComponentChild"){
					return lastComponentChild(node, level, key);
				}
				return proxy(node[name], level + 1, key);
			}
		}
		function property(node, level, name){
			if (name === "componentType"){
				return componentType(node);
			}
			if (name === "dataset"){
				return new Proxy(node.dataset || {}, dataset);
			}
			const value = node[name];
			switch(typeof value){
				case "string":
				case "number":
				case "boolean": {
					return value;
				}
				case "undefined": {
					if (node.nodeType === 1){
						return node.getAttribute(name);
					}
				}
			}
		}
		function parentComponent(node, level, key){
			if (node && level !== 0){
				const parentNode = node.parentNode;
				if (parentNode && parentNode.nodeType === 1){
					if (componentType(parentNode)){
						return proxy(parentNode, level - 1, key);
					}
					return parentComponent(parentNode, level, key);
				}
			}
		}
		function firstComponentChild(node, level, key){
			if (node){
				const firstChild = node.firstChild;
				if (firstChild){
					if (componentType(firstChild)){
						return proxy(firstChild, level + 1, key);
					}
					const componentChild = firstComponentChild(firstChild, level + 1, key);
					if (componentChild){
						return componentChild;
					}
					return nextComponentChild(firstChild, level + 1, key);
				}
			}
		}
		function nextComponentChild(node, level, key){
			if (node){
				const nextSibling = node.nextSibling;
				if (nextSibling){
					if (componentType(nextSibling)){
						return proxy(nextSibling, level, key);
					}
					const componentChild = firstComponentChild(nextSibling, level, key);
					if (componentChild){
						return componentChild;
					}
					return nextComponentChild(nextSibling, level, key);
				}
			}
		}
		function nextComponentSibling(node, level, key){
			if (node && level !== 0){
				const nextSibling = node.nextSibling;
				if (nextSibling){
					if (componentType(nextSibling)){
						return proxy(nextSibling, level, key);
					}
					const componentChild = firstComponentChild(nextSibling, level, key);
					if (componentChild){
						return componentChild;
					}
					return nextComponentSibling(nextSibling, level, key);
				}
				else{
					return nextComponentSibling(node.parentNode, level - 1, key);
				}
			}
		}
		function lastComponentChild(node, level, key){
			if (node){
				const lastChild = node.lastChild;
				if (lastChild){
					if (componentType(lastChild)){
						return proxy(lastChild, level + 1, key);
					}
					const componentChild = lastComponentChild(lastChild, level + 1, key);
					if (componentChild){
						return componentChild;
					}
					return previousComponentChild(lastChild, level + 1, key);
				}
			}
		}
		function previousComponentChild(node, level, key){
			if (node){
				const previousSibling = node.previousSibling;
				if (previousSibling){
					if (componentType(previousSibling)){
						return proxy(previousSibling, level, key);
					}
					const componentChild = lastComponentChild(previousSibling, level, key);
					if (componentChild){
						return componentChild;
					}
					return previousComponentChild(previousSibling, level, key);
				}
			}
		}
		function previousComponentSibling(node, level, key){
			if (node && level !== 0){
				const previousSibling = node.previousSibling;
				if (previousSibling){
					if (componentType(previousSibling)){
						return proxy(previousSibling, level, key);
					}
					const componentChild = lastComponentChild(previousSibling, level, key);
					if (componentChild){
						return componentChild;
					}
					return previousComponentSibling(previousSibling, level, key);
				}
				else{
					return previousComponentSibling(node.parentNode, level - 1, key);
				}
			}
		}
		function proxy(node, level = 0, key){
			if (node){
				const abstraction = function(extra){
					return extra === true? level: extra === null? key: node;
				};
				return new Proxy(abstraction, handler);
			}
		}
		return proxy;
		// todo add "ticks" argument to deactivate the proxy when the states have changed
	})(componentType, componentState);
	// componentTaggedDeclaration: OuterHTML -> ComponentType -> ComponentSubtype -> ComponentProperties -> OuterHTML
	function componentTaggedDeclaration(outerHTML, type, subtype, properties){
		const tagEnd = outerHTML[outerHTML.length - 2] === "/"? "/>": ">";
		if (subtype){
			return outerHTML.replace(tagEnd, ' ' + componentTypeAttribute + '="' + type + '" ' + componentSubtypeAttribute + '="' + subtype + '"' + tagEnd);
		}
		return outerHTML.replace(tagEnd, ' ' + componentTypeAttribute + '="' + type + '"' + tagEnd);
	}
	// ComponentSubcomponentType: ComponentType
	// ComponentSubcomponentSubtype: ComponentType
	// ComponentSubcomponentParentSelector: ComponentSubcomponentSelector
	// ComponentSubcomponentSelector: String
	// componentSubcomponentSelector: ComponentSubcomponentParentSelector -> ComponentSubcomponentType -> ComponentSubcomponentSubtype -> ComponentSubcomponentSelector
	function componentSubcomponentSelector(subcomponentParentSelector, subcomponentType, subcomponentSubtype){
		const selector = ":scope " + subcomponentParentSelector + ">*[" + componentTypeAttribute + "='" + subcomponentType + "']";
		if (!subcomponentSubtype){
			return selector;
		}
		return selector + "[" + componentSubtypeAttribute + "='" + subcomponentSubtype + "']";
	}
	// componentElement: Element -> ComponentElement
	function componentElement(element){
		if (element && element.nodeType === 1){
			const attribute = element.getAttribute(componentTypeAttribute);
			if (attribute){
				return element;
			}
			return componentElement(element.parentNode);
		}
	}
	// componentParent: Element -> ComponentElement
	function componentParent(element){
		if (element && element.nodeType === 1){
			return componentElement(element.parentNode);
		}
	}
	// componentSubcomponentLevel: Node -> Node -> Level -> Level
	function componentSubcomponentLevel(parent, child, level){
		if (child && child.nodeType === 1){
			if (child === parent){
				return level || 0;
			}
			return componentSubcomponentLevel(parent, child.parentNode, (level || 0) + 1);
		}
	}
	// ComponentPropertyApplication: True
	// ComponentPropertyApplication: ComponentNode -> ComponentPropertyName -> ComponentNode
	// ComponentPropertyApplication: [ComponentNode -> ComponentPropertyName -> ComponentNode, CompnentPropertyName] 
	// ComponentPropertyApplication: [ComponentNode -> ComponentPropertyName -> ComponentNode, CompnentPropertyName -> ComponentPropertyName] 
	// componentPropertyApplication: ComponentType -> ComponentPropertyName -> ComponentPropertyApplication
	function componentPropertyApplication(componentType, propertyName){
		const registration = componentRegistrations[componentType];
		if (registration){
			const properties = registration.properties;
			if (properties){
				return properties[propertyName];
			}
		}
	}
	// ComponentSubelement: Node -> ComponentPropertyName -> Node
	// componentPropertyElement: Node -> ComponentPropertyName -> Node
	// componentPropertyElement: Node -> ComponentPropertyName -> ComponentSubelement -> Node
	function componentPropertyElement(node, name, subelement){
		if (subelement === undefined){
			return node;
		}
		const key = {};
		const proxy = subelement(componentNode(node, 0, key), name);
		if (typeof proxy === "function"){
			const element = proxy(key);
			if (element === node){
				return node;
			}
			if (componentParent(element) === node && !componentType(element)){
				return element;
			}
		}
	}
	// ComponentPropertyName: String
	// ComponentAlias: ComponentPropertyName -> ComponentPropertyName
	// componentPropertyAlias: ComponentPropertyName -> ComponentPropertyName -> ComponentPropertyName
	// componentPropertyAlias: ComponentPropertyName -> ComponentAlias -> ComponentPropertyName
	function componentPropertyAlias(name, alias){
		if (alias === undefined){
			return name;
		}
		if (typeof alias === "string"){
			return alias;
		}
		return alias(name);
	}
	// componentPropertyValue: Node -> ComponentPropertyName -> ComponentPropertyValue
	function componentPropertyValue(node, name){
		const value = node[name];
		switch(typeof value){
			case "string":
			case "number":
			case "boolean": {
				return value;
			}
			case "undefined": {
				if (node.nodeType === 1){
					return node.getAttribute(name);
				}
			}
		}	
	}
	// ComponentPropertyChanged: Boolean
	// ComponentSubelement -> ComponentPropertyName -> ComponentNode 
	// componentPropertyUpdate: Node -> ComponentPropertyName -> ComponentPropertyValue -> ComponentSubelement -> ComponentPropertyChanged
	function componentPropertyUpdate(node, name, value, subelement, alias){
		if (value === undefined){
			return false;
		}
		const element = componentPropertyElement(node, name, subelement);
		if (!element){
			return false;
		}
		const key = componentPropertyAlias(name, alias);
		const oldValue = componentPropertyValue(element, key);
		if (element[key] !== undefined){
			element[key] = value;
		}
		else if (element.nodeType === 1){
			element.setAttribute(key, value);
		}
		const newValue = componentPropertyValue(element, key);
		return newValue !== oldValue;
	}
	// componentChildPropertyEvaluation: Element -> Element -> Index -> ComponentPropertyName -> ComponentPropertyEvaluation -> ComponentPropertySubelement -> ComponentPropertyAlias -> [[Node, ComponentPropertyName, ComponentPropertyValue, ComponentPropertySubelement, ComponentPropertyAlias], ...] -> [[Node, ComponentPropertyName, ComponentPropertyValue, ComponentPropertySubelement, ComponentPropertyAlias], ...]
	function componentChildPropertyEvaluation(parent, child, index, propertyName, propertyEvaluation, propertySubelement, propertyAlias, evaluations){
		// note: pure (synchornous, readonly) returns an array of node, property name and property value triples
		// note: order of evaluation is not important
		const level = componentSubcomponentLevel(parent, child);
		const propertyValue = propertyEvaluation(componentNode(parent, 0), componentNode(child, level), index, propertyName);
		if (propertyValue === undefined){
			return evaluations;
		}
		return [...evaluations, [child, propertyName, propertyValue, propertySubelement, propertyAlias]];
	}
	// componentSelectorPropertyEvaluations: Element -> Element - Boolean -> ComponentSelector -> ComponentPropertyName, ComponentPropertyEvaluation -> ComponentPropertySubelement -> ComponentPropertyAlias -> [[Node, ComponentPropertyName, ComponentPropertyValue, ComponentPropertySubelement, ComponentPropertyAlias], ...] -> [[Node, ComponentPropertyName, ComponentPropertyValue, ComponentPropertySubelement, ComponentPropertyAlias], ...]
	function componentSelectorPropertyEvaluations(parent, child, exclusion, selector, propertyName, propertyEvaluation, propertySubelement, propertyAlias, evaluations){
		// note: pure (synchornous, readonly) returns an array of node, property name and property value triples
		// note: order of evaluation is not important
		const children = parent.querySelectorAll(selector);
		if (children.length === 0){
			return evaluations;
		}
		const totalEvaluations = Array.prototype.reduce.call(children, function(evaluations, item, index){
			if (exclusion && item === child || !exclusion && item !== child){
				return evaluations;
			}
			return componentChildPropertyEvaluation(parent, item, index, propertyName, propertyEvaluation, propertySubelement, propertyAlias, evaluations);
		}, evaluations);
		return totalEvaluations;
	}
	// componentSubcomponentsPropertiesEvaluations: Element -> Element -> Boolean -> [[Node, ComponentPropertyName, ComponentPropertyValue, ComponentPropertySubelement, ComponentPropertyAlias], ...] -> [[Node, ComponentPropertyName, ComponentPropertyValue, ComponentPropertySubelement, ComponentPropertyAlias], ...]
	function componentSubcomponentsPropertiesEvaluations(parent, child, exclusion, evaluations){
		// note: pure (synchornous, readonly) returns an array of node, property name and property value triples
		// note: order of evaluation is not important
		const type = componentType(parent);
		const registration = componentRegistrations[type];
		if (!registration){
			return evaluations;
		}
		const subcomponents = registration.subcomponents;
		if (!subcomponents || subcomponents.length === 0){
			return evaluations;
		}
		const totalEvaluations = subcomponents.reduce(function(evaluations, subcomponent){
			const subcomponentType = subcomponent[0];
			const subcomponentParentSelector = subcomponent[1];
			const propertyName = subcomponent[2];
			const propertyEvaluation = subcomponent[3];
			const subcomponentSubtype = subcomponent[4];
			const subcomponentPropertyApplication = componentPropertyApplication(subcomponentType, propertyName);
			if (!subcomponentPropertyApplication){
				return evaluations;
			}
			const subcomponentSelector = componentSubcomponentSelector(subcomponentParentSelector, subcomponentType, subcomponentSubtype);
			const subcomponentPropertySubelement = typeof subcomponentPropertyApplication === "function"? subcomponentPropertyApplication: Array.isArray(subcomponentPropertyApplication)? subcomponentPropertyApplication[0]: undefined;
			const subcomponentPropertyAlias = typeof subcomponentPropertyApplication === "string"? subcomponentPropertyApplication: Array.isArray(subcomponentPropertyApplication)? subcomponentPropertyApplication[1]: undefined;
			return componentSelectorPropertyEvaluations(parent, child, exclusion, subcomponentSelector, propertyName, propertyEvaluation, subcomponentPropertySubelement, subcomponentPropertyAlias, evaluations);
		}, evaluations);
		return totalEvaluations;
		//todo subcomponents of subcomponents should be evaluated (synchronously and whithout exclusion) 
	}
	// ComponentPropertySubelement: ComponentNode -> ComponentPropertyName -> ComponentNode
	// ComponentInternalEffectOption: Boolean
	// componentEffectApplication: Element -> ComponentPropertyName -> ComponentPropertyValue -> ComponentPropertySubelement -> ComponentPropertyAlias -> ComponentInternalEffectOption -> ()
	function componentEffectApplication(element, effectPropertyName, effectPropertyValue, effectPropertySubelement, effectPropertyAlias, internalEffectOption){
		const updated = componentPropertyUpdate(element, effectPropertyName, effectPropertyValue, effectPropertySubelement, effectPropertyAlias);
		if (updated || !internalEffectOption){
			componentReaction(element);
		}
	}
	// componentEffects: Element -> ()
	function componentEffects(element){
		if (!element.isConnected){
			return;
		}
		const type = componentType(element);
		if (type){
			const registration = componentRegistrations[type];
			if (registration){
				const effects = registration.effects;
				if (effects){
					effects.forEach(function(item){
						const effect = item[0];
						const effectPropertyName = effect[0];
						const effectEffectuality = effect[1];
						const effectPropertySubelement = effect[2];
						const effectPropertyAlias = effect[3];
						const cause = item[1];
						const causePropertyName = cause[0];
						const causePropertyEvaluation = cause[1];
						const causePropertySubelement = cause[2];
						const causePropertyAlias = cause[3];
						const options = item[2];
						const internalEffectOption = options && options.internal;
						const causePropertyValue = causePropertyEvaluation(componentNode(element, 0), causePropertyName);
						if (causePropertyValue !== undefined){
							const updated = componentPropertyUpdate(element, causePropertyName, causePropertyValue, causePropertySubelement, causePropertyAlias);
							if (updated){
								const subelement = componentPropertyElement(element, effectPropertyName, effectPropertySubelement);
								if (subelement){
									const effectApplication = effectuality(function implication(effect){
										return function cause(effectPropertyValue, ...x){
											if (effectPropertyValue !== undefined){
												componentEffectApplication(element, effectPropertyName, effectPropertyValue, effectPropertySubelement, effectPropertyAlias, internalEffectOption);
											}
											return effect(effectPropertyValue, ...x);
										};
									});
									const componentContext = context({ component: { container: subelement } });
									const asynchronous = (delay(0)); // note: the interpretation must be asynchronous (specify a zero millisecond delay)
									interpretation((effectApplication)(effectEffectuality)(asynchronous))(causePropertyValue, causePropertyName, effectPropertyName, componentContext);
								}
							}
						}
					});
				}
			}
		}
	}
	// componentPresence: Element -> ()
	function componentPresence(element){
		if (!element.isConnected){
			return;
		}
		const type = componentType(element);
		if (type){
			const registration = componentRegistrations[type];
			if (registration){
				const presence = registration.presence;
				if (typeof presence === "function"){
					if (!presence(componentNode(element, 0))){
						element.parentNode.removeChild(element);
						componentReaction(element.parentElement);
					}
				}
			}
		}
	}
	// ComponentPropertySubelement: ComponentNode -> ComponentPropertyName -> ComponentNode
	// ComponentPropertyAlias: ComponentPropertyName
	// ComponentPropertyAlias: ComponentPropertyName -> ComponentPropertyName
	// componentPropertiesApplications: [[Element, ComponentPropertyName, ComponentPropertyValue, ComponentPropertySubelement, ComponentPropertyAlias], ...] -> ()
	function componentPropertiesApplications(evaluations){
		let updatedElements = new Map();
		evaluations.forEach(function(evaluation){
			const element = evaluation[0];
			const propertyName = evaluation[1];
			const propertyValue = evaluation[2];
			const propertySubelement = evaluation[3];
			const propertyAlias = evaluation[4];
			if (componentPropertyUpdate(element, propertyName, propertyValue, propertySubelement, propertyAlias))
			{
				updatedElements.set(element, true);
				componentReaction(element);
			}
		});
		for (let updatedElement of updatedElements){
			componentPresence(updatedElement);
			componentEffects(updatedElement);
		}
	}
	// componentReactionCycle: () -> ()
	function componentReactionCycle(){
		if (componentReactions.size !== 0){
			for (let reaction of componentReactions){
				const parent = reaction[0];
				const child = reaction[1][0];
				const exclusion = reaction[1][1];
				if (exclusion){
					// dealing with interdependent properties: first, the properties of the child siblings are evaluated and applied
					reaction[1][1] = false; // unpure
				}
				else{
					// dealing with interdependent properties: second, the properties of the child itself are evaluated and applied
					componentReactions.delete(parent); // unpure
					const parentParent = componentParent(parent);
					if (parentParent){
						// third, the properties of the parent parent subcomponents are evaluated and applied (recursively)
						componentReactions.set(parentParent, [parent, true]);
					}
				}					
				const evaluations = componentSubcomponentsPropertiesEvaluations(parent, child, exclusion, []);
				if (evaluations && evaluations.length !== 0){
					componentPropertiesApplications(evaluations);
				}
				break;
			}
			componentReactionCycle();
		}
	}
	// componentReaction: Element -> ()
	function componentReaction(element){
		if (element && element.isConnected){
			componentPresence(element);
			componentEffects(element);
			const parent = componentParent(element);
			if (parent){
				// note: if no parent component, no properties need to be evaluated (only the parent component specifies the component properties)
				const size = componentReactions.size;
				componentReactions.set(parent, [element, true]);
				if (size === 0){
					// restart iddle reaction queue
					componentReactionCycle();
				}
			}
		}
	}
	// ComponentSubpropertyName: String
	// ComponentSubpropertyValue: String
	// ComponentIgnition: ComponentNode -> ComponentEventNode ->ComponentEventNode -> ComponentSubpropertyValue
	// ComponentSubpropertySubelement: ComponentNode -> ComponentSubpropertyName -> ComponentNode
	// ComponentSubpropertyAlias: ComponentSubpropertyName
	// ComponentSubpropertyAlias: ComponentSubpropertyName -> ComponentSubpropertyName
	// componentEventIgnition: ComponentEventType -> Event -> ComponentIgnition -> ComponentSubpropertyName -> ComponentSubpropertySubelement -> ComponentSubpropertyAlias -> ()
	function componentEventIgnition(type, event, ignition, subpropertyName, subpropertySubelement, subpropertyAlias){
		const eventName = event.type;
		const target = event.target;
		const element = componentElement(target);
		if (element && componentType(element) === type){
			if (ignition === true){
				componentReaction(element);
			}
			else if (typeof ignition === "string"){
				if (target.matches(ignition)){
					componentReaction(element);
				}
			}
			else{
				const level = componentSubcomponentLevel(element, target);
				const subpropertyValue = ignition(componentNode(element, 0), componentNode(target, level), eventName, subpropertyName);
				if (componentPropertyUpdate(element, subpropertyName, subpropertyValue, subpropertySubelement, subpropertyAlias)){
					componentReaction(element);
				}
			}
		}
	}
	// ComponentOuterHTML: String
	// componentSubcomponentDescription: ComponentType -> ComponentProperties -> ComponentSubtype -> ComponentOuterHTML
	function componentSubcomponentDescription(type, properties, subtype){
		if (type){
			const registration = componentRegistrations[type];
			if (registration){
				const description = registration.description;
				if (description){
					const definition = description(type, properties || {}, subtype);
					const outerHTML = componentOuterHTML(definition);
					if (outerHTML){
						return componentTaggedDeclaration(outerHTML, type, subtype, properties);
					}
				}
			}
		}
		return "";
	}
	// componentDescription: Object
	function componentDescription(description){ //todo do not use document.createElement so it is compatible with server-side rendering, use strings only with proper escaping
		if (Array.isArray(description)){
			if (description.length === 0){
				// default component: line break
				return document.createElement("BR");
			}
			// component
			const type = description[0];
			const properties = description [1];
			const subtype = description[2];
			return componentSubcomponentDescription(type, properties, subtype);			
		}
		if (typeof description === "object"){
			let element = Object.keys(description).reduce(function(accumulator, key){
				if (accumulator){
					return accumulator;
				}
				const value = description[key];
				if (Array.isArray(value)){
					let element = document.createElement(key);
					value.forEach(function(item){
						if (typeof item === "string"){
							element.appendChild(document.createTextNode(item));
						}
						else{
							const child = componentDescription(item);
							if (child !== undefined){
								if (typeof child === "string"){
									const dummy = document.createElement("dummy");
									element.appendChild(dummy);
									dummy.outerHTML = child;
								}
								else{
									element.appendChild(child);
								}
							}
						}
					});
					return element;							
				}
			}, undefined);
			if (element){				
				Object.keys(description).forEach(function(key){
					const value = description[key];
					if (typeof value === "string"){
						element.setAttribute(key, value);
					}
				});
				return element;
			}
			// default element: line break
			return document.createElement("BR");
		}
	} 
	// componentOuterHTML: String -> String
	// componentOuterHTML: Object -> String
	function componentOuterHTML(description){
		if (typeof description === "string"){
			return description;
		}
		const element = componentDescription(description);
		if (element){
			return element.outerHTML;
		}
	}
	// component: True -> () -> ComponentTypeAttribute -> ComponentSubtypeAttribute -> ComponentEffectAttributePrefix -> ComponentCauseAttributePrefix -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
	// component: True -> ComponentType -> ComponentRegistration -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
	// component: ComponentType -> ComponentSubtype -> { PropertyName: PropertyValue, ... } -> Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
	// component: ComponentType -> ComponentSubtype -> True -> Effectuality ((({ PropertyName: PropertyValue, ... }, u1, u2, ...) -> ()) -> (({ PropertyName: PropertyValue, ... }, u1, u2, ...) -> ()))
	function component(type, subtype){
		if (type === true){
			return function(type){
				return function(registration){
					return effectuality(function implication(effect){
						return function cause(...x){
							componentRegistrations[type] = registration;
							const events = registration.events;
							if (events){
								const properties = registration.properties;
								for(let eventName in events){
									const ignition = events[eventName];
									if (ignition === true || typeof ignition === "string"){
										document.addEventListener(eventName, function(event){
											componentEventIgnition(type, event, ignition);
										}, true);
									}
									else if (ignition){
										const subpropertyName = ignition[0];
										if (subpropertyName){
											// note: do not change declared properties
											if (properties === undefined || properties[subpropertyName] === undefined){
												const subpropertyIgnition = ignition[1];
												const subpropertySubelement = ignition[2];
												const subpropertyAlias = ignition[3];
												if (typeof subpropertyIgnition === "function"){
													document.addEventListener(eventName, function(event){
														componentEventIgnition(type, event, subpropertyIgnition, subpropertyName, subpropertySubelement, subpropertyAlias);
													}, true);
												}
											}
										}
									}
								}
							}
							return effect(...x);
						};
					});
				};
			};
		}
		return function(properties){
			return effectuality(function implication(effect){
				return function cause(...x){
					const registration = componentRegistrations[type];
					if (registration){
						const description = registration.description;
						if (description){
							const definition = description(type, properties === true && x[0] || properties || {});
							const outerHTML = componentOuterHTML(definition);
							if (outerHTML){
								const taggedOuterHTML = componentTaggedDeclaration(outerHTML, type, subtype, properties);
								const element = document.createElement("dummy");
								const container = context()("component", "container")(...x);
								if (container !== undefined){
									container.appendChild(element);
								}
								else{
									document.body.appendChild(element);
								}
								element.outerHTML= taggedOuterHTML;
							}
						}
					}
					return effect(...x);
				};
			});
		};
	}

	// self-tests
	if (declaration === undefined){
		if (location.hash !== "#self-tests"){
			return function(){
			};
		}
		return function selfTests(){

			// effectuality test
			(function(){
				const times2 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x * 2);
						});
					};
				});
				const effectuality1 = times2;
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 14){
						console.warn("effectuality test: " + x);
					}
					else {
						console.error("effectuality test: error: expected 14: got " + x);
					}
				});
				cause(7);
			})();

			// binary-effectuality test
			(function(){
				const multiplication = effectuality(function implication(effect){
					return function cause(x1, x2){
						setTimeout(function(){
							effect(x1 * x2);
						});
					};
				});
				const effectuality1 = multiplication;
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 42){
						console.warn("binary-effectuality test: " + x);
					}
					else {
						console.error("binary-effectuality test: error: expected 42: got " + x);
					}
				});
				cause(7, 6);
			})();

			// binary-binary-effectuality test
			(function(){
				const division = effectuality(function implication(effect){
					return function cause(x1, x2){
						setTimeout(function(){
							const y2 = x1 % x2;
							const y1 = (x1 - y2) / x2;
							effect(y1, y2);
						});
					};
				});
				const effectuality1 = division;
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x1, x2){
					if (x1 === 4 && x2 === 2){
						console.warn("binary-binary-effectuality test: " + [x1, x2]);
					}
					else {
						console.error("binary-binary-effectuality test: error: expected 4,2: got " + [x1, x2]);
					}
				});
				cause(14, 3);
			})();

			// binary-effectuality binary-binary-effectuality test
			(function(){
				const multiplication = effectuality(function implication(effect){
					return function cause(x1, x2){
						setTimeout(function(){
							effect(x1 * x2);
						});
					};
				});
				const division = effectuality(function implication(effect){
					return function cause(x1, x2){
						setTimeout(function(){
							const y2 = x1 % x2;
							const y1 = (x1 - y2) / x2;
							effect(y1, y2);
						});
					};
				});
				const effectuality1 = multiplication(division);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 8){
						console.warn("binary-effectuality binary-binary-effectuality test: " + x);
					}
					else {
						console.error("binary-effectuality binary-binary-effectuality test: error: expected 8: got " + x);
					}
				});
				cause(14, 3);
			})();

			// binary-binary-effectuality binary-binary-effectuality test
			(function(){
				const division = effectuality(function implication(effect){
					return function cause(x1, x2){
						setTimeout(function(){
							const y2 = x1 % x2;
							const y1 = (x1 - y2) / x2;
							effect(y1, y2);
						});
					};
				});
				const effectuality1 = division(division);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x1, x2){
					if (x1 === 5 && x2 === 1){
						console.warn("binary-binary-effectuality binary-binary-effectuality test: " + [x1, x2]);
					}
					else {
						console.error("binary-binary-effectuality binary-binary-effectuality test: error: expected 5,1: got " + [x1, x2]);
					}
				});
				cause(35, 3);
			})();

			// effectuality effectuality test
			(function(){
				const increment3 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x + 3);
						});
					};
				});
				const times2 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x * 2);
						});
					};
				});
				const effectuality1 = increment3(times2);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 17){
						console.warn("effectuality effectuality associativity test: " + x);
					}
					else {
						console.error("effectuality effectuality associativity test: error: expected 17: got " + x);
					}
				});
				cause(7);
			})();

			// effectuality effectuality effectuality test
			(function(){
				const tenth = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x / 10);
						});
					};
				});
				const increment3 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x + 3);
						});
					};
				});
				const times2 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x * 2);
						});
					};
				});
				const effectuality1 = tenth(increment3)(times2);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 1.7){
						console.warn("effectuality effectuality effectuality test: " + x);
					}
					else {
						console.error("effectuality effectuality effectuality test: error: expected 1.7: got " + x);
					}
				});
				cause(7);
			})();

			// effectuality effectuality effectuality associativity test
			(function(){
				const tenth = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x / 10);
						});
					};
				});
				const increment3 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x + 3);
						});
					};
				});
				const times2 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x * 2);
						});
					};
				});
				const effectuality1 = tenth(increment3(times2));
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 1.7){
						console.warn("effectuality effectuality effectuality associativity test: " + x);
					}
					else {
						console.error("effectuality effectuality effectuality associativity test: error: expected 1.7: got " + x);
					}
				});
				cause(7);
			})();

			// effectuality effectuality identity effectuality test
			(function(){
				const identity = effectuality(function implication(effect){
					return function cause(x){
						effect(x);
					};
				});
				const tenth = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x / 10);
						});
					};
				});
				const increment3 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x + 3);
						});
					};
				});
				const times2 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x * 2);
						});
					};
				});
				const effectuality1 = (tenth)(increment3)(identity)(times2);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 1.7){
						console.warn("effectuality effectuality identity effectuality test: " + x);
					}
					else {
						console.error("effectuality effectuality identity effectuality test: error: expected 1.7: got " + x);
					}
				});
				cause(7);
			})();

			// addition test
			(function(){
				const addition = effectuality(function addition(effect){
					return function cause(x1, x2){
						effect(x1 + x2);
					};
				});
				const effectuality1 = addition;
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 13){
						console.warn("addition test: " + x);
					}
					else {
						console.error("addition test: error: expected 13: got " + x);
					}
				});
				cause(7, 6);
			})();

			// (addition)(square)(times10) test
			(function(){
				const addition = effectuality(function addition(effect){
					return function cause(x1, x2, ...x){
						effect(x1 + x2, ...x);
					};
				});
				const square = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						setTimeout(function(){
							effect(x1, x2 * x2, ...x);
						});
					};
				});
				const times10 = effectuality(function implication(effect){
					return function cause(x1, ...x){
						setTimeout(function(){
							effect(x1 * 10, ...x);
						});
					};
				});
				const effectuality1 = (addition)(square)(times10);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 106){
						console.warn("(addition)(square)(times10) test: " + x);
					}
					else {
						console.error("(addition)(square)(times10) test: error: expected 106: got " + x);
					}
				});
				cause(7, 6);
			})();

			// (addition)(square)(multiplication) test
			(function(){
				const addition = effectuality(function addition(effect){
					return function cause(x1, x2, ...x){
						effect(x1 + x2, ...x);
					};
				});
				const square = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						setTimeout(function(){
							effect(x1, x2 * x2, ...x);
						});
					};
				});
				const multiplication = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						setTimeout(function(){
							effect(x1 * x2, ...x);
						});
					};
				});
				const effectuality1 = (addition)(square)(multiplication);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 57){
						console.warn("(addition)(square)(multiplication) test: " + x);
					}
					else {
						console.error("(addition)(square)(multiplication) test: error: expected 57: got " + x);
					}
				});
				cause(7, 3, 6);
			})();

			// (addition)(square)(division) test
			(function(){
				const addition = effectuality(function addition(effect){
					return function cause(x1, x2, x3, ...x){
						effect(x1 + x2 + x3, ...x);
					};
				});
				const square = effectuality(function implication(effect){
					return function cause(x1, x2, x3, ...x){
						setTimeout(function(){
							effect(x1, x2, x3 * x3, ...x);
						});
					};
				});
				const division = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						setTimeout(function(){
							const y2 = x1 % x2;
							const y1 = (x1 - y2) / x2;
							effect(y1, y2, ...x);
						});
					};
				});
				const effectuality1 = (addition)(square)(division);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 42){
						console.warn("(addition)(square)(division) test: " + x);
					}
					else {
						console.error("(addition)(square)(division) test: error: expected 42: got " + x);
					}
				});
				cause(14, 3, 6);
			})();

			// ternary-addition test
			(function(){
				const addition = effectuality(function addition(effect){
					return function cause(x1, x2, x3, ...x){
						effect(x1 + x2 + x3, ...x);
					};
				});
				const tenth = effectuality(function implication(effect){
					return function cause(x1, x2, x3, ...x){
						setTimeout(function(){
							effect(x1, x2, x3 / 10, ...x);
						});
					};
				});
				const square = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						setTimeout(function(){
							effect(x1, x2 * x2, ...x);
						});
					};
				});
				const times10 = effectuality(function implication(effect){
					return function cause(x1, ...x){
						setTimeout(function(){
							effect(x1 * 10, ...x);
						});
					};
				});
				const effectuality1 = (addition)(tenth)(square)(times10);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 106.5){
						console.warn("ternary-addition test: " + x);
					}
					else {
						console.error("ternary-addition test: error: expected 106.5: got " + x);
					}
				});
				cause(7, 6, 5);
			})();

			// addition duplication test
			(function(){
				const addition = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						effect(x1 + x2, ...x);
					};
				});
				const times10 = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						setTimeout(function(){
							effect(x1, x2 * 10, ...x);
						});
					};
				});
				const square = effectuality(function implication(effect){
					return function cause(x1, ...x){
						setTimeout(function(){
							effect(x1 * x1, ...x);
						});
					};
				});
				const duplication = effectuality(function implication1(effect){
					return function cause(x1, ...x){
						effect(x1, x1, ...x);
					};
				});
				const effectuality1 = (addition)(times10)(square)(duplication);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 96){
						console.warn("addition dupliction test: " + x);
					}
					else {
						console.error("addition duplication test: error: expected 96: got " + x);
					}
				});
				cause(6);
			})();

			// addition dupliction addition duplication test
			(function(){
				const addition = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						effect(x1 + x2, ...x);
					};
				});
				const times10 = effectuality(function implication(effect){
					return function cause(x1, x2, x3, ...x){
						setTimeout(function(){
							effect(x1, x2, x3 * 10, ...x);
						});
					};
				});
				const square = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						setTimeout(function(){
							effect(x1, x2 * x2, ...x);
						});
					};
				});
				const tenth = effectuality(function implication(effect){
					return function cause(x1, ...x){
						setTimeout(function(){
							effect(x1 / 10, ...x);
						});
					};
				});
				const duplication = effectuality(function implication1(effect){
					return function cause(x1, ...x){
						effect(x1, x1, x1, ...x);
					};
				});
				const effectuality1 = (addition)(addition)(times10)(square)(tenth)(duplication);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 96.6){
						console.warn("addition addition duplication test: " + x);
					}
					else {
						console.error("addition addition duplication test: error: expected 96.6: got " + x);
					}
				});
				cause(6);
			})();

			// input test
			(function(){
				const effectuality1 = input("input01");
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === "7"){
						console.warn("input test: " + x);
					}
					else {
						console.error("input test: error: expected 7: got " + x);
					}
				});
				cause();
			})();

			// output test
			(function(){
				const effectuality1 = output("output02");
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 7){
						console.warn("output test: " + x);
					}
					else {
						console.error("output test: error: expected 7: got " + x);
					}
					const output01 = document.getElementById("output02").value;
					if (output01 === "7"){
						console.warn("output test output: " + output01);
					}
					else {
						console.error("output test output: error: expected 7: got " + output01);
					}
				});
				cause(7);
			})();

			// output effectuality input test
			(function(){
				const output03 = output("output03");
				const times2 = effectuality(function implication(effect){
					return function cause(x){
						setTimeout(function(){
							effect(x * 2);
						});
					};
				});
				const input03 = input("input03");
				const effectuality1 = output03(times2)(input03);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 14){
						console.warn("output effectuality input test: " + x);
					}
					else {
						console.error("output effectuality input test: error: expected 14: got " + x);
					}
					const output01 = document.getElementById("output03").value;
					if (output01 === "14"){
						console.warn("output effectuality input test output: " + output01);
					}
					else {
						console.error("output effectuality input test output: error: expected 14: got " + output01);
					}
				});
				cause();
			})();

			// output addition duplication addition duplication input test
			(function(){
				const output04 = output("output04");
				const addition = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						effect(x1 + x2, ...x);
					};
				});
				const times10 = effectuality(function implication(effect){
					return function cause(x1, x2, x3, ...x){
						setTimeout(function(){
							effect(x1, x2, x3 * 10, ...x);
						});
					};
				});
				const square = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						setTimeout(function(){
							effect(x1, x2 * x2, ...x);
						});
					};
				});
				const tenth = effectuality(function implication(effect){
					return function cause(x1, ...x){
						setTimeout(function(){
							effect(x1 / 10, ...x);
						});
					};
				});
				const duplication = effectuality(function implication1(effect){
					return function cause(x1, ...x){
						effect(x1, x1, x1, ...x);
					};
				});
				const input04 = input("input04");
				const effectuality1 = (output04)(addition)(addition)(times10)(square)(tenth)(duplication)(input04);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 96.6){
						console.warn("output addition addition duplication input test: " + x);
					}
					else {
						console.error("output addition addition duplication input test: error: expected 96.6: got " + x);
					}
					const output01 = document.getElementById("output04").value;
					if (output01 === "96.6"){
						console.warn("output addition addition duplication input test output: " + output01);
					}
					else {
						console.error("output addition addition duplication input test output: error: expected 96.6: got " + output01);
					}
				});
				cause();
			})();

			// delay test
			(function(){
				const addition = effectuality(function implication(effect){
					return function cause(x1, x2, x3){
						return effect(x1 + x2 + x3);
					};
				})(delay(500));
				const tenth = effectuality(function implication(effect){
					return function cause(x1, x2, x3, ...x){
						effect(x1, x2, x3 / 10, ...x);
					};
				})(delay(400));
				const square = effectuality(function implication(effect){
					return function cause(x1, x2, ...x){
						effect(x1, x2 * x2, ...x);
					};
				})(delay(300));
				const times10 = effectuality(function implication(effect){
					return function cause(x1, ...x){
						effect(x1 * 10, ...x);
					};
				})(delay(200));
				const duplication = effectuality(function implication(effect){
					return function cause(x1, ...x){
						return effect(x1, x1, x1, ...x);
					};
				})(delay(100));
				const effectuality1 = (output("output10"))(addition)(tenth)(square)(times10)(duplication)(input("input10"));
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === 96.6){
						console.warn("delay test: " + x);
					}
					else {
						console.error("delay test: error: expected 96.6: got " + x);
					}
					const output01 = document.getElementById("output10").value;
					if (output01 === "96.6"){
						console.warn("delay test asynchronous output: " + output01);
					}
					else {
						console.error("delay test asynchronous output: error: expected 96.6: got " + output01);
					}
				});
				cause();
				const output01 = document.getElementById("output10").value;
				if (output01 === ""){
					console.warn("delay test synchronous output: " + output01);
				}
				else {
					console.error("delay test synchronous output: error: expected : got " + output01);
				}
			})();

			// request test
			(function(){
				const requestShipTo = request(function(sql){
					if (sql === "SELECT * FROM shipTo WHERE shipToNumber = 6"){
						return [{ shipToNumber: 6, shipToName: "AtlasIntercom", shipToAddress: "3 Steep street, 81234 San Alonzo, USA", soldToNumber: 1, }];
					}
				});
				const requestSoldTo = request(function(sql){
					if (sql === "SELECT * FROM soldTo WHERE soldToNumber = 1"){
						return [{ soldToNumber: 1, soldToName: "PretechEnergy", soldToAddress: "19 Miranda avenue, 76123 Plant Lake, USA", }];
					}
				});
				const shipToFilter = effectuality(function implication(effect){
					return function cause(shipToNumber){
						return effect("SELECT * FROM shipTo WHERE shipToNumber = " + shipToNumber);
					};
				});
				const soldToFilter = effectuality(function implication(effect){
					return function cause(soldToNumber){
						return effect("SELECT * FROM soldTo WHERE soldToNumber = " + soldToNumber);
					};
				});
				const soldToNumber = effectuality(function implication(effect){
					return function cause(records){
						if (records.length !== 0){
							return effect(records[0].soldToNumber);
						}
						return effect("");
					};
				});
				const soldToName = effectuality(function implication(effect){
					return function cause(records){
						if (records.length !== 0){
							return effect(records[0].soldToName);
						}
						return effect("");
					};
				});
				const effectuality1 = (output("output11"))(soldToName)(requestSoldTo)(soldToFilter)(soldToNumber)(requestShipTo)(shipToFilter)(input("input11"));
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x){
					if (x === "PretechEnergy"){
						console.warn("request test: " + x);
					}
					else {
						console.error("request test: error: expected PretechEnergy: got " + x);
					}
					const output01 = document.getElementById("output11").value;
					if (output01 === "PretechEnergy"){
						console.warn("request test asynchronous output: " + output01);
					}
					else {
						console.error("request test asynchronous output: error: expected PretechEnergy: got " + output01);
					}
				});
				cause();
				const output01 = document.getElementById("output11").value;
				if (output01 === ""){
					console.warn("request test synchronous output: " + output01);
				}
				else {
					console.error("request test synchronous output: error: expected : got " + output01);
				}
			})();

			// recurrence test
			(function(){
				const times2 = effectuality(function implication(effect){
					return function cause(x0, ...x){
						setTimeout(function(){
							console.log("recurrence test: " + x0);
							effect(x0 * 2, ...x);
						}, 10000);
					};
				});
				const feedback = effectuality(function implication(effect){
					return function cause(x0, ...x){
						return effect(true, x0, ...x);
					};
				});
				const effectuality1 = recurrence(feedback, times2);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(x0, ...x){
					console.error("recurrence test: should not occur: got: " + x0);
				});
				cause(1);
			})();

			// output recurence input test
			(function(){
				const times2 = effectuality(function implication(effect){
					return function cause(x0, ...x){
						setTimeout(function(){
							effect(x0 * 2, ...x);
						}, 100);
					};
				});
				const feedback = effectuality(function implication(effect){
					return function cause(x0, ...x){
						const recurse = x0 < 1000;
						return effect(recurse, x0, ...x);
					};
				});
				const inputInput05 = input("input05");
				const outputOutput05 = output("output05");
				const inputOutput05 = input("output05");
				const effectuality1 = recurrence((feedback),(outputOutput05)(times2)(inputOutput05),)(outputOutput05)(inputInput05);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(...x){
				});
				cause();
			})();

			// output initialization-reduction-recurence input test
			(function(){
				const times2 = effectuality(function implication(effect){
					return function cause(x0, ...x){
						setTimeout(function(){
							effect(x0 * 2, x0, ...x);
						}, 100);
					};
				});
				const feedback = effectuality(function implication(effect){
					return function cause(x0, ...x){
						const recurse = x0 < 1000;
						return effect(recurse, x0, x0, ...x);
					};
				});
				const initialization = effectuality(function implication(effect){
					return function cause(...x){
						return effect(...x);
					};
				});
				const inputInput06 = input("input06");
				const outputOutput06 = output("output06");
				const inputOutput06 = input("output06");
				const effectuality1 = recurrence((feedback),(outputOutput06)(times2)(inputOutput06),(initialization))(outputOutput06)(inputInput06);
				const implication1 = decryption1(effectuality1);
				const cause = implication1(function effect(...x){
				});
				cause();
			})();
		};
	}

	///////////////////////////////////////////////////////////
	// execution

	function preparation(additionalSideEffects){
		return additionalSideEffects.map(function(item){
			return item(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component);
		});
	}

	// declaration: Effectuality -> Concurrence -> Recurrence -> Conjunction -> Disjunction -> Injunction -> Log -> Observation -> Stream -> Delay -> Signal -> Request -> Component -> ... -> Effectuality ((() -> ()) -> (() -> ()))
	const effectuality1 = declaration(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, ...preparation(additionalSideEffects));
	// effectuality1: Effectuality ((t -> ()) -> (s -> ()))
	// interpretation: Efectuality ((t -> ()) -> (s -> ())) -> (s -> ())
	function interpretation(interpretationEffectuality){
		return function(...x){
			// implication: (t -> ()) -> (s -> ())
			const implication = decryption1(interpretationEffectuality);
			if (implication !== undefined){
				const probe = [];
				let count = 0;
				const cause = implication(function effect(...y){
					if (++count > 1){
						console.error("Effectuality error: an effect should not be called more than once: " + count);
					}
					if (y[y.length - 1] !== probe){
						console.error("Effectuality error: cause arguments should be passed to the effect: " + y);
					}
				});
				return cause(...x, probe);
			}
		};
	}

	// execution: s -> ()
	const execution = interpretation(effectuality1);

	return execution;
}

//////////////////////////////////
// Effectuality combinators (pure)

// effectualityZero: Effectuality -> Effectuality ()
function effectualityZero(effectuality){
	return effectuality();
}

// effectualityUnit: Effectuality -> Effectuality (((s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ()))
function effectualityUnit(effectuality){
	return effectuality(function implication(effect){
		return function cause(...x){
			return effect(...x);
		};
	});
}

// effectualityLift: Effectuality -> (((s1, s2, ...) -> t) -> Effectuality (((t, s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())))
// effectualityLift: Effectuality -> (((s1, s2, ...) -> [t1, t2, ...]) -> True -> Effectuality (((t1, t2, ..., s1, s2, ...) -> ()) -> ((s1, s2, ...) -> ())))
function effectualityLift(effectuality){
	return function lift(f, spread){
		// f: (s1, s2, ...) -> t
		return effectuality(function implication(effect){
			return function cause(...x){
				const y = f(...x);
				if (spread && Array.isArray(y)){
					return effect(...y, ...x);
				}
				return effect(y, ...x);
			};
		});
	};
}

// effectualityInitialization: Effectuality -> t1 -> t2 -> ... -> Effectuality (((t1, t2, ...) -> ()) -> (() -> ()))
function effectualityInitialization(effectuality){
	return function initialization(...x){
		// y: (t1, t2, ...tN)
		return effectuality(function implication(effect){
			return function cause(...y){
				return effect(...x, ...y);
			};
		});
	};
}

// effectualityCopy: Effectuality -> Index -> Index -> ... -> Effectuality ((si, sj, ..., s1, s2, ...] -> ()) -> ((s1, s2, ...) -> ()))
function effectualityCopy(effectuality){
	function extraction(indices, x){
		// indices = number, number, ...
		// x: u1, ..., s1, u2, ..., s2, u3, ...
		const y = indices.reduce(function(accumulator, item){
			if (Array.isArray(item)){
				return [...accumulator, extraction(item, x)];
			}
			return [...accumulator, x[item]];
		}, []);
		// return: s1, s2, ... 
		return y;
	}
	return function copy(...indices){
		return effectuality(function implication(effect){
			// implication: ((t1, t2, ..., u1, ..., s1, u2, ..., s2, u3, ...) -> ()) -> ((u1, ..., s1, u2, ..., s2, u3, ...) -> ())
			// effect: ((t1, t2, ..., u1, ..., s1, u2, ..., s2, u3, ...) -> ()
			// cause: (u1, ..., s1, u2, ..., s2, u3, ...) -> ()
			return function cause(...x){
				// x: u1, ..., s1, u2, ..., s2, u3, ...
				// x1: s1, s2, ...
				const x1 = extraction(indices, x);
				return effect(...x1, ...x);
			};
		});
	};
}

// effectualityInjunctionFit: Effectuality -> Injunction -> (EffectIndex -> EffectIndex -> ...) -> (CauseIndex -> CauseIndex -> ...) -> (Effectuality (((t1, t2, t3, ..., u1, u2, u3, ...) -> ()) -> ((s1, s2, ..., u1, u2, u3, ...) -> ())) -> Effectuality (((ti, tj, ..., u1, ..., s1, u2, ..., s2, u3, ...) -> ()) -> ((u1, ..., s1, u2, ..., s2, u3, ...) -> ()))))
function effectualityInjunctionFit(effectuality, injunction){
	const copy = effectualityCopy(effectuality);
	return function fit(...effectIndices){
		return function fit(...causeIndices){
			return function fit(fitEffectuality){
				return injunction(copy(...effectIndices))((fitEffectuality)(copy(...causeIndices)));
			};
		};
	};
}

// effectualityIndexation: Effectuality (((t11, t12, ...) -> ()) -> ((Index, s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((Index, s21, s22, ...) -> ())) -> ... -> [Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())) -> ...]
function effectualityIndexation(effectuality){
	return function indexation(...indexationEffectualities){
		return indexationEffectualities.map(function(item, index){
			// item: Effectuality (((ti1, ti2, ...) -> ()) -> ((Index, si1, si2, ...) -> ()))
			// index: Index
			// indexationEffectuality: Effectuality (((Index, si1, si2, ...) -> ()) -> ((si1, si2, ...) -> ()))
			const indexationEffectuality = effectuality(function implication(effect){
				// implication: ((Index, si1, si2, ...) -> ()) -> ((si1, si2, ...) -> ())
				// effect: (Index, si1, si2, ...) -> ()
				// cause: (Index, si1, si2, ...) -> ()
				return function cause(...x){
					// x: si1, si2, ...
					return effect(index, ...x);
				};
			});
			// return: Effectuality (((ti1, ti2, ...) -> ()) -> ((si1, si2, ...) -> ()))
			return (item)(indexationEffectuality)
		});
	};
}

// effectualityConcurrenceAll: Effectuality -> Concurrence -> (Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())) -> ... -> Effectuality ((([t11, t12, ...], [t21, t22, ...], ...) -> ()) -> (([s11, s12, ...], [s21, s22, ...], ...) -> ())))
function effectualityConcurrenceAll(effectuality, concurrence){
	return concurrence(effectuality(function(effect){
		return function cause(values){
			// values: [[[si1, si2, ...siNi], [CountN, IndexNi, [u1, u2, ...]]], ...]
			// value: [[si1, si2, ...siNi], CountN, IndexNi, [u1, u2, ...]]
			const value = values[values.length - 1];
			// count: IndexN
			const count = value[1];
			const z = value[3];
			if (values.length === count){
				const y = values.slice().sort((item1, item2) => item1[2] - item2[2]).map(value => value[0]).flat(); // note: sort is unpure but (sort o slice) is pure
				return effect(...y, ...z);
			}
		};
	}));
}

// effectualityConcurrenceAny: Effectuality -> Concurrence -> (Effectuality (((t11, t12, ...) -> ()) -> ((s11, s12, ...) -> ())) -> Effectuality (((t21, t22, ...) -> ()) -> ((s21, s22, ...) -> ())) -> ... -> Effectuality (((ti1, ti2, ...) -> ()) -> (([s11, s12, ...], [s21, s22, ...], ...) -> ())))
function effectualityConcurrenceAny(effectuality, concurrence){
	return concurrence(effectuality(function(effect){
		return function cause(values){
			// values: [[[si1, si2, ...siNi], CountN, IndexNi, [u1, u2, ...]], ...]
			if (values.length === 1){
				const value = values[0];
				const x = value[0];
				const z = value[3];
				return effect(...x, ...z);
			}
		};
	}));
}

// effectualityConcurrenceEither: Effectuality -> Concurrence -> (Effectuality ((Boolean -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality ((Boolean -> ()) -> ((s1, s2, ...) -> ())) -> ... -> (Effectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> Effectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ())) -> ... -> Effectuality (((t1, t2, ...) -> ()) -> ((s1, s2, ...) -> ()))))
function effectualityConcurrenceEither(effectuality, concurrence){
	return function(...conditionalities){
		return function(...alternatives){
			if (conditionalities.length === 0){
				if (alternatives.length === 0){
					return effectuality(function unit(effect){
						return function cause(...x){
							return effect(...x);
						};
					});
				}
				return alternatives[0];
			}
			const effectualitiesIf = conditionalities.length > alternatives.length? conditionalities: conditionalities.slice(0, alternatives.length);
			const effectualitiesThen = alternatives.length === effectualitiesIf.length + 1? alternatives: alternatives.length === effectualitiesIf.length? alternatives.concat(effectualityUnit(effectuality)): alternatives.slice(0, effectualitiesIf.length + 1);
			const concurrenceIf = concurrence(effectuality(function(effect){
				return function cause(values){
					// values: [[[si1, si2, ...siNi], CountN, IndexNi, [u1, u2, ...]], ...]
					const value = values[values.length - 1];
					const check = value[0][0];
					if (check || values.length === value[1] && effectualitiesIf.length < effectualitiesThen.length){
						const done = values.reduce(function(accumulator, item, index){
							return accumulator || index < values.length - 1 && item[0][0];
						}, false);
						if (!done){
							const index = value[2];
							const trail = value[3];
							return effect(check? index: values.length, ...trail);
						}
					}
				};
			}));
			const concurrenceThen = concurrence(effectuality(function(effect){
				return function cause(values){
					// values: [[si1, si2, ...siNi], [CountN, IndexNi, [u1, u2, ...]], ...]
					const value = values[values.length - 1];
					const x = value[0];
					const trail = value[3].slice(2);
					return effect(...x, ...trail);
				};
			}));
			const concurrenciesThen = effectualitiesThen.map(function(item, index){
				return item(effectuality(function implication(effect){
					return function cause(x0, ...x){
						if (x0 === index){
							return effect(x[0], x0, ...x);
						}
					};
				}));
			});
			return (concurrenceThen(...concurrenciesThen))(concurrenceIf(...effectualitiesIf));
		};
	};
}

// effectualityStore: Effectuality -> True -> Key, Key, ... -> Effectuality ((Store, s, u1, u2, ...) -> ()) -> ((s, u1, u2, ...) -> ()))
// effectualityStore: Effectuality -> False -> Key, Key, ... -> Effectuality ((s, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
// effectualityStore: Effectuality -> True -> True, True, ... -> Effectuality ((Store, Key, Key, ..., s, u1, u2, ...) -> ()) -> ((Key, Key, ..., s, u1, u2, ...) -> ()))
// effectualityStore: Effectuality -> False -> True, True, ... -> Effectuality ((s, Key, Key, ..., u1, u2, ...) -> ()) -> ((Key, Key, ..., u1, u2, ...) -> ()))
const effectualityStore = (function(){
	const symbol = Symbol("stores");
	const stores = Object.create(null, {
		[symbol]: {
			value: true, 
		}
	});
	function find(x, determinations){
		const found = x.reduce(function(accumulator, item, index){
			return accumulator || (index >= determinations && typeof item === "object" && item !== null && item[symbol]? item: undefined);
		}, undefined);
		return found || stores;
	}
	function read(object, keys, x){
		if (keys.length === 0){
			return;
		}
		const value = keys.reduce(function(object, key, index){
			return object? object[resolution(key, index, keys, x)]: undefined;
		}, object);
		return value;
	}
	function write(value, object, keys, x){
		if (keys.length === 0 || value === read(object, keys, x)){
			return object;
		}
		const node = keys.reduceRight(function(node, key, index){
			const leaf = read(object, keys.slice(0, index), x);
			return Object.create(leaf || stores, {
				[resolution(keys[index], index, keys, x)]:{
					value: node || value,
					enumerable: true,
				}
			});
		}, undefined);
		return node;
	}
	function resolution(key, index, keys, x){
		if (typeof key === "string"){
			return key;
		}
		const xIndex = keys.reduce(function(accumulator, item, itemIndex){
			if (itemIndex >= index){
				return accumulator;
			}
			if (typeof item === "string"){
				return accumulator;
			}
			return accumulator + 1;
		}, 0);
		return x[xIndex];
	}
	function determination(keys){
		const count = keys.reduce(function(count, item){
			return (typeof item === "string")? count: count + 1;
		}, 0);
		return count;
	}
	return function(effectuality){
		return function store(declaration){
			if (declaration){
				return function(...keys){
					return effectuality(function implication(effect){
						return function cause(...x){
							const determinations = determination(keys);
							const value = x[determinations];
							const previous = find(x, determinations + 1);
							const next = write(value, previous, keys, x);
							return effect(next, ...x);
						};
					});
				};
			}
			return function(...keys){
				return effectuality(function implication(effect){
					return function cause(...x){
						const determinations = determination(keys);
						const previous = find(x, determinations);
						const value = read(previous, keys, x);
						return effect(value, ...x);
					};
				});
			};
		};
	};
})();

// tag: [String, String, ...] -> [String, String, ...] -> Effectuality(((t1, t2, ..., u1, u2, ...) -> ()) -> ((s1, s2, ..., u1, u2, ..., Tag (s1, s2, ..), v1, v2, ...) -> ())) -> Effectuality(((Tag (t1, t2, ..., s1, s2, ...), u1, u2, ..., Tag (s1, s2, ...), v1, v2, ...) -> ()) -> ((u1, u2, ..., Tag (s1, s2, ...), v1, v2, ...)  -> ()))
const effectualityTag = (function(){
	const symbol = Symbol("tags");
	const tags = Object.create(null, {
		[symbol]: {
			value: true, 
		}
	});
	function find(x){
		const found = x.reduce(function(accumulator, item, index){
			return accumulator || (typeof item === "object" && item !== null && item[symbol]? item: undefined);
		}, undefined);
		return found || tags;
	}
	function read(object, keys){
		return keys.map(function(key){
			return object[key];
		});
	}
	function write(object, keys, x){
		if (keys.length === 0){
			return object;
		}
		const differences = keys.filter(function(key, index){
			return x[index] !== object[key];
		});
		if (differences.length === 0){
			return object;
		}			
		const propertiesArray = differences.map(function(key, index){
			return {
				[key]: {
					value: x[index],
					enumerable: true,
				}
			};
		});
		const propertiesObject = Object.assign(...propertiesArray); 
		return Object.create(object, propertiesObject);
	}
	return function(effectuality){
		return function tag(...effectKeys){
			return function(...causeKeys){
				return function(tagEffectuality){
					if (tagEffectuality === undefined){
						if (causeKeys.length === 0){
							// importation
							return effectuality(function implication(effect){
								return function cause(...x){
									if (effectKeys.length === 0){
										return effect(...x);
									}
									const previous = find(x);
									const next = write(previous, effectKeys, x);
									if (next === previous){
										return effect(...x);
									}
									return effect(next, ...x);
								};
							});
						}
						if (effectKeys.length === 0){
							// exportation
							return effectuality(function implication(effect){
								return function cause(...x){
									if (causeKeys.length === 0){
										return effect(...x);
									}
									const previous = find(x);
									const y = read(previous, causeKeys);
									return effect(...y, ...x);
								};
							});
						}
						// mapping
						return effectuality(function implication(effect){
							return function cause(...x){
								const previous = find(x);
								const y = read(previous, causeKeys);
								const next = write(previous, effectKeys, y);
								if (next === previous){
									return effect(...x);
								}
								return effect(next, ...x);
							};
						});
					}
					// adaptation
					const prolog = effectuality(function implication(effect){
						return function cause(...x){
							const previous = find(x);
							const y = read(previous, causeKeys);
							return effect(...y, ...x);
						};
					});
					const epilog = effectuality(function implication(effect){
						return function cause(...x){
							const previous = find(x);
							const next = write(previous, effectKeys, x);
							return effect(next, ...x);
						};
					});
					if (effectKeys.length === 0 && causeKeys.length === 0){
						return tagEffectuality;
					}
					if (effectKeys.length === 0){
						return (tagEffectuality)(prolog);
					}
					if (causeKeys.length === 0){
						return (epilog)(tagEffectuality);
					}
					return (epilog)(tagEffectuality)(prolog);

				};
			};
		};
	};
})();

//todo immutable stack (linked list instead of spread arrays)
//todo optimize closures (static functions called with closure arguments)
//todo name effect values and cause values (second and third arguments of Effectuality) and check names in composition, concurrence, recurrence, injunction, concurrence, recurrence, conjunction, disjunction (semantic type system at declaration stage)

/* //todo alternatively the following TypeScript type checks effectuality composition compatibility:
type Effectuality<T extends unknown[], S extends unknown[]> = <R extends unknown[], Q extends unknown[]>(effectuality1: Effectuality<R, Q>) => R extends [...S, ...infer V]? Effectuality<[...T, ...V], Q>: R extends Partial<S>? S extends [...[any] extends R? [any]: [any, any] extends R? [any, any]: [any, any, any] extends R? [any, any, any]: [any, any, any, any] extends R? [any, any, any, any]: [any, any, any, any, any] extends R? [any, any, any, any, any]: [any, any, any, any, any, any] extends R? [any, any, any, any, any, any]: [any, any, any, any, any, any, any] extends R? [any, any, any, any, any, any, any]: [any, any, any, any, any, any, any, any] extends R? [any, any, any, any, any, any, any, any]: [any, any, any, any, any, any, any, any, any] extends R? [any, any, any, any, any, any, any, any, any]: R, ...infer U]? Effectuality<T, [...Q, ...U]>: never: never; //todo support [any, ...] tuple up to length 100 (instead of 9)
declare const effectuality1: Effectuality<[number], []>;
declare const effectuality2: Effectuality<[number], []>;
declare const effectuality3: Effectuality<[string, number, number], [number|boolean, number]>;
declare const duplication: <T extends unknown[], S extends unknown[], X>(arg: Effectuality<[X, ...T], S>) => Effectuality<[X, X, ...T], S>;
const effectuality21 = (effectuality2)(effectuality1); // TypeScript type is: Effectuality<[number, number], []>
const effectuality32 = (effectuality3)(effectuality2); // TypeScript type is: Effectuality<[string, number, number], [number]>
const effectuality31 = (effectuality3)(effectuality1); // TypeScript type is: Effectuality<[string, number, number], [number]>
const effectuality23 = (effectuality2)(effectuality3); // TypeScript type is: Effectuality<[number, string, number, number], [number | boolean, number]>
const effectuality13 = (effectuality1)(effectuality3); // TypeScript type is: Effectuality<[number, string, number, number], [number | boolean, number]>
const effectuality33 = (effectuality3)(effectuality3); // TypeScript type is: never
const effectuality331 = (effectuality3)(effectuality3)(effectuality1); // TypeScript error
const effectuality321 = (effectuality3)(effectuality2)(effectuality1); // TypeScript type is: Effectuality<[string, number, number], []>
const effectuality3212 = (effectuality3)(effectuality2)(effectuality1)(effectuality2); // TypeScript type is: Effectuality<[string, number, number, number], []>
const effectuality3duplication1 = (effectuality3)(duplication(effectuality1)); // TypeScript type is: Effectuality<[string, number, number], []>
const effectuality3duplication3 = (effectuality3)(duplication(effectuality3)); // TypeScript type is: never
*/

/* //todo the following Haskell programm is a Proof Of Concept for Effectuality:
-- online test at https://replit.com/languages/haskell
import System.IO.Unsafe (unsafePerformIO)
import Control.Concurrent (threadDelay)
-- Stack
data S a b = S a b | Bottom deriving Show
-- Effectuality
data Effectuality t s = Effectuality ((t -> ()) -> (s -> ()))
implication :: Effectuality t s -> ((t -> ()) -> (s -> ()))
implication (Effectuality i) = i  
-- Efectuality composition infix operator: <<
(<<) :: Effectuality t s -> Effectuality s r -> Effectuality t r
effectuality1 << effectuality2 = Effectuality (\effect -> (implication effectuality2) ((implication effectuality1) effect))
-- sample Effectuality with side-effect
output :: (Show a) => String -> Effectuality (S a b) (S a b)
output x = Effectuality (\effect -> (\(S y z) -> unsafePerformIO (putStrLn (x ++  show y) >> return (effect (S y z)))))
-- sample Effectuality with side-effect
input :: String -> Effectuality (S String b) b
input x = Effectuality (\effect -> (\y -> unsafePerformIO (do
        putStrLn x
        z <- getLine
        return (effect (S z y))
    )))
-- sample Effectuality with side-effect
delay :: Int -> Effectuality a a
delay x = Effectuality (\effect -> (\y -> unsafePerformIO (Control.Concurrent.threadDelay x >> return (effect y))))
-- sample Effectuality with no side-effect
initialization :: a -> Effectuality (S a b) b
initialization x = Effectuality (\effect -> (\y -> effect (S x y)))
-- sample Effectuality with no side-effect
decimal :: Effectuality (S Integer (S String a)) (S String a)
decimal = Effectuality (\effect -> (\(S x y) -> effect (S (read x) (S x y))))
-- sample Effectuality with no side-effect
square :: Effectuality (S Integer (S Integer a)) (S Integer a)
square = Effectuality (\effect -> (\(S x y) -> effect (S (x * x) (S x y))))
-- sample Effectuality with no side-effect
add :: Effectuality (S Integer (S Integer (S Integer a))) (S Integer (S Integer a))
add = Effectuality (\effect -> (\(S x (S y z)) -> effect (S (x + y) (S x (S y z)))))
-- sample Effectuality composition
effectuality0 = output "add: " << add << initialization 10 << delay 3000000 << output "square: " << square << output "decimal: " << decimal << input "type 3..."
-- sample Effectuality execution
implication0 = implication effectuality0
effect :: a -> ()
effect x = ()
cause = implication0(effect)
-- stdout:
--- type 3...
-- stdin:
--- 3
-- stdout:
--- decimal: 3
--- square: 9
-- wait:
--- 3 seconds
-- stdout:
--- add: 19
--- ()
main = putStrLn (show (cause Bottom))
*/

</script>

<script> "use strict"

/////////////////
// run tests

// tests
function runTest(declaration){
	if (location.hash === "#self-tests"){
		// input: Effectuality -> Identifier -> Effectuality (((String, ...) -> ()) -> ((...) -> ()))
		function input(effectuality){
			return function input(identifier){
				return effectuality(function implication(effect){
					// effect: (String, ...) -> ()
					// cause: (...) -> ()
					return function cause(...x){
						const element = document.getElementById(identifier);
						const value = element? element.value: "";
						effect(value, ...x);
					};
				});
			};
		}
		// output: Effectuality -> Identifier -> Effectuality (((String, ...) -> ()) -> ((String, ...) -> ()))
		function output(effectuality){
			return function output(identifier){
				return effectuality(function implication(effect){
					// effect: (String, ...) -> ()
					// cause: (String, ...) -> ()
					return function cause(value, ...x){
						const element = document.getElementById(identifier);
						if (element){
							element.value = value;
						}
						effect(value, ...x);
					};
				});
			};
		}
		return compilation(declaration, input, output);
	}
	return function(){
	};
}

// check: Effectuality, Log, String, [s1, s2, ...], [[t1, t2, ...]], Effectuality ((t1, t2, ...) -> (s1, s2, ...)) -> Effectuality ((t1, t2, ...) -> (s1, s2, ...))
function check(effectuality, log, title, values, outcomes, effectuality1){
	function among(outcome, outcomes){
		return outcomes.reduce(function(accumulator, item){
			return accumulator || JSON.stringify(outcome) === JSON.stringify(item);
		}, false);
	}
	return (log(1)(function(...outcome){
		if (among(outcome, outcomes)){
			return title + ": " + JSON.stringify(outcome);
		}
	}))(log(2)(function(...outcome){
		if (!among(outcome, outcomes)){
			if (outcomes.length === 0){
				return title + ": error: should not occur: got " + JSON.stringify(outcome);
			}
			return title + ": error: expected " + outcomes.map(item => JSON.stringify(item)).join(" or ") + ": got " + JSON.stringify(outcome);
		}
	}))(effectuality1)(effectualityInitialization(effectuality)(...values));
}

// run initialization test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const initialization = effectualityInitialization(effectuality)(7, 6);
	return check(effectuality, log, "initialization test", [], [[7, 6, []]], (initialization));
})();

// run zero test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	return check(effectuality, log, "zero test", [], [], (zero));
})();

// run unit test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	return check(effectuality, log, "unit test", [3, 4, 5, 6], [[3, 4, 5, 6, []]], (unit));
})();

// run lift combinator test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	return check(effectuality, log, "lift combinator test", [6, 7], [[13, 6, 7, []]], (addition));
})();

// run copy combinator test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const copy = effectualityCopy(effectuality);
	return check(effectuality, log, "copy combinator test", [5, 6, 7, 8], [[6, 8, 5, 8, 5, 6, 7, 8, []]], (copy(1,3,0,3)));
})();

// run indexation combinator test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const indexation = effectualityIndexation(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const indexations = indexation(initialization(123), initialization(456), initialization(789));
	return check(effectuality, log, "indexation combinator test", [], [[123,0,456,1,789,2,[]]], (indexations[0])(indexations[1])(indexations[2]));
})();

// run conjunction left identity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	return check(effectuality, log, "conjunction left identity", [6], [[96, 60, 36, 6, []]], (addition)(conjunction((zero),(times10),(square))));
})();

// run conjunction right identity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	return check(effectuality, log, "conjunction right identity", [6], [[96, 60, 36, 6, []]], (addition)(conjunction((times10),(square),(zero))));
})();

// run conjunction middle identity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	return check(effectuality, log, "conjunction middle identity", [6], [[96, 60, 36, 6, []]], (addition)(conjunction((times10),(zero),(square))));
})();

// run composition left identity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const multiplication = lift(function(x1, x2){
		return x1 * x2;
	});
	return check(effectuality, log, "composition left identity", [6, 7], [[48, 42, 6, 7, []]], (unit)(addition)(multiplication));
})();

// run composition middle identity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const multiplication = lift(function(x1, x2){
		return x1 * x2;
	});
	return check(effectuality, log, "composition left identity", [6, 7], [[48, 42, 6, 7, []]], (addition)(unit)(multiplication));
})();

// run composition right identity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const multiplication = lift(function(x1, x2){
		return x1 * x2;
	});
	return check(effectuality, log, "composition right identity", [6, 7], [[48, 42, 6, 7, []]], (addition)(multiplication)(unit));
})();

// run composition left annihilation test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const multiplication = lift(function(x1, x2){
		return x1 * x2;
	});
	return check(effectuality, log, "composition left annihilation", [6, 7], [], (zero)(addition)(multiplication));
})();

// run composition right annihilation test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const multiplication = lift(function(x1, x2){
		return x1 * x2;
	});
	return check(effectuality, log, "composition right annihilation", [6, 7], [], (addition)(multiplication)(zero));
})();

// run composition middle annihilation test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const multiplication = lift(function(x1, x2){
		return x1 * x2;
	});
	return check(effectuality, log, "composition left annihilation", [6, 7], [], (addition)(zero)(multiplication));
})();

// run conjunction left annihilation test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const negation = lift(function(x){
		return -x;
	});
	const multiplication = lift(function(x1, x2){
		return x1 * x2;
	});
	return check(effectuality, log, "conjunction left annihilation", [6, 7], [[-48, 48, 42, 6, 7, []]], (negation)(conjunction(zero,addition))(multiplication));
})();

// run conjunction right annihilation test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const negation = lift(function(x){
		return -x;
	});
	const multiplication = lift(function(x1, x2){
		return x1 * x2;
	});
	return check(effectuality, log, "conjunction right annihilation", [6, 7], [[-48, 48, 42, 6, 7, []]], (negation)(conjunction(addition,zero))(multiplication));
})();

// run conjunction zero test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	return check(effectuality, log, "conjunction zero", [6, 7], [], (addition)(conjunction(zero)));
})();

// run conjunction zero zero test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	return check(effectuality, log, "conjunction zero zero", [6, 7], [], (addition)(conjunction(zero, zero)));
})();

// run conjunction undefined test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const zero = effectualityZero(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	return check(effectuality, log, "conjunction undefined", [6, 7], [], (addition)(conjunction()));
})();

// run composition associativity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	const tenth = lift(function(x1){
		return x1 / 10;
	});
	return check(effectuality, log, "composition associativity", [60], [[360, 36, 6, 60, []]], (times10)(square)(tenth));
})();

// run composition left associativity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	const tenth = lift(function(x1){
		return x1 / 10;
	});
	return check(effectuality, log, "composition left associativity", [60], [[360, 36, 6, 60, []]], ((times10)(square))(tenth));
})();

// run composition right associativity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	const tenth = lift(function(x1){
		return x1 / 10;
	});
	return check(effectuality, log, "composition right associativity", [60], [[360, 36, 6, 60, []]], (times10)((square)(tenth)));
})();

// run conjunction associativity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	const lift = effectualityLift(effectuality);
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	const tenth = lift(function(x1){
		return x1 / 10;
	});
	return check(effectuality, log, "conjunction associativity", [6], [[60, 36, 0.6, 6, []]], conjunction(times10,square,tenth));
})();

// run conjunction left associativity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	const lift = effectualityLift(effectuality);
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	const tenth = lift(function(x1){
		return x1 / 10;
	});
	return check(effectuality, log, "conjunction left associativity", [6], [[60, 36, 0.6, 6, []]], conjunction(conjunction(times10,square),tenth));
})();

// run conjunction right associativity test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	const lift = effectualityLift(effectuality);
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	const tenth = lift(function(x1){
		return x1 / 10;
	});
	return check(effectuality, log, "conjunction right associativity", [6], [[60, 36, 0.6, 6, []]], conjunction(times10,conjunction(square,tenth)));
})();

// run conjunction of compositions test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	const lift = effectualityLift(effectuality);
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	const tenth = lift(function(x1){
		return x1 / 10;
	});
	const increment3 = lift(function(x1){
		return x1 + 3;
	});
	return check(effectuality, log, "conjunction of composition", [6], [[360, 36, 0.9, 9, 6, []]], (conjunction((times10)(square),(tenth)(increment3))));
})();

// run composition of conjunctions test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	const lift = effectualityLift(effectuality);
	const times10 = lift(function(x1){
		return x1 * 10;
	});
	const square = lift(function(x1){
		return x1 * x1;
	});
	const tenth = lift(function(x1){
		return x1 / 10;
	});
	const increment3 = lift(function(x1){
		return x1 + 3;
	});
	return check(effectuality, log, "composition of conjunctions", [6], [[360, 3.6, 36, 9, 6, []]], (conjunction(times10,tenth))(conjunction(square,increment3)));
})();

// run addition all test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const all = effectualityConcurrenceAll(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const times10 = lift(function(x){
		return x * 10;
	})(log(1)(function(x){
		return "addition all test: times10: " + x;
	}))(delay(400));
	const square = lift(function(x){
		return x * x;
	})(log(1)(function(x){
		return "addition any test: square: " + x;
	}))(delay(300));
	return check(effectuality, log, "addition all test", [6], [[96,60,36,6,[]]], (addition)(all(times10, square)));
})();

// run addition any test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const times10 = lift(function (x){
		return x * 10;
	})(log(1)(function(x){
		return "addition any test: times10: " + x;
	}))(delay(400));
	const square = lift(function (x){
		return x * x;
	})(log(1)(function(x){
		return "addition any test: square: " + x;
	}))(delay(300));
	return check(effectuality, log, "addition any test", [6], [[42, 36, 6, []]], (addition)(any(times10, square)));
})();

// run addition disjunction test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	})(log(1)(function(...x){
		return "addition disjunction test: addition: " + x;
	}))(log(2)(function(x1, x2){
		if (x1 !== 6 || x2 !== 7){
			return "addition disjunction test: addition: expectd 6,7: got: " + [x1, x2];
		}
	}));
	const times10 = lift(function times10(x){
		return x * 10;
	})(log(1)(function(...x){
		return "addition disjunction test: times10: " + x;
	}))(log(2)(function(x){
		if (x !== 6){
			return "addition disjunction test: times10: expectd 6: got: " + x;
		}
	}))(delay(400));
	const square = lift(function square(x){
		return x * x;
	})(log(1)(function(...x){
		return "addition disjunction test: square: " + x;
	}))(log(2)(function(x){
		if (x !== 6){
			return "addition disjunction test: square: expectd 6: got: " + x;
		}
	}))(delay(300));
	return check(effectuality, log, "addition disjunction test", [6, 7, 0], [[13, 6, 7, 0, []]], (addition)(disjunction(times10,square)));
})();

// run either first test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const either = effectualityConcurrenceEither(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	const even = lift(function(x){
		return x % 2 === 0;
	})(log(1)(function(x){
		return "either first test: even: " + x;
	}))(delay(200));
	const odd = lift(function(x){
		return x % 2 !== 0;
	})(log(1)(function(x){
		return "either first test: odd: " + x;
	}))(delay(100));
	const times10 = lift(function(x){
		return x * 10;
	})(log(1)(function(x){
		return "either first test: times10: " + x;
	}))(delay(400));
	const square = lift(function(x){
		return x * x;
	})(log(2)(function(x){
		return "either first test: square: should not occur: got " + x;
	}))(delay(300));
	return check(effectuality, log, "either first test", [7, 123], [[70, 7, 123, []]], (either)(odd, even)(times10, square));
})();

// run either second test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const either = effectualityConcurrenceEither(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	const even = lift(function(x){
		return x % 2 === 0;
	})(log(1)(function(x){
		return "either second test: even: " + x;
	}))(delay(200));
	const odd = lift(function(x){
		return x % 2 !== 0;
	})(log(1)(function(x){
		return "either second test: odd: " + x;
	}))(delay(100));
	const times10 = lift(function(x){
		return x * 10;
	})(log(2)(function(x){
		return "either second test: times10: should not occur: got " + x;
	}))(delay(400));
	const square = lift(function(x){
		return x * x;
	})(log(1)(function(x){
		return "either second test: square: " + x;
	}))(delay(300));
	return check(effectuality, log, "either second test", [6, 123], [[36, 6, 123, []]], (either)(odd, even)(times10, square));
})();

// run either third test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const either = effectualityConcurrenceEither(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	const even = lift(function(x){
		return x % 2 === 0;
	})(log(1)(function(x){
		return "either third test: even: " + x;
	}))(delay(200));
	const odd = lift(function(x){
		return x % 2 === 1;
	})(log(1)(function(x){
		return "either third test: odd: " + x;
	}))(delay(100));
	const times10 = lift(function(x){
		return x * 10;
	})(log(2)(function(x){
		return "either third test: times10: should not occur: got " + x;
	}))(delay(400));
	const square = lift(function(x){
		return x * x;
	})(log(2)(function(x){
		return "either third test: square: should not occur: got " + x;
	}))(delay(300));
	return check(effectuality, log, "either third test", [Infinity, 123], [[Infinity, 123, []]], (either)(odd, even)(times10, square));
})();

// run fallback-either first test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const either = effectualityConcurrenceEither(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	const odd = lift(function(x){
		return x % 2 !== 0;
	})(log(1)(function(x){
		return "fallback-either first test: odd: " + x;
	}))(delay(100));
	const times10 = lift(function(x){
		return x * 10;
	})(log(1)(function(x){
		return "fallback-either first test: times10: " + x;
	}))(delay(400));
	const square = lift(function(x){
		return x * x;
	})(log(2)(function(x){
		return "fallback-either first test: square: should not occur: got: " + x;
	}))(delay(300));
	return check(effectuality, log, "fallback-either first test", [7, 123], [[70, 7, 123, []]], (either)(odd)(times10, square));
})();

// run fallback-either second test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const either = effectualityConcurrenceEither(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	const odd = lift(function(x){
		return x % 2 !== 0;
	})(log(1)(function(x){
		return "fallback-either second test: odd: " + x;
	}))(delay(100));
	const times10 = lift(function(x){
		return x * 10;
	})(log(2)(function(x){
		return "fallback-either second test: times10: should not occur: got " + x;
	}))(delay(400));
	const square = lift(function(x){
		return x * x;
	})(log(1)(function(x){
		return "fallback-either second test: square: " + x;
	}))(delay(300));
	return check(effectuality, log, "fallback-either second test", [6, 123], [[36, 6, 123, []]], (either)(odd)(times10, square));
})();

// run ternary-either first test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const either = effectualityConcurrenceEither(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	function multiple(n, m){
		return lift(function(x){
			return x % n === m;
		})(log(1)(function(x){
			return "ternary-either first test: " + n + " "+ m + " multiple: " + x;
		}))(delay(100 * m));
	}
	const times10 = lift(function(x){
		return x * 10;
	})(log(1)(function(x){
		return "ternary-either first test: times10: " + x;
	}))(delay(600));
	const square = lift(function(x){
		return x * x;
	})(log(2)(function(x){
		return "ternary-either first test: square: should not occur: got " + x;
	}))(delay(500));
	const tenth = lift(function(x){
		return x / 10;
	})(log(2)(function(x){
		return "ternary-either first test: tenth: should not occur: got " + x;
	}))(delay(400));
	return check(effectuality, log, "ternary-either first test", [6], [[60, 6, []]], (either)(multiple(3, 0), multiple(3, 1), multiple(3, 2))(times10, square, tenth));
})();

// run ternary-either second test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const either = effectualityConcurrenceEither(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	function multiple(n, m){
		return lift(function(x){
			return x % n === m;
		})(log(1)(function(x){
			return "ternary-either second test: " + n + " "+ m + " multiple: " + x;
		}))(delay(100 * m));
	}
	const times10 = lift(function(x){
		return x * 10;
	})(log(2)(function(x){
		return "ternary-either second test: times10: should not occur: got " + x;
	}))(delay(600));
	const square = lift(function(x){
		return x * x;
	})(log(1)(function(x){
		return "ternary-either second test: square: " + x;
	}))(delay(500));
	const tenth = lift(function(x){
		return x / 10;
	})(log(2)(function(x){
		return "ternary-either second test: tenth: should not occur: got " + x;
	}))(delay(400));
	return check(effectuality, log, "ternary-either second test", [7], [[49, 7, []]], (either)(multiple(3, 0), multiple(3, 1), multiple(3, 2))(times10, square, tenth));
})();

// run ternary-either third test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const either = effectualityConcurrenceEither(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	function multiple(n, m){
		return lift(function(x){
			return x % n === m;
		})(log(1)(function(x){
			return "ternary-either third test: " + n + " "+ m + " multiple: " + x;
		}))(delay(100 * m));
	}
	const times10 = lift(function(x){
		return x * 10;
	})(log(2)(function(x){
		return "ternary-either third test: times10: should not occur: got " + x;
	}))(delay(600));
	const square = lift(function(x){
		return x * x;
	})(log(2)(function(x){
		return "ternary-either third test: square: should not occur: got " + x;
	}))(delay(500));
	const tenth = lift(function(x){
		return x / 10;
	})(log(1)(function(x){
		return "ternary-either third test: tenth: " + x;
	}))(delay(400));
	return check(effectuality, log, "ternary-either third test", [8], [[0.8, 8, []]], (either)(multiple(3, 0), multiple(3, 1), multiple(3, 2))(times10, square, tenth));
})();

// run ternary-addition all test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const all = effectualityConcurrenceAll(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2, x3){
		return x1 + x2 + x3;
	});
	const times10 = lift(function(x){
		return x * 10;
	})(log(1)(function(x){
		return "ternary-addition all test: times10: " + x;
	}))(delay(700));
	const square = lift(function(x){
		return x * x;
	})(log(1)(function(x){
		return "ternary-addition all test: square: " + x;
	}))(delay(600));
	const tenth = lift(function(x){
		return x / 10;
	})(log(1)(function(x){
		return "ternary-addition all test: tenth: " + x;
	}))(delay(500));
	return check(effectuality, log, "ternary-addition all test", [6], [[96.6, 60, 36, 0.6, 6, []]], (addition)(all(times10, square, tenth)));
})();

// run ternary-addition any test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const lift = effectualityLift(effectuality);
	const addition = lift(function(x1, x2){
		return x1 + x2;
	});
	const times10 = lift(function(x){
		return x * 10;
	})(log(1)(function(x){
		return "ternary-addition any test: times10: " + x;
	}))(delay(900));
	const square = lift(function(x){
		return x * x;
	})(log(1)(function(x){
		return "ternary-addition any test: square: " + x;
	}))(delay(800));
	const tenth = lift(function(x){
		return x / 10;
	})(log(1)(function(x){
		return "ternary-addition any test: tenth: " + x;
	}))(delay(900));
	return check(effectuality, log, "ternary-addition any test", [6], [[42, 36, 6, []]], (addition)(any(times10, square, tenth)));
})();

// run output ternary-addition all input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const all = effectualityConcurrenceAll(effectuality, concurrence);
	const addition = lift(function(x1, x2, x3){
		return x1 + x2 + x3;
	});
	const times10 = lift(function(x){
		return x * 10;
	})(log(1)(function(x){
		return "output ternary-addition all input test: times10: " + x;
	}))(delay(700));
	const square = lift(function(x){
		return x * x;
	})(log(1)(function(x){
		return "output ternary-addition all input test: square: " + x;
	}))(delay(600));
	const tenth = lift(function(x){
		return x / 10;
	})(log(1)(function(x){
		return "output ternary-addition all input test: tenth: " + x;
	}))(delay(500));
	return check(effectuality, log, "output ternary-addition all input test output", [], [["96.6", 96.6, 60, 36, 0.6, "6", []]], (input("output07"))(output("output07"))(addition)(all(times10, square, tenth))(input("input07")));
})();

// run output ternary-addition any input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const addition = lift(function(x1, x2){
		return x1 * 1 + x2 * 1;
	});
	const times10 = lift(function(x){
		return x * 10;
	})(log(1)(function(x){
		return "output ternary-addition any input test: times10: " + x;
	}))(delay(700));
	const square = lift(function(x){
		return x * x;
	})(log(1)(function(x){
		return "output ternary-addition any input test: square: " + x;
	}))(delay(600));
	const tenth = lift(function(x){
		return x / 10;
	})(log(1)(function(x){
		return "output ternary-addition any input test: tenth: " + x;
	}))(delay(700));
	return check(effectuality, log, "output ternary-addition any input test output", [], [["42", 42, 36, "6", []]], (input("output08"))(output("output08"))(addition)(any(times10, square, tenth))(input("input08")));
})();

// run output ternary-addition first variable-delay input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const addition3 = lift(function addition3(x1, x2, x3){
		return x1 + x2 + x3;
	})(log(1)(function(...x){
		return "output ternary-addition first variable-delay input: addition3: " + x;
	}));
	const times10 = (fit(0)(0)(lift(function(x){
		return x * 10;
	})))(log(1)(function(...x){
		return "output ternary-addition first variable-delay input: times10: " + x;
	}))(fit()(1)(delay(true)));
	const square = (fit(0)(0)(lift(function(x){
		return x * x;
	})))(log(1)(function(...x){
		return "output ternary-addition first variable-delay input: square: " + x;
	}))(fit()(2)(delay(true)));
	const tenth = (fit(0)(0)(lift(function(x){
		return x / 10;
	})))(log(1)(function(...x){
		return "output ternary-addition first variable-delay input: tenth: " + x;
	}))(fit()(3)(delay(true)));
	return check(effectuality, log, "output ternary-addition first variable-delay input", [1000, 2000, 2000, 7, 8], [["75",75,60,"6",1000,2000,2000,7,8,[]]], (input("output14"))(output("output14"))(fit(0)(0,5,6)(addition3))(any((times10),(square),(tenth)))(input("input14")));
})();

// run output ternary-addition second variable-delay input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const addition3 = lift(function addition3(x1, x2, x3){
		return x1 + x2 + x3;
	})(log(1)(function(...x){
		return "output ternary-addition second variable-delay input: addition3: " + x;
	}));
	const times10 = (fit(0)(0)(lift(function(x){
		return x * 10;
	})))(log(1)(function(...x){
		return "output ternary-addition second variable-delay input: times10: " + x;
	}))(fit()(1)(delay(true)));
	const square = (fit(0)(0)(lift(function(x){
		return x * x;
	})))(log(1)(function(...x){
		return "output ternary-addition second variable-delay input: square: " + x;
	}))(fit()(2)(delay(true)));
	const tenth = (fit(0)(0)(lift(function(x){
		return x / 10;
	})))(log(1)(function(...x){
		return "output ternary-addition second variable-delay input: tenth: " + x;
	}))(fit()(3)(delay(true)));
	return check(effectuality, log, "output ternary-addition second variable-delay input", [2000, 1000, 2000, 7, 8], [["51",51,36,"6",2000,1000,2000,7,8,[]]], (input("output15"))(output("output15"))(fit(0)(0,5,6)(addition3))(any((times10),(square),(tenth)))(input("input15")));
})();

// run output ternary-addition third variable-delay input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const addition3 = lift(function addition3(x1, x2, x3){
		return x1 + x2 + x3;
	})(log(1)(function(...x){
		return "output ternary-addition third variable-delay input: addition3: " + x;
	}));
	const times10 = (fit(0)(0)(lift(function(x){
		return x * 10;
	})))(log(1)(function(...x){
		return "output ternary-addition third variable-delay input: times10: " + x;
	}))(fit()(1)(delay(true)));
	const square = (fit(0)(0)(lift(function(x){
		return x * x;
	})))(log(1)(function(...x){
		return "output ternary-addition third variable-delay input: square: " + x;
	}))(fit()(2)(delay(true)));
	const tenth = (fit(0)(0)(lift(function(x){
		return x / 10;
	})))(log(1)(function(...x){
		return "output ternary-addition third variable-delay input: tenth: " + x;
	}))(fit()(3)(delay(true)));
	return check(effectuality, log, "output ternary-addition third variable-delay input", [2000, 2000, 1000, 7, 8], [["15.6",15.6,0.6,"6",2000,2000,1000,7,8,[]]], (input("output16"))(output("output16"))(fit(0)(0,5,6)(addition3))(any((times10),(square),(tenth)))(input("input16")));
})();

// run output ternary-addition canceled-any fixed-delay input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const copy = effectualityCopy(effectuality);
	const cancellation = (fit()(1)((delay()(false))))(log(1)(function(...x){
		return "output ternary-addition canceled-any fixed-delay input: cancellation: " + x;
	}));
	const addition3 = lift(function addition3(x1, x2, x3){
		return x1 + x2 + x3;
	})(log(1)(function(...x){
		return "output ternary-addition canceled-any fixed-delay input: addition3: " + x;
	}));
	const times10 = (fit(0)(1)(lift(function(x){
		return x * 10;
	})))(log(2)(function(...x){
		return "output ternary-addition canceled-any fixed-delay input: error: times10 should not occur: got: " + x;
	}))(delay(2000, true));
	const square = (fit(0)(1)(lift(function(x){
		return x * x;
	})))(log(1)(function(...x){
		return "output ternary-addition canceled-any fixed-delay input: square: " + x;
	}))(delay(1000, true));
	const tenth = (fit(0)(1)(lift(function(x){
		return x / 10;
	})))(log(2)(function(...x){
		return "output ternary-addition canceled-any fixed-delay input: error: tenth should not occur: got: " + x;
	}))(delay(2000, true));
	return check(effectuality, log, "output ternary-addition canceled-any fixed-delay input", [7, 8], [["51",51,36,0,"6",7,8,[]]], (input("output17"))(output("output17"))(fit(0)(3,4)(addition3))(cancellation)(fit(0)()((any((times10),(square),(tenth)))))(delay()(true))(input("input17")));
})();

// run output ternary-addition canceled-any first variable-delay input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const cancellation = (fit()(1)((delay()(false))))(log(1)(function(...x){
		return "output ternary-addition canceled-any first variable-delay input test: cancellation: " + x;
	}));
	const addition3 = lift(function addition3(x1, x2, x3){
		return x1 + x2 + x3;
	})(log(1)(function(...x){
		return "output ternary-addition canceled-any first variable-delay input test: addition3: " + x;
	}));
	const times10 = (fit(0)(1)(lift(function(x){
		return x * 10;
	})))(log(1)(function(...x){
		return "output ternary-addition canceled-any first variable-delay input test: times10: " + x;
	}))(fit()(2)(delay(true, true)));
	const square = (fit(0)(1)(lift(function(x){
		return x * x;
	})))(log(2)(function(...x){
		return "output ternary-addition canceled-any first variable-delay input test: error: square should not occur: got: " + x;
	}))(fit()(3)(delay(true, true)));
	const tenth = (fit(0)(1)(lift(function(x){
		return x / 10;
	})))(log(2)(function(...x){
		return "output ternary-addition canceled-any first variable-delay input test: error: tenth should not occur: got: " + x;
	}))(fit()(4)(delay(true, true)));
	return check(effectuality, log, "output ternary-addition canceled-any first variable-delay input test output", [1000, 2000, 2000, 7, 8], [["75",75,60,0,"6",1000,2000,2000,7,8,[]]], (input("output18"))(output("output18"))(fit(0)(6,7)(addition3))(cancellation)(fit(0)()((any((times10),(square),(tenth)))))(delay()(true))(input("input18")));
})();

// run output ternary-addition canceled-any second variable-delay input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const cancellation = (fit()(1)((delay()(false))))(log(1)(function(...x){
		return "output ternary-addition canceled-any second variable-delay input test: cancellation: " + x;
	}));
	const addition3 = lift(function addition3(x1, x2, x3){
		return x1 + x2 + x3;
	})(log(1)(function(...x){
		return "output ternary-addition canceled-any second variable-delay input test: addition3: " + x;
	}));
	const times10 = (fit(0)(1)(lift(function(x){
		return x * 10;
	})))(log(2)(function(...x){
		return "output ternary-addition canceled-any second variable-delay input test: error: times10 should not occur: got: " + x;
	}))(fit()(2)(delay(true, true)));
	const square = (fit(0)(1)(lift(function(x){
		return x * x;
	})))(log(1)(function(...x){
		return "output ternary-addition canceled-any second variable-delay input test: square: " + x;
	}))(fit()(3)(delay(true, true)));
	const tenth = (fit(0)(1)(lift(function(x){
		return x / 10;
	})))(log(2)(function(...x){
		return "output ternary-addition canceled-any second variable-delay input test: error: tenth should not occur: got: " + x;
	}))(fit()(4)(delay(true, true)));
	return check(effectuality, log, "output ternary-addition canceled-any second variable-delay input test output", [2000, 1000, 2000, 7, 8], [["51",51,36,0,"6",2000,1000,2000,7,8,[]]], (input("output19"))(output("output19"))(fit(0)(6,7)(addition3))(cancellation)(fit(0)()((any((times10),(square),(tenth)))))(delay()(true))(input("input19")));
})();

// run output ternary-addition canceled-any third variable-delay input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const cancellation = (fit()(1)((delay()(false))))(log(1)(function(...x){
		return "output ternary-addition canceled-any third variable-delay input test: cancellation: " + x;
	}));
	const addition3 = lift(function addition3(x1, x2, x3){
		return x1 + x2 + x3;
	})(log(1)(function(...x){
		return "output ternary-addition canceled-any third variable-delay input test: addition3: " + x;
	}));
	const times10 = (fit(0)(1)(lift(function(x){
		return x * 10;
	})))(log(2)(function(...x){
		return "output ternary-addition canceled-any third variable-delay input test: error: times10 should not occur: got " + x;
	}))(fit()(2)(delay(true, true)));
	const square = (fit(0)(1)(lift(function(x){
		return x * x;
	})))(log(2)(function(...x){
		return "output ternary-addition canceled-any third variable-delay input test: error: square should not occur: got: " + x;
	}))(fit()(3)(delay(true, true)));
	const tenth = (fit(0)(1)(lift(function(x){
		return x / 10;
	})))(log(1)(function(...x){
		return "output ternary-addition canceled-any third variable-delay input test: tenth: " + x;
	}))(fit()(4)(delay(true, true)));
	return check(effectuality, log, "output ternary-addition canceled-any third variable-delay input test output", [2000, 2000, 1000, 7, 8], [["15.6",15.6,0.6,0,"6",2000,2000,1000,7,8,[]]], (input("output20"))(output("output20"))(fit(0)(6,7)(addition3))(cancellation)(fit(0)()((any((times10),(square),(tenth)))))(delay()(true))(input("input20")));
})();

// run fit test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const multiplication = lift(function (x1, x2){
		return x1 * x2;
	})(log(1)(function(...x){
		return "fit test: multiplication: " + x;
	}));
	const addition = lift(function(x1, x2){
		return x1 * 1 + x2 * 1;
	})(log(1)(function(...x){
		return "fit test: addition: " + x;
	}));
	return check(effectuality, log, "fit test", [5, 6, 7], [[77, 11, 5, 6, 7, []]], (fit(0)(0,3)(multiplication))(addition));
})();

// run array-fit test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const unit = effectualityUnit(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	return check(effectuality, log, "array-fit test", [5, 6, 7], [[[5,6],[5,7],6,7,5,6,7,[]]], (fit(0,1,2,3)([0,1],[0,2],1,2)(unit)));
})();

// run copy test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const copy = effectualityCopy(effectuality);
	const lift = effectualityLift(effectuality);
	const multiplication = lift(function (x1, x2){
		return x1 * x2;
	})(log(1)(function(...x){
		return "copy test: multiplication: " + x;
	}));
	const addition = lift(function(x1, x2){
		return x1 * 1 + x2 * 1;
	})(log(1)(function(...x){
		return "copy test: addition: " + x;
	}));
	return check(effectuality, log, "copy test", [5, 6, 7], [[77, 11, 5, 6, 7, []]], (multiplication)(copy(0,3)())(addition)(copy(0,1)()));
})();

// run array-copy test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const copy = effectualityCopy(effectuality);
	return check(effectuality, log, "array-copy test", [5, 6, 7], [[[5,6],[5,7],6,7,5,6,7,[]]], (copy([0,1],[0,2],1,2)));
})();

// run output injunction input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const initialization = effectualityInitialization(effectuality);
	const copy = effectualityCopy(effectuality)(0);
	const lift = effectualityLift(effectuality);
	const multiplication = lift(function (x1, x2){
		return x1 * x2;
	})(log(1)(function(...x){
		return "output injunction input test: multiplication: " + x;
	}));
	const addition = lift(function(x1, x2){
		return x1 * 1 + x2 * 1;
	})(log(1)(function(...x){
		return "output injunction input test: addition: " + x;
	}));
	const selection = lift(function(x0){
		return x0;
	})(log(1)(function(...x){
		return "output injunction input test: selection: " + x;
	}));
	return check(effectuality, log, "output injunction input test", [5, 7], [[150, 5, 7, []]], (injunction(selection)((multiplication)(initialization(2))(output("output09"))(copy)(addition)(initialization(3))(multiplication)(input("input09"))(addition))));
})();

// run injunction recurrence test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const initialization = effectualityInitialization(effectuality);
	const lift = effectualityLift(effectuality);
	const multiplication = lift(function (x1, x2){
		return x1 * x2;
	})(log(1)(function(...x){
		return "injunction recurrence test: multiplication: " + x;
	}));
	const addition = lift(function(x1, x2){
		return x1 * 1 + x2 * 1;
	})(log(1)(function(...x){
		return "injunction recurrence test: addition: " + x;
	}));
	const selection = lift(function(x0){
		return x0;
	})(log(1)(function(...x){
		return "injunction recurrence test: selection: " + x;
	}));
	const feedback = lift(function(x0){
		if (x0 === 150){
			return true;
		}
		return false;
	});
	return check(effectuality, log, "injunction recurrence test", [5, 7], [[1866, 150, 5, 7, []]], recurrence(feedback,(injunction(selection)((multiplication)(initialization(2))(addition)(initialization(3))(multiplication)(initialization(6))(addition)))));
})();

// run output conjunction recurrence input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const unit = effectualityUnit(effectuality);
	const twice1 = lift(function(x){
		return x * 2;
	});
	const twice2 = lift(function(x){
		return x * 2;
	});
	const feedback1 = lift(function(x0){
		if (x0 < 1000){
			return true;
		}
		return false;
	});
	const feedback2 = lift(function(x0){
		if (x0 < 500){
			return true;
		}
		return false;
	});
	const recurrence1 = recurrence((feedback1),(output("output31"))(twice1)(delay(500))(input("output31")))(output("output31"))(input("input31"));
	const recurrence2 = recurrence((feedback2),(output("output32"))(twice2)(delay(100))(input("output32")))(output("output32"))(input("input32"));
	const expected = [1024,"512",512,"256",256,"128",128,"64",64,"32",32,"16",16,"8",8,"4",4,"2",2,"1","1",512,"256",256,"128",128,"64",64,"32",32,"16",16,"8",8,"4",4,"2",2,"1","1",[]];
	return check(effectuality, log, "output conjunction recurrence input test", [], [expected], (conjunction((recurrence1),(recurrence2))));
})();

// run output composition recurrence input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const twice1 = lift(function(x){
		return x * 2;
	});
	const twice2 = lift(function(x){
		return x * 2;
	});
	const feedback1 = lift(function(x0){
		if (x0 < 1000){
			return true;
		}
		return false;
	});
	const feedback2 = lift(function(x0){
		if (x0 < 500){
			return true;
		}
		return false;
	});
	const recurrence1 = recurrence((feedback1),(output("output33"))(twice1)(delay(500))(input("output33")))(output("output33"))(input("input33"));
	const recurrence2 = recurrence((feedback2),(output("output34"))(twice2)(delay(100))(input("output34")))(output("output34"))(input("input34"));
	const expected = [1024,"512",512,"256",256,"128",128,"64",64,"32",32,"16",16,"8",8,"4",4,"2",2,"1","1",512,"256",256,"128",128,"64",64,"32",32,"16",16,"8",8,"4",4,"2",2,"1","1",[]];
	return check(effectuality, log, "output composition recurrence input test", [], [expected], (recurrence1)(recurrence2));
})();

// run output composition initialization-reduction-recurrence input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const initialization = effectualityInitialization(effectuality);
	const lift = effectualityLift(effectuality);
	const twice1 = lift(function(x){
		return x * 2;
	});
	const twice2 = lift(function(x){
		return x * 2;
	});
	const feedback1 = lift(function(x0){
		if (x0 < 1000){
			return [true, x0];
		}
		return [false, x0];
	}, true);
	const feedback2 = lift(function(x0){
		if (x0 < 500){
			return [true, x0];
		}
		return [false, x0];
	}, true);
	const recurrence1 = recurrence((feedback1),(output("output33"))(twice1)(delay(500))(input("output33")),(initialization("------")))(output("output33"))(input("input33"));
	const recurrence2 = recurrence((feedback2),(output("output34"))(twice2)(delay(100))(input("output34")),(initialization()))(output("output34"))(input("input34"));
	const expected = [1024,512,256,128,64,32,16,8,4,2,"------","1",512,256,128,64,32,16,8,4,2,"1",[]];
	return check(effectuality, log, "output composition initialization-reduction-recurrence input test", [], [expected], (recurrence1)(recurrence2));
})();

// run write-write-read-read-store test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const store = effectualityStore(effectuality)(true);
	const restore = effectualityStore(effectuality)(false);
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const multiplication = lift(function cause(x, y){
		return x * y;
	});
	const duplication = lift(function(store1, x1, x2){
		return x2;
	});
	const expected = [1764,7,252,6,42,7,6,123,456,789,{"operands":{"second":7}},7,{"operands":{"first":6}},6,7,[]];
	return check(effectuality, log, "write-write-read-read-store test", [6,7], [expected], (multiplication)(restore("operands","second"))(multiplication)(restore("operands","first"))(multiplication)(restore("operands","second"))(restore("operands","first"))(initialization(123,456,789))(store("operands","second"))(duplication)(store("operands","first")));
})();

// run write-write-read-read-write-write-read-read-store test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const store = effectualityStore(effectuality)(true);
	const restore = effectualityStore(effectuality)(false);
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const multiplication = lift(function cause(x, y){
		return x * y;
	});
	const duplication = lift(function(store1, x1, x2){
		return x2;
	});
	const expected = [84672,8,10584,6,1764,{"operands":{"second":8}},8,1764,{"operands":{"second":7}},6,1764,7,252,6,42,7,6,123,456,789,{"operands":{"second":7}},7,{"operands":{"first":6}},6,7,[]];
	return check(effectuality, log, "write-write-read-read-write-write-read-read-store test", [6,7], [expected],  (multiplication)(restore("operands","second"))(multiplication)(restore("operands","first"))(duplication)(store("operands","second"))(initialization(8))(duplication)(store("operands","first"))(initialization(6))(multiplication)(restore("operands","second"))(multiplication)(restore("operands","first"))(multiplication)(restore("operands","second"))(restore("operands","first"))(initialization(123,456,789))(store("operands","second"))(duplication)(store("operands","first")));
})();

// run write-write-read-read-write-write-read-read-variable-keys-store test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const store = effectualityStore(effectuality)(true);
	const restore = effectualityStore(effectuality)(false);
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const multiplication = lift(function cause(x, y){
		return x * y;
	});
	const duplication1 = lift(function(store1, x1, x2){
		return x2;
	});
	const duplication2 = lift(function(store1, key1, x1, x2){
		return x2;
	});
	const selection = lift(function(x1){
		return x1;
	});
	const expected = [84672,8,10584,6,1764,{"operands":{"second":8}},"second",8,1764,{"operands":{"second":7}},"operands",6,1764,7,252,6,42,7,6,123,456,789,{"operands":{"second":7}},"operands","second",7,{"operands":{"first":6}},6,7,[]];
	return check(effectuality, log, "write-write-read-read-write-write-read-read-variable-keys-store test", [6,7], [expected],  (multiplication)(restore("operands","second"))(multiplication)(restore("operands","first"))(duplication2)(store("operands",true))(initialization("second"))(initialization(8))(duplication2)(store(true,"first"))(initialization("operands"))(initialization(6))(multiplication)(injunction(selection)((restore("operands",true))(initialization("second"))))(multiplication)(injunction(selection)((restore(true,"first"))(initialization("operands"))))(multiplication)(injunction(selection)((restore(true,true))(initialization("operands","second")))) (restore("operands","first"))(initialization(123,456,789))(store(true,true))(initialization("operands","second"))(duplication1)(store("operands","first")));
})();

// run tag test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const tag = effectualityTag(effectuality);
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const multiplication = lift(function cause(x, y){
		return x * y;
	});
	const expected = [1764,{"result":1764},1764,252,7,{"operands.first":252},{"result":252},252,6,42,{"result":42},42,6,7,123,456,789,{"operands.first":6,"operands.second":7},6,7,[]];
	return check(effectuality, log, "tag test", [6,7], [expected], ((tag()("result")())(tag("result")("operands.first","operands.second")(multiplication))(tag("operands.first")("result")())(tag("result")("operands.first","result")(multiplication))(tag("result")("operands.first","operands.second")(multiplication))(initialization(123,456,789))(tag("operands.first","operands.second")()())));
})();

// run output constant-rate-signal input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const limitation = lift(function(time, id){
		if (time < 7500){
			return undefined;
		}
		return id;
	});
	const multiplication = lift(function cause(x, y){
		return x * y;
	});
	return check(effectuality, log, "output constant-rate-signal input test output", [], [[0, []]], (signal(1000,(output("output41"))(multiplication)(input("input41"))(fit()()((signal()(false))(limitation))))(signal()(true))));
})();

// run output variable-rate-signal input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const fit = effectualityInjunctionFit(effectuality, injunction);
	const limitation = lift(function(time, id){
		if (time < 7500){
			return undefined;
		}
		return id;
	});
	const multiplication = lift(function cause(x, y){
		return x * y;
	})(log(1)(function(x, y){
		return "output variable-rate-signal input: multiplication: " + x + " * " + y;
	}));
	return check(effectuality, log, "output variable-rate-signal input test output", [2000], [[0, 2000, []]], (fit()(1,0)(signal(true,(output("output42"))(multiplication)(input("input42"))(fit()()((signal()(false))(limitation)))))(signal()(true))));
})();

// run output push-pull-pull-push-stream input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const multiplication = effectualityLift(effectuality)(function(x1, x2){
		return x1 * x2;
	})(log(1)(function(...x){
		return "push-pull-pull-push-stream: multiplication: " + x;
	}));
	const declaration = (stream()(1));
	const consumption1 = (output("output50"))(multiplication)(input("input50"))(stream(false,0));
	const consumption2 = (output("output51"))(multiplication)(input("input51"))(stream(false,0,false));
	const production1 = (stream(true))(initialization(6));
	const production2 = (stream(true))(initialization(7));
	return check(effectuality, log, "push-pull-pull-push-stream", [], [[0, []]], disjunction((production2),(consumption2),(consumption1),(production1))(declaration));
})();

// run output push-push-pull-pull-watermark-stream input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const multiplication = effectualityLift(effectuality)(function(x1, x2){
		return x1 * x2;
	})(log(1)(function(...x){
		return "push-push-pull-pull-watermark-stream: multiplication: " + x;
	}));
	const declaration = (stream()(1,0)); // watermark 0: production interrupted until consumption (buffer length 1 greater than 0) 
	const consumption1 = (log(1)(function(...x){
		return "push-push-pull-pull-watermark-stream: consumption1 end: " + x;
	}))(output("output60"))(multiplication)(input("input60"))(stream(false,0))(log(1)(function(...x){
		return "push-push-pull-pull-watermark-stream: consumption1 start: " + x;
	}));
	const consumption2 = (log(1)(function(...x){
		return "push-push-pull-pull-watermark-stream: consumtion2 end: " + x;
	}))(output("output61"))(multiplication)(input("input61"))(stream(false,0,false))(log(1)(function(...x){
		return "push-push-pull-pull-watermark-stream: consumption2 start: " + x;
	}));
	const production1 = (log(1)(function(...x){
		return "push-push-pull-pull-watermark-stream: production1 end: " + x;
	}))(stream(true))(initialization(6))(log(1)(function(...x){
		return "push-push-pull-pull-watermark-stream: production1 start: " + x;
	}));
	const production2 = (log(1)(function(...x){
		return "push-push-pull-pull-watermark-stream: production2 end: " + x;
	}))(stream(true))(initialization(7))(log(1)(function(...x){
		return "push-push-pull-pull-watermark-stream: production2 start: " + x;
	}));
	return check(effectuality, log, "push-push-pull-pull-watermark-stream", [], [[0, []]], disjunction((consumption2),(consumption1),(production2),(production1))(declaration));
})();

// run output pull-pull-ondemand-stream input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const multiplication = effectualityLift(effectuality)(function(x1, x2){
		return x1 * x2;
	})(log(1)(function(...x){
		return "push-pull-pull-push-stream: multiplication: " + x;
	}));
	const ondemand = (initialization(10));
	const declaration = (stream()(1,false,(ondemand)));
	const consumption1 = (output("output52"))(multiplication)(input("input52"))(stream(false,0));
	const consumption2 = (output("output53"))(multiplication)(input("input53"))(stream(false,0,false));
	return check(effectuality, log, "pull-pull-ondemand-stream", [], [[0, []]], disjunction((consumption2),(consumption1))(declaration));
})();

// run output push-pull-asynchronous-stream input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const initialization = effectualityInitialization(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function cause(x, y){
		return 1 * x + 1 * y;
	})(log(1)(function(x, y){
		return "output push-pull-asynchronous-stream input: addition: " + x + " + " + y;
	}));
	const declaration = (stream()(2));
	const consumption1 = (output("output54"))(addition)(input("input54"))(stream(false,0));
	const consumption2 = (output("output55"))(addition)(input("input55"))(stream(false,1));
	const production10 = (stream(true))(initialization(0));
	const production11 = (stream(true))(initialization(5));
	const production12 = (stream(true))(initialization(10));
	const production13 = (stream(true))(initialization(15));
	const production14 = (stream(true))(initialization(20));
	const production20 = (stream(true))(initialization(0));
	const production21 = (stream(true))(initialization(7));
	const production22 = (stream(true))(initialization(14));
	const production23 = (stream(true))(initialization(21));
	const production24 = (stream(true))(initialization(28));
	const consumption10 = (consumption1)(delay(0));
	const consumption11 = (consumption1)(delay(1000));
	const consumption12 = (consumption1)(delay(2000));
	const consumption13 = (consumption1)(delay(3000));
	const consumption14 = (consumption1)(delay(4000));
	const consumption15 = (consumption1)(delay(5000));
	const consumption16 = (consumption1)(delay(6000));
	const consumption17 = (consumption1)(delay(7000));
	const consumption18 = (consumption1)(delay(8000));
	const consumption19 = (consumption1)(delay(9000));
	const consumption20 = (consumption2)(delay(500));
	const consumption21 = (consumption2)(delay(1500));
	const consumption22 = (consumption2)(delay(2500));
	const consumption23 = (consumption2)(delay(3500));
	const consumption24 = (consumption2)(delay(4500));
	const consumption25 = (consumption2)(delay(5500));
	const consumption26 = (consumption2)(delay(6500));
	const consumption27 = (consumption2)(delay(7500));
	const consumption28 = (consumption2)(delay(8500));
	const consumption29 = (consumption2)(delay(9500));
	const termination1 = (stream(false,0,true))(delay(10000));
	const termination2 = (stream(false,1,true))(delay(10500));
	const production = disjunction((production24),(production14),(production23),(production13),(production22),(production12),(production21),(production11),(production20),(production10));
	const consumption = disjunction((consumption29),(consumption19),(consumption28),(consumption18),(consumption27),(consumption17),(consumption26),(consumption16),(consumption25),(consumption15),(consumption24),(consumption14),(consumption23),(consumption13),(consumption22),(consumption12),(consumption21),(consumption11),(consumption20),(consumption10));
	const termination = disjunction((termination2),(termination1));
	return check(effectuality, log, "output push-pull-asynchronous-stream input test output", [], [[0, []]], disjunction((termination),(consumption),(production))(declaration));
})();

// run output pull-push-asynchronous-stream input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const initialization = effectualityInitialization(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function cause(x, y){
		return 1 * x + 1 * y;
	})(log(1)(function(x, y){
		return "output pull-push-asynchronous-stream input: addition: " + x + " + " + y;
	}));
	const declaration = (stream()(2));
	const consumption1 = (output("output56"))(addition)(input("input56"))(stream(false,0));
	const consumption2 = (output("output57"))(addition)(input("input57"))(stream(false,1));
	const production10 = (stream(true))(initialization(0))(delay(1000));
	const production11 = (stream(true))(initialization(5))(delay(2000));
	const production12 = (stream(true))(initialization(10))(delay(4000));
	const production13 = (stream(true))(initialization(15))(delay(6000));
	const production14 = (stream(true))(initialization(20))(delay(8000));
	const production20 = (stream(true))(initialization(0))(delay(1500));
	const production21 = (stream(true))(initialization(7))(delay(3000));
	const production22 = (stream(true))(initialization(14))(delay(5000));
	const production23 = (stream(true))(initialization(21))(delay(7000));
	const production24 = (stream(true))(initialization(28))(delay(9000));
	const consumption10 = (consumption1)(delay(0));
	const consumption11 = (consumption1)(delay(0));
	const consumption12 = (consumption1)(delay(0));
	const consumption13 = (consumption1)(delay(0));
	const consumption14 = (consumption1)(delay(0));
	const consumption15 = (consumption1)(delay(0));
	const consumption16 = (consumption1)(delay(0));
	const consumption17 = (consumption1)(delay(0));
	const consumption18 = (consumption1)(delay(0));
	const consumption19 = (consumption1)(delay(0));
	const consumption20 = (consumption2)(delay(0));
	const consumption21 = (consumption2)(delay(0));
	const consumption22 = (consumption2)(delay(0));
	const consumption23 = (consumption2)(delay(0));
	const consumption24 = (consumption2)(delay(0));
	const consumption25 = (consumption2)(delay(0));
	const consumption26 = (consumption2)(delay(0));
	const consumption27 = (consumption2)(delay(0));
	const consumption28 = (consumption2)(delay(0));
	const consumption29 = (consumption2)(delay(0));
	const termination1 = (stream(false,0,true))(delay(10000));
	const termination2 = (stream(false,1,true))(delay(10500));
	const production = disjunction((production24),(production14),(production23),(production13),(production22),(production12),(production21),(production11),(production20),(production10));
	const consumption = disjunction((consumption29),(consumption19),(consumption28),(consumption18),(consumption27),(consumption17),(consumption26),(consumption16),(consumption25),(consumption15),(consumption24),(consumption14),(consumption23),(consumption13),(consumption22),(consumption12),(consumption21),(consumption11),(consumption20),(consumption10));
	const termination = disjunction((termination2),(termination1));
	return check(effectuality, log, "output pull-push-asynchronous-stream input test output", [], [[0, []]], disjunction((termination),(production),(consumption))(declaration));
})();

// run output asynchronous-ondemand-stream input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const initialization = effectualityInitialization(effectuality);
	const lift = effectualityLift(effectuality);
	const addition = lift(function cause(x, y){
		return 1 * x + 1 * y;
	})(log(1)(function(x, y){
		return "output asynchronous-ondemand-stream input: addition: " + x + " + " + y;
	}));
	const multiplication = lift(function cause(x, y){
		return x * y;
	})(log(1)(function(x, y){
		return "output asynchronous-ondemand-stream input: multiplication: " + x + " * " + y;
	}));
	const ondemand = (multiplication)(initialization(10))(delay(500));
	const declaration = (stream()(2,false,(ondemand)));
	const consumption1 = (output("output58"))(addition)(input("input58"))(stream(false,0));
	const consumption2 = (output("output59"))(addition)(input("input59"))(stream(false,1));
	const consumption10 = (consumption1)(delay(0));
	const consumption11 = (consumption1)(delay(1000));
	const consumption12 = (consumption1)(delay(2000));
	const consumption13 = (consumption1)(delay(3000));
	const consumption14 = (consumption1)(delay(4000));
	const consumption15 = (consumption1)(delay(5000));
	const consumption16 = (consumption1)(delay(6000));
	const consumption17 = (consumption1)(delay(7000));
	const consumption18 = (consumption1)(delay(8000));
	const consumption19 = (consumption1)(delay(9000));
	const consumption20 = (consumption2)(delay(0));
	const consumption21 = (consumption2)(delay(1000));
	const consumption22 = (consumption2)(delay(2000));
	const consumption23 = (consumption2)(delay(3000));
	const consumption24 = (consumption2)(delay(4000));
	const consumption25 = (consumption2)(delay(5000));
	const consumption26 = (consumption2)(delay(6000));
	const consumption27 = (consumption2)(delay(7000));
	const consumption28 = (consumption2)(delay(8000));
	const consumption29 = (consumption2)(delay(9000));
	const termination1 = (stream(false,0,true))(delay(10000));
	const termination2 = (stream(false,1,true))(delay(10500));
	const consumption = disjunction((consumption29),(consumption19),(consumption28),(consumption18),(consumption27),(consumption17),(consumption26),(consumption16),(consumption25),(consumption15),(consumption24),(consumption14),(consumption23),(consumption13),(consumption22),(consumption12),(consumption21),(consumption11),(consumption20),(consumption10));
	const termination = disjunction((termination2),(termination1));
	return check(effectuality, log, "output asynchronous-ondemand-stream input test output", [], [[0, []]], disjunction((termination)(consumption))(declaration));
})();

// run output constant-id-observation input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const multiplication = lift(function cause(x, y){
		return x * y;
	})(log(1)(function(...x){
		return "output constant-id-observation input: multiplication: " + x;
	}));
	const success = function(x){
		if (x === "42"){
			return "output constant-id-observation input: success: " + x;
		}
	};
	const error = function(x){
		if (x !== "42"){
			return "output constant-id-observation input: error: expected: 42: got: " + x;
		}
	};
	return check(effectuality, log, "output constant-id-observation input", [7], [["42", "6", 7, []]], (log(1)(success))(log(2)(error))(input("output70"))(delay(2000))(observation(true)("observation1")())(input("input70"))(observation(false)(false)("observation1")((output("output70"))(multiplication)(delay(1000)))));
})();

// run output variable-id-observation input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const selection = lift(function cause(x, id1, y){
		return [x, y];
	}, true);
	const multiplication = lift(function cause(x, y){
		return x * y;
	})(log(1)(function(...x){
		return "output variable-id-observation input: multiplication: " + x;
	}));
	const success = function(x){
		if (x === "42"){
			return "output variable-id-observation input: success: " + x;
		}
	};
	const error = function(x){
		if (x !== "42"){
			return "output variable-id-observation input: error: expected: 42: got: " + x;
		}
	};
	return check(effectuality, log, "output variable-id-observation input", [7], [["42", "observation1", "6", "observation1", 7, []]], (log(1)(success))(log(2)(error))(input("output71"))(delay(2000))(observation(true)()(selection))(initialization("observation1"))(input("input71"))(observation(false)(false)()((output("output71"))(multiplication)(delay(1000))))(initialization("observation1")));
})();

// run output constant-id-cancellable-observation input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const unit = effectualityUnit(effectuality);
	const registration = observation()(true);
	const cancellation = observation()(false);
	const selection = lift(function cause(x, id2, y){
		return [x, y];
	}, true);
	const multiplication = lift(function cause(x, y){
		return x * y;
	})(log(1)(function(...x){
		return "output constant-id-cancellable-observation input: multiplication: " + x;
	}));
	const success = function(x){
		if (x === "42"){
			return "output constant-id-cancellable-observation input: success: " + x;
		}
	};
	const error = function(x){
		if (x !== "42"){
			return "output constant-id-cancellable-observation input: error: expected: 42: got: " + x;
		}
	};
	return check(effectuality, log, "output constant-id-cancellable-observation input", [7], [["42", 8, 0, 7, []]], (log(1)(success))(log(2)(error))(input("output72"))(delay(2000))(observation(true)("observation1")(selection))(initialization(8))(cancellation)(delay(2000))(injunction()((observation(true)("observation1")(selection))(input("input72"))))(observation(false)(true)("observation1")((output("output72"))(multiplication)(delay(1000))))(registration));
})();

// run output variable-id-cancellable-observation input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const initialization = effectualityInitialization(effectuality);
	const unit = effectualityUnit(effectuality);
	const registration = observation()(true);
	const cancellation = observation()(false);
	const selection = lift(function cause(x, id2, y){
		return [x, y];
	}, true);
	const multiplication = lift(function cause(x, y){
		return x * y;
	})(log(1)(function(...x){
		return "output variable-id-cancellable-observation input: multiplication: " + x;
	}));
	const success = function(x){
		if (x === "42"){
			return "output variable-id-cancellable-observation input: success: " + x;
		}
	};
	const error = function(x){
		if (x !== "42"){
			return "output variable-id-cancellable-observation input: error: expected: 42: got: " + x;
		}
	};
	return check(effectuality, log, "output variable-id-cancellable-observation input", [7], [["42", "observation1", 8, 0, 7, []]], (log(1)(success))(log(2)(error))(input("output73"))(delay(2000))(observation(true)()(selection))(initialization("observation1"))(initialization(8))(cancellation)(delay(2000))(injunction()((observation(true)()(selection))(initialization("observation1"))(input("input73"))))(injunction(unit)((observation(false)(true)()((output("output73"))(multiplication)(delay(1000))))(initialization("observation1"))))(registration));
})();

// run output request canceled-any input test
runTest(function tests(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component, input, output){
	const lift = effectualityLift(effectuality);
	const any = effectualityConcurrenceAny(effectuality, concurrence);
	const registration = request()(true);
	const cancellation = request()(false);
	const indexation = effectualityIndexation(effectuality);
	const filterDuplication = lift(function(index, id, ...filters){
		const filter = filters[index];
		return [id, filter];
	}, true);
	const idDuplication = lift(function(value, record, id){
		return id;
	});
	const valueDuplication = lift(function(id, value){
		return value;
	});
	const soldToRequest = request(function(sql){
		if (sql === "SELECT * FROM soldTo WHERE soldToNumber = 6"){
			return [{ soldToNumber: 6, soldToName: "PretechEnergy", soldToAddress: "19 Miranda avenue, 76123 Plant Lake, USA", }];
		}
	}, 3000, true)(log(1)(function(...x){
		return "output request canceled-any input test: soldToRequest: " + x;
	}));
	const shipToRequest = request(function(sql){
		if (sql === "SELECT * FROM shipTo WHERE shipToNumber = 6"){
			return [{ shipToNumber: 6, shipToName: "AtlasIntercom", shipToAddress: "3 Steep street, 81234 San Alonzo, USA", soldToNumber: 6, }];
		}
	}, 2000, true)(log(1)(function(...x){
		return "output request canceled-any input test: shipToRequest: " + x;
	}));
	const materialRequest = request(function(sql){
		if (sql === "SELECT * FROM material WHERE materialNumber = 6"){
			return [{ materialNumber: 6, materialName: "Z14132 50W led bulb", }];
		}
	}, 3000, true)(log(1)(function(...x){
		return "output request canceled-any input test: matrialRequest: " + x;
	}));
	const soldToFilter = lift(function(soldToNumber){
		return "SELECT * FROM soldTo WHERE soldToNumber = " + soldToNumber;
	})(log(1)(function(...x){
		return "output request canceled-any input test: soldToFilter: " + x;
	}));
	const shipToFilter = lift(function(shipToNumber){
		return "SELECT * FROM shipTo WHERE shipToNumber = " + shipToNumber;
	})(log(1)(function(...x){
		return "output request canceled-any input test: shipToFilter: " + x;
	}));
	const materialFilter = lift(function(materialNumber){
		return "SELECT * FROM material WHERE materialNumber = " + materialNumber;
	})(log(1)(function(...x){
		return "output request canceled-any input test: materialFilter: " + x;
	}));
	const soldToName = lift(function(records){
		if (records.length !== 0){
			return records[0].soldToName;
		}
		return "";
	})(log(2)(function(...x){
		return "output request canceled-any input test: error: soldToName should not occur: got: " + x;
	}));
	const shipToName = lift(function(records){
		if (records.length !== 0){
			return records[0].shipToName;
		}
		return "";
	})(log(1)(function(...x){
		return "output request canceled-any input test: shipToName: " + x;
	}));
	const materialName = lift(function(records){
		if (records.length !== 0){
			return records[0].materialName;
		}
		return "";
	})(log(2)(function(...x){
		return "output request canceled-any input test: error: materialName should not occur: got: " + x;
	}));
	const expected = ["AtlasIntercom","AtlasIntercom",0,"AtlasIntercom",[{"shipToNumber":6,"shipToName":"AtlasIntercom","shipToAddress":"3 Steep street, 81234 San Alonzo, USA","soldToNumber":6}],0,"SELECT * FROM shipTo WHERE shipToNumber = 6",1,0,"SELECT * FROM material WHERE materialNumber = 6","SELECT * FROM shipTo WHERE shipToNumber = 6","SELECT * FROM soldTo WHERE soldToNumber = 6","6",[]];
	return check(effectuality, log, "output request canceled-any input test output", [], [expected], (input("output13"))(output("output13"))(valueDuplication)(cancellation)(idDuplication)(any(...indexation((materialName)(materialRequest)(filterDuplication),(shipToName)(shipToRequest)(filterDuplication),(soldToName)(soldToRequest)(filterDuplication))))(registration)(conjunction((materialFilter),(shipToFilter),(soldToFilter)))(input("input13")));
})();

</script>


<script> "use strict"

/////////////////////////
// web applications (pure)

const applications = {
	"web-application#1":
		// application: Effectuality -> Concurrence -> Recurrence -> Conjunction -> Disjunction -> Injunction -> Log -> Observation -> Stream -> Delay -> Signal -> Request -> Component -> Effectuality ((() -> ()) -> (() -> ()))
		function application(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component){
			// Hello World!
			const declaration = (component(true)("hello-world")({
				description: function(){
					return { DIV: ["Hello World!"] };
				},
			}));
			const definition = (component("hello-world")());
			return (definition)(declaration);
		},
	"web-application#2":
		// application: Effectuality -> Concurrence -> Recurrence -> Conjunction -> Disjunction -> Injunction -> Log -> Observation -> Stream -> Delay -> Signal -> Request -> Component -> Effectuality ((() -> ()) -> (() -> ()))
		function application(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component){
			// Asynchronous side-effect
			const declaration = (component(true)("asynchronous-square")({
				description: function(type, properties){
					return { DIV: [
						{ INPUT: [], value: properties.key || "4" }, " input", [], 
						{ INPUT: [], value: properties.value || "16" }, " asynchronous output (3 second delay): input * input",
					], "data-key": properties.key || "" };
				},
				properties:{
					key: [elementNode => elementNode.firstElementChild, "value"],
				},
				effects:[
					[
						["value", (effectuality(function implication(effect){
							return function cause(causeValue, causeName, effectName, ...u){
								const effectValue = causeValue * causeValue;
								return effect(effectValue, causeValue, causeName, effectName, ...u);
							};
						}))(delay(3000)), componentNode => componentNode.lastElementChild],
						["data-key", function(componentNode){
							return componentNode.firstElementChild.value;
						}],
					],
				],
				events:{
					change: true,
				},
			}));
			const definition = component("asynchronous-square")();
			return (definition)(declaration);
		},
	"web-application#3":
		// application: Effectuality -> Concurrence -> Recurrence -> Conjunction -> Disjunction -> Injunction -> Log -> Observation -> Stream -> Delay -> Signal -> Request -> Component -> Effectuality ((() -> ()) -> (() -> ()))
		function application(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component){
			// 3 levels of component dependencies
			const calculator = (component(true)("calculator")({
				description: function(type, properties){
					return { DIV: [
						["sum", { a: "6", b: "2" }], " a", [],
						["sum", { a: "7", b: "3" }], " b", [],
						["cell", { value: "80" }, "total"], " c = a * b",
					] };
				},
				subcomponents:[
					["cell", "", "value", function(componentNode, subcomponentNode, subcomponentIndex, propertyName){
						const a = componentNode.firstComponentChild("value");
						const b = subcomponentNode.previousComponentSibling("value");
						return a * b;
					}, "total"],
				],
			}));
			const sum = (component(true)("sum")({
				description: function(type, properties){
					return { SPAN: [
						["cell", { value: properties.a || "" }], " + ",
						["cell", { value: properties.b || "" }], " = ",
						["cell", { value: 1 * (properties.a || "") + 1 * (properties.b || "") }, "total"],
					] };
					//todo implement "hot" properties (hot properties should be evaluated at artificial "hot" event)
				},
				states:{
					value: function(componentNode){
						return componentNode.lastComponentChild.value;
					},
				},
				properties:{
					value: true,
				},
				subcomponents:[
					["cell", "", "value", function(componentNode, subcomponentNode, subcomponentIndex, propertyName){
						const a = componentNode.firstComponentChild("value");
						const b = subcomponentNode.previousComponentSibling("value");
						return 1 * a + 1 * b;
					}, "total"],
				],
			}));
			const cell = (component(true)("cell")({
				description: function(type, properties){
					return { INPUT: [], value: (properties.value || "").toString() };
				},
				states:{
					value: function(componentNode){
						return componentNode.value;
					},
				},
				properties:{
					value: true,
				},
				events:{
					change: true,
				},
			}));
			const declaration = (calculator)(sum)(cell);
			const definition = component("calculator")();
			return (definition)(declaration);
		},
	"web-application#4":
		// application: Effectuality -> Concurrence -> Recurrence -> Conjunction -> Disjunction -> Injunction -> Log -> Observation -> Stream -> Delay -> Signal -> Request -> Component -> Effectuality ((() -> ()) -> (() -> ()))
		function application(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component){
			// Inter-dependencies
			const user = (component(true)("user")({
				description: function(type, properties){
					return { SPAN: [
						["edit", { value: (properties.firstName || "").trim() }, "firstName"], " first name", [],
						["edit", { value: (properties.lastName || "").trim() }, "lastName"], " last name", [],
						["edit", { value: ((properties.firstName || "") + " " + (properties.lastName || "")).trim() }, "fullName"], " full name",
					] };
				},
				properties:{
					firstName: true,
					lastName: true,
					fullName: true,
				},
				subcomponents:[
					["edit", "", "value", function(componentNode, subcomponentNode, subcomponentIndex, propertyName){
						const fullName = componentNode.lastComponentChild("value");
						return (fullName.split(" ")[0] || "").trim();
					}, "firstName"],
					["edit", "", "value", function(componentNode, subcomponentNode, subcomponentIndex, propertyName){
						const firstName = componentNode.firstComponentChild("value");
						const lastName = subcomponentNode.previousComponentSibling("value");
						return (firstName + " " + lastName).trim();
					}, "fullName"],
					["edit", "", "value", function(componentNode, subcomponentNode, subcomponentIndex, propertyName){
						const fullName = componentNode.lastComponentChild("value");
						return (fullName.split(" ")[1] || "").trim();
					}, "lastName"],
				],
			}));
			const edit = (component(true)("edit")({
				description: function(type, properties){
					return { INPUT: [], value: properties.value || "" };
				},
				states:{
					value: function(componentNode){
						return componentNode.value;
					},
				},
				properties:{
					value: true,
				},
				events:{
					change: true,
				},
			}));
			const declaration = (user)(edit);
			const definition = component("user")();
			return (definition)(declaration);
		},
	"web-application#5":
		// application: Effectuality -> Concurrence -> Recurrence -> Conjunction -> Disjunction -> Injunction -> Log -> Observation -> Stream -> Delay -> Signal -> Request -> Component -> Effectuality ((() -> ()) -> (() -> ()))
		function application(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component){
			// Todo list
			const todo = (component(true)("todo")({
				description: function(type, properties){
					return { DIV: [
						{ DIV: [{ B: ["Todo list:"] }] },
						["list"], [],
						["edit"], " new item",
					], "data-new": properties.new || "" };
				},
				states:{
					"new": componentNode => componentNode.lastComponentChild("value"),
				},
				subcomponents:[
					["list", "", "data-new", componentNode => componentNode("new")],
				],
			}));
			const list = (component(true)("list")({
				description: function(type, properties){
					return { DIV: [] };
				},
				"properties":{
					"data-new": "data-new",
				},
				effects:[
					[
						["data-value", (component("item")(true))(effectuality(function implication(effect){
							return function cause(value, ...x){
								return effect({ value: value }, value, ...x);
							};
						}))],
						["data-key", componentNode => componentNode["data-new"]],
					],
				],
			}));
			const item = (component(true)("item")({
				description: function(type, properties){
					if (properties.value){
						return { DIV: [
							{ INPUT: [], type: "checkbox", checked: properties.done? "": null }, " ",
							{ SPAN: [properties.value], contenteditable: "", title: "double-click to edit or erase" },
						] };
					}
				},
				states:{
					value: componentNode => componentNode.lastElementChild.innerText,
				},
				properties:{
					value: true,
				},
				presence: componentNode => componentNode("value"),
				events:{
					blur: "span",
				},
			}));
			const edit = (component(true)("edit")({
				description: function(type, properties){
					return { INPUT: [], value: properties.value || "" };
				},
				states:{
					value: componentNode => componentNode.value,
				},
				properties:{
					value: true,
				},
				events:{
					change: true,
				},
				effects:[
					[
						["value", (effectualityInitialization(effectuality)(""))], // reset input
						["data-value", componentNode => componentNode.value],
					],
				],
			}));
			const declaration = (todo)(list)(item)(edit);
			const definition = component("todo")();
			return (definition)(declaration);
		},
	"web-application#6":
		// application: Effectuality -> Concurrence -> Recurrence -> Conjunction -> Disjunction -> Injunction -> Log -> Observation -> Stream -> Delay -> Signal -> Request -> Component -> Effectuality ((() -> ()) -> (() -> ()))
		function application(effectuality, concurrence, recurrence, conjunction, disjunction, injunction, log, observation, stream, delay, signal, request, component){
			// Counter
			const declaration = (component(true)("counter")({
				description: function(type, properties){
					return {
						DIV: [
							"Counter: ", { SPAN: [properties.count || "0"] }, [],
						 	{ BUTTON: ["increment"] },
						],
					};
				},
				properties:{
					count: true,
				},
				events:{
					click: ["value", function(node, target){
						if (target.tagName === "BUTTON"){
							return 1 + node.firstElementChild.innerText * 1;
						}
					}, node => node.firstElementChild, "innerText"],
				},
			}));
			const definition = component("counter")();
			return (definition)(declaration);
		},
};

</script>

<script> "use strict"

//////////////////////
// IFrames (framework)

if (!location.hash){
	const title = document.createElement("H1");
	title.appendChild(document.createTextNode("Effectuality"));
	document.body.appendChild(title);
	// Effectuality web-application demos
	Object.keys(applications).forEach(function(key){
		const frame = document.createElement("IFRAME");
		frame.width = "100%";
		frame.height = "200em";
		frame.src = location.href + "#" + key;
		document.body.appendChild(frame);
	});
	// Effectuality self-tests
	const frame0 = document.createElement("IFRAME");
	frame0.width = "100%";
	frame0.height = "975em";
	frame0.src = location.href + "#self-tests";
	document.body.appendChild(frame0);
	// Effectuality sample
	const frame00 = document.createElement("IFRAME");
	frame00.width = "100%";
	frame00.height = "2440em";
	frame00.src = location.href + "#sample";
	document.body.appendChild(frame00);
}
else{
	const name = location.hash.substr(1);
	if (name === "self-tests"){
		document.getElementById("self-tests").style.display = "block";
		compilation()();
	}
	else if (name === "sample"){
		document.getElementById("effectuality").value = Effectuality.toString();
		document.getElementById("sample-run").onclick = function(){
			function application(effectuality){
				// input: Effectuality (((String, u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
				const input = effectuality(function implication(effect){
					// effect: (String, u1, u2, ...) -> ()
					// cause: (u1, u2, ...) -> ()
					return function cause(...x){
						const element = document.getElementById("sample-input");
						const value = element? element.value: "";
						effect(value, ...x);
					};
				});
				// output: Effectuality (((String, u1, u2, ...) -> ()) -> ((String, u1, u2, ...) -> ()))
				const output = effectuality(function implication(effect){
					// effect: (String, u1, u2, ...) -> ()
					// cause: (String, u1, u2, ...) -> ()
					return function cause(value, ...x){
						const element = document.getElementById("sample-output");
						if (element){
							element.value = value;
						}
						effect(value, ...x);
					};
				});
				// delay: Effectuality (((u1, u2, ...) -> ()) -> ((u1, u2, ...) -> ()))
				const delay = effectuality(function implication(effect){
					// effect: (u1, u2, ...) -> ()
					// cause: (u1, u2, ...) -> ()
					return function cause(...x){
						setTimeout(function(){
							return effect(...x);
						}, 3000);
					};
				});
				// square: Effectuality (((Number, Number, u1, u2, ...) -> ()) -> ((Number, u1, u2, ...) -> ()))
				const square = effectuality(function implication(effect){
					// effect: (Number, Number, u1, u2, ...) -> ()
					// cause: (Number, u1, u2, ...) -> ()
					return function cause(value, ...x){
						return effect(value * value, value, ...x);
					};
				});
				return (output)(square)(delay)(input);
			}
			compilation(application)();
		};
		document.getElementById("sample").style.display = "block";
	}
	else{
		const subtitle = document.createElement("H2");
		subtitle.style.with = "100%";
		subtitle.appendChild(document.createTextNode(name));
		document.body.appendChild(subtitle);
		const source = document.createElement("button");
		source.style.float = "right";
		source.appendChild(document.createTextNode("view source"));
		source.tabIndex = -1;
		source.onclick = function(){
			const view = window.open("about:blank");
			view.document.title = name;
			view.document.body.innerHTML = '<textarea style="width: 100%; height: 100%">\t\t</textarea>';
			view.document.body.firstChild.value += applications[name].toString();
		};
		subtitle.appendChild(source);
		const application = applications[name];
		compilation(application)();
	}
}

</script>

</body>
</html>